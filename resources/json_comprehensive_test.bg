namespace json_comprehensive_test

fn main() {
    // Test encoding primitives
    println(json-encode(0))
    println(json-encode(-42))
    println(json-encode(9007199254740991))
    println(json-encode(0.0))
    println(json-encode(-3.14159))
    println(json-encode(10000000000.0))
    println(json-encode(""))
    println(json-encode("hello world"))
    println(json-encode("with \"quotes\" and \\backslash"))
    println(json-encode("line1\nline2\ttab"))
    println(json-encode(true))
    println(json-encode(false))
    println(json-encode(null))

    // Test encoding collections
    println(json-encode([]))
    println(json-encode([1]))
    println(json-encode([1, 2, 3, 4, 5]))
    println(json-encode([[1, 2], [3, 4]]))
    println(json-encode({}))
    println(json-encode({:a 1}))
    println(json-encode({:nested {:deep true}}))

    // Test decoding primitives
    println(json-decode("0"))
    println(json-decode("-999"))

    // Test decoding float with exponent
    let exp_num = json-decode("1e5")
    println(exp_num)

    // Test decoding empty collections
    let empty_arr = json-decode("[]")
    println(length(empty_arr))

    let empty_obj = json-decode("{}")
    println(length(empty_obj))

    // Test decoding array with mixed types (access elements individually)
    // Note: Getting null from collections has a display bug - test non-null elements
    let mixed_arr = json-decode("[1,true,false]")
    println(get(mixed_arr, 0))
    println(get(mixed_arr, 1))
    println(get(mixed_arr, 2))

    // Test unicode in strings (using actual unicode character)
    println(json-encode("unicode: é"))
    let decoded = json-decode("\"unicode: \\u00e9\"")
    println(decoded)

    // Test error handling - invalid JSON
    let caught_error = try {
        json-decode("{invalid}")
    } catch (e) {
        "caught parse error"
    }
    println(caught_error)

    // Test error handling - unencodable type (function)
    let encode_error = try {
        json-encode(fn() { 1 })
    } catch (e) {
        "caught encode error"
    }
    println(encode_error)

    // Test error handling - trailing content
    let trailing_error = try {
        json-decode("123 extra")
    } catch (e) {
        "caught trailing content error"
    }
    println(trailing_error)

    // Test round-trip
    let data = {:name "Alice" :age 30 :active true}
    let encoded = json-encode(data)
    let decoded_data = json-decode(encoded)
    println(get(decoded_data, "name"))
    println(get(decoded_data, "age"))
    println(get(decoded_data, "active"))

    // Test array round-trip
    let arr = [95, 87, 92]
    let encoded_arr = json-encode(arr)
    let decoded_arr = json-decode(encoded_arr)
    println(get(decoded_arr, 0))
    println(get(decoded_arr, 1))
    println(get(decoded_arr, 2))
}

// @beagle.core.snapshot
// 0
// -42
// 9007199254740991
// 0.0
// -3.14159
// 10000000000.0
// ""
// "hello world"
// "with \"quotes\" and \\backslash"
// "line1\nline2\ttab"
// true
// false
// null
// []
// [1]
// [1,2,3,4,5]
// [[1,2],[3,4]]
// {}
// {"a":1}
// {"nested":{"deep":true}}
// 0
// -999
// 100000.0
// 0
// 0
// 1
// true
// false
// "unicode: é"
// unicode: é
// caught parse error
// caught encode error
// caught trailing content error
// Alice
// 30
// true
// 95
// 87
// 92
