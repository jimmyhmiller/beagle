namespace async_parallel_test

use beagle.async as async
use beagle.effect as effect
use beagle.core as core

// Test that ImplicitAsyncHandler spawns actual threads and await works correctly.
// This test verifies that futures run on different threads by checking thread IDs.
// This proves the spawn+await bug is fixed (threaded spawn + threaded await).

fn main() {
    println("=== Async Parallel Execution Test ===")

    let main_thread_id = core/thread-id()

    // Use atoms to collect thread IDs from futures
    let thread_ids = atom([])

    // Spawn two futures that capture their thread ID
    let f1 = async/async(fn() {
        let id = core/thread-id()
        // Small sleep to ensure thread is actually used
        core/sleep(10)
        swap!(thread_ids, fn(ids) { push(ids, id) })
        id
    })

    let f2 = async/async(fn() {
        let id = core/thread-id()
        core/sleep(10)
        swap!(thread_ids, fn(ids) { push(ids, id) })
        id
    })

    // Wait for both
    let thread_id_1 = async/await(f1)
    let thread_id_2 = async/await(f2)

    // Verify futures ran on different threads than main
    let f1_different = thread_id_1 != main_thread_id
    let f2_different = thread_id_2 != main_thread_id

    if f1_different && f2_different {
        println("Futures ran on different threads than main: OK")
    } else {
        println("Futures ran on different threads than main: FAILED")
    }

    // Verify we got exactly 2 thread IDs recorded
    let ids = deref(thread_ids)
    let count = length(ids)
    if count == 2 {
        println("Thread IDs collected: OK")
    } else {
        println("Thread IDs collected: FAILED (expected 2, got", count, ")")
    }

    println("Final result: done")
}

// @beagle.core.snapshot
// === Async Parallel Execution Test ===
// Futures ran on different threads than main: OK
// Thread IDs collected: OK
// Final result: done
