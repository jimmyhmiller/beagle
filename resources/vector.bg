// This crap code from chatgpt that doesn't work...
// I should stop being lazy and just write one.
// I should also consider how to properly write this
// in rust with gc tracking and stuff

struct PersistentVectorNode {
    value
    left
    right
}

struct PersistentVector {
    root
    size
}

fn persistent_vector() {
    PersistentVector {
        root: null,  // start with an empty vector
        size: 0
    }
}

fn vector_get(node, idx, depth) {
    if depth == 0 {
        node.value
    } else {
        let branch_size = pow(2, depth - 1)  // Split at half the current depth
        if idx < branch_size {
            vector_get(node.left, idx, depth - 1)
        } else {
            vector_get(node.right, idx - branch_size, depth - 1)
        }
    }
}

fn vector_assoc(node, idx, value, depth) {
    if depth == 0 {
        PersistentVectorNode {
            value: value,
            left: null,
            right: null
        }
    } else {
        let branch_size = pow(2, depth - 1)  // We need to branch at half the depth

        let new_left = if node != null { node.left } else { null }
        let new_right = if node != null { node.right } else { null }

        if idx < branch_size {
            PersistentVectorNode {
                value: null,
                left: vector_assoc(new_left, idx, value, depth - 1),
                right: new_right
            }
        } else {
            PersistentVectorNode {
                value: null,
                left: new_left,
                right: vector_assoc(new_right, idx - branch_size, value, depth - 1)
            }
        }
    }
}

fn vector_push(vector, value) {
    let depth = log2(vector.size + 1)

    // If the tree is full at the current depth, create a new root with the left and right nodes
    let new_root = if vector.size == pow(2, depth) {
        PersistentVectorNode {
            value: null,
            left: vector.root,
            right: vector_assoc(null, 0, value, depth)
        }
    } else {
        vector_assoc(vector.root, vector.size, value, depth)
    }

    PersistentVector {
        root: new_root,
        size: vector.size + 1
    }
}
fn vector_get_value(vector, idx) {
    let depth = log2(vector.size)
    vector_get(vector.root, idx, depth)
}

fn log2_helper(n, result) {
    if n > 1 {
        log2_helper(n / 2, result + 1)
    } else {
        result
    }
}

fn log2(n) {
    log2_helper(n, 0)
}

fn mod(a, b) {
    a - (a / b) * b
}

fn pow(base, exp) {
    if exp == 0 {
        1
    } else {
        if exp == 1 {
            base
        } else {
            let half_pow = pow(base, exp / 2)
            if mod(exp, 2) == 0 {
                half_pow * half_pow
            } else {
                base * half_pow * half_pow
            }
        }
    }
}

fn main() {
    let vector = persistent_vector()
    let vector = vector_push(vector, 1)
    let vector = vector_push(vector, 2)
    let vector = vector_push(vector, 3)

    println(vector)
    
    let x = vector_get_value(vector, 0)
    let y = vector_get_value(vector, 1)
    println(x)
    println(y)
}