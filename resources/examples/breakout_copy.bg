namespace breakout_copy

// Breakout game using raylib via FFI
// Classic arcade game: destroy all bricks with the bouncing ball!

use beagle.ffi as ffi
use beagle.mutable-array as arr
// ============================================================
// Raylib Library Setup
// ============================================================

let raylib = ffi/load-library("/opt/homebrew/lib/libraylib.dylib")

// Core window functions
let rl_init_window = ffi/get-function(
    raylib, "InitWindow",
    [ffi/Type.I32, ffi/Type.I32, ffi/Type.String],
    ffi/Type.Void
)

let rl_close_window = ffi/get-function(
    raylib, "CloseWindow", [], ffi/Type.Void
)

let rl_window_should_close = ffi/get-function(
    raylib, "WindowShouldClose", [], ffi/Type.I32
)

let rl_set_target_fps = ffi/get-function(
    raylib, "SetTargetFPS", [ffi/Type.I32], ffi/Type.Void
)

// Drawing control
let rl_begin_drawing = ffi/get-function(
    raylib, "BeginDrawing", [], ffi/Type.Void
)

let rl_end_drawing = ffi/get-function(
    raylib, "EndDrawing", [], ffi/Type.Void
)

let rl_clear_background = ffi/get-function(
    raylib, "ClearBackground", [ffi/Type.U32], ffi/Type.Void
)

// Drawing shapes
let rl_draw_rectangle = ffi/get-function(
    raylib, "DrawRectangle",
    [ffi/Type.I32, ffi/Type.I32, ffi/Type.I32, ffi/Type.I32, ffi/Type.U32],
    ffi/Type.Void
)

let rl_draw_rectangle_lines = ffi/get-function(
    raylib, "DrawRectangleLines",
    [ffi/Type.I32, ffi/Type.I32, ffi/Type.I32, ffi/Type.I32, ffi/Type.U32],
    ffi/Type.Void
)

let rl_draw_circle = ffi/get-function(
    raylib, "DrawCircle",
    [ffi/Type.I32, ffi/Type.I32, ffi/Type.F32, ffi/Type.U32],
    ffi/Type.Void
)

let rl_draw_text = ffi/get-function(
    raylib, "DrawText",
    [ffi/Type.String, ffi/Type.I32, ffi/Type.I32, ffi/Type.I32, ffi/Type.U32],
    ffi/Type.Void
)

// Input - Keyboard
let rl_is_key_down = ffi/get-function(
    raylib, "IsKeyDown", [ffi/Type.I32], ffi/Type.I32
)

let rl_is_key_pressed = ffi/get-function(
    raylib, "IsKeyPressed", [ffi/Type.I32], ffi/Type.I32
)

// Input - Mouse
let rl_get_mouse_x = ffi/get-function(
    raylib, "GetMouseX", [], ffi/Type.I32
)

let rl_get_mouse_y = ffi/get-function(
    raylib, "GetMouseY", [], ffi/Type.I32
)

let rl_is_mouse_button_down = ffi/get-function(
    raylib, "IsMouseButtonDown", [ffi/Type.I32], ffi/Type.I32
)

let rl_get_fps = ffi/get-function(
    raylib, "GetFPS", [], ffi/Type.I32
)

let MOUSE_LEFT_BUTTON = 0

// Shader functions
// LoadShaderFromMemory(vsCode, fsCode) -> Shader
// Shader is a 16-byte struct: {u32 id, void* locs}
let rl_load_shader_from_memory = ffi/get-function(
    raylib, "LoadShaderFromMemory",
    [ffi/Type.String, ffi/Type.String],
    ffi/Type.Structure { types: [ffi/Type.U32, ffi/Type.Pointer] }
)

// BeginShaderMode takes Shader by value (16 bytes = 2 x u64 in registers)
let rl_begin_shader_mode = ffi/get-function(
    raylib, "BeginShaderMode",
    [ffi/Type.U64, ffi/Type.U64],
    ffi/Type.Void
)

let rl_end_shader_mode = ffi/get-function(
    raylib, "EndShaderMode", [], ffi/Type.Void
)

// UnloadShader takes Shader by value
let rl_unload_shader = ffi/get-function(
    raylib, "UnloadShader",
    [ffi/Type.U64, ffi/Type.U64],
    ffi/Type.Void
)

// GetTime returns seconds elapsed since InitWindow (as f64 bits)
let rl_get_time = ffi/get-function(
    raylib, "GetTime", [], ffi/Type.U64
)

// GetShaderLocation(shader, uniformName) -> int
let rl_get_shader_location = ffi/get-function(
    raylib, "GetShaderLocation",
    [ffi/Type.U64, ffi/Type.U64, ffi/Type.String],
    ffi/Type.I32
)

// SetShaderValue(shader, locIndex, value_ptr, uniformType)
// uniformType: 0=FLOAT, 1=VEC2, 2=VEC3, 3=VEC4
let rl_set_shader_value = ffi/get-function(
    raylib, "SetShaderValue",
    [ffi/Type.U64, ffi/Type.U64, ffi/Type.I32, ffi/Type.Pointer, ffi/Type.I32],
    ffi/Type.Void
)

// ============================================================
// Color Helper
// ============================================================

fn color(r, g, b, a) {
    r + (g * 256) + (b * 65536) + (a * 16777216)
}

fn rgb(r, g, b) {
    color(r, g, b, 255)
}

// Predefined colors
let RAYWHITE = rgb(245, 245, 245)
let BLACK = rgb(0, 0, 0)
let WHITE = rgb(255, 255, 255)
let RED = rgb(230, 41, 55)
let GREEN = rgb(0, 228, 48)
let BLUE = rgb(0, 121, 241)
let YELLOW = rgb(253, 249, 0)
let ORANGE = rgb(255, 161, 0)
let PINK = rgb(255, 109, 194)
let PURPLE = rgb(200, 122, 255)
let DARKGRAY = rgb(80, 80, 80)
let LIGHTGRAY = rgb(200, 200, 200)
let SKYBLUE = rgb(102, 191, 255)
let LIME = rgb(0, 158, 47)
let GOLD = rgb(255, 203, 0)
let MAROON = rgb(190, 33, 55)
let DARKBLUE = rgb(0, 82, 172)
let DARKGREEN = rgb(0, 117, 44)

// Key codes
let KEY_RIGHT = 262
let KEY_LEFT = 263
let KEY_DOWN = 264
let KEY_UP = 265
let KEY_SPACE = 32
let KEY_R = 82
let KEY_C = 67
let KEY_P = 80

// History Tree constants
let MAX_TREE_NODES = 500        // Global node limit across all branches

// ============================================================
// Helper Functions
// ============================================================

fn init_window(width, height, title) {
    rl_init_window(width, height, title)
}

fn close_window() {
    rl_close_window()
}

fn window_should_close() {
    rl_window_should_close() != 0
}

fn set_target_fps(fps) {
    rl_set_target_fps(fps)
}

fn begin_drawing() {
    rl_begin_drawing()
}

fn end_drawing() {
    rl_end_drawing()
}

fn clear_background(c) {
    rl_clear_background(c)
}

fn draw_rectangle(x, y, w, h, c) {
    rl_draw_rectangle(x, y, w, h, c)
}

fn draw_rectangle_lines(x, y, w, h, c) {
    rl_draw_rectangle_lines(x, y, w, h, c)
}

fn draw_circle(x, y, radius, c) {
    rl_draw_circle(x, y, radius, c)
}

fn draw_text(text, x, y, size, c) {
    rl_draw_text(text, x, y, size, c)
}

fn is_key_down(key) {
    rl_is_key_down(key) != 0
}

fn is_key_pressed(key) {
    rl_is_key_pressed(key) != 0
}

fn get_mouse_x() {
    rl_get_mouse_x()
}

fn get_mouse_y() {
    rl_get_mouse_y()
}

fn is_mouse_button_down(button) {
    rl_is_mouse_button_down(button) != 0
}

fn get_fps() {
    rl_get_fps()
}

// Shader functions
fn load_shader_from_memory(vs_code, fs_code) {
    // Returns a StructReturn { low, high }
    rl_load_shader_from_memory(vs_code, fs_code)
}

fn begin_shader_mode(shader) {
    // shader is StructReturn { low, high }
    rl_begin_shader_mode(shader.low, shader.high)
}

fn end_shader_mode() {
    rl_end_shader_mode()
}

fn unload_shader(shader) {
    rl_unload_shader(shader.low, shader.high)
}

fn get_time() {
    // Returns time as f64 bits - we need to convert to f32 for shader
    rl_get_time()
}

fn get_shader_location(shader, name) {
    rl_get_shader_location(shader.low, shader.high, name)
}

fn set_shader_value_float(shader, loc, value_buffer) {
    // uniformType 0 = SHADER_UNIFORM_FLOAT
    rl_set_shader_value(shader.low, shader.high, loc, value_buffer, 0)
}

fn set_shader_value_int(shader, loc, value_buffer) {
    // uniformType 4 = SHADER_UNIFORM_INT
    rl_set_shader_value(shader.low, shader.high, loc, value_buffer, 4)
}

// ============================================================
// Glow Shader for the Ball
// ============================================================

// Fragment shader for a glowing effect
let GLOW_FRAGMENT_SHADER = "
#version 330
in vec2 fragTexCoord;
in vec4 fragColor;
out vec4 finalColor;
uniform sampler2D texture0;
uniform int frame;  // Frame counter as integer

void main() {
    vec4 texelColor = texture(texture0, fragTexCoord);
    // Convert frame to time (assuming 60 fps)
    float time = float(frame) / 60.0;
    // Pulsing glow effect
    float pulse = 0.5 + 0.5 * sin(time * 8.0);
    float glow = pulse * 0.5;
    vec3 glowColor = vec3(1.0, 0.7, 0.2); // Golden glow
    vec3 finalRgb = texelColor.rgb + glowColor * glow * texelColor.a;
    finalColor = vec4(finalRgb, texelColor.a) * fragColor;
}
"

// ============================================================
// Game Constants
// ============================================================

let SCREEN_WIDTH = 800
let SCREEN_HEIGHT = 600

let PADDLE_WIDTH = 100
let PADDLE_HEIGHT = 15
let PADDLE_SPEED = 10  // Faster paddle for better control
let PADDLE_Y = SCREEN_HEIGHT - 50

let BALL_RADIUS = 8
let BALL_SPEED = 6

let BRICK_ROWS = 5
let BRICK_COLS = 10
let BRICK_WIDTH = 70
let BRICK_HEIGHT = 25
let BRICK_PADDING = 5
let BRICK_OFFSET_TOP = 60
let BRICK_OFFSET_LEFT = 35

// ============================================================
// Game State Structures
// ============================================================

struct Ball {
    x
    y
    dx
    dy
}

struct Brick {
    x
    y
    alive
    color
}

struct GameState {
    paddle_x
    paddle_prev_x  // Previous paddle position for velocity calculation
    ball
    bricks
    score
    lives
    game_over
    won
    ball_attached  // Ball attached to paddle at start
}

struct StepResult {
    done
    score
    state
    frame
    resume_cont
}

struct LoopCtx {
    shader_ctx
    history_tree
    pause_node_idx    // Current position when paused (for navigation)
    just_resumed
}

// ============================================================
// Brick Management
// ============================================================

fn get_brick_color(row) {
    if row == 0 {
        RED
    } else if row == 1 {
        ORANGE
    } else if row == 2 {
        YELLOW
    } else if row == 3 {
        GREEN
    } else {
        SKYBLUE
    }
}

fn create_brick(row, col) {
    let x = BRICK_OFFSET_LEFT + col * (BRICK_WIDTH + BRICK_PADDING)
    let y = BRICK_OFFSET_TOP + row * (BRICK_HEIGHT + BRICK_PADDING)
    Brick {
        x: x,
        y: y,
        alive: true,
        color: get_brick_color(row)
    }
}

fn create_row_bricks(row, col, acc) {
    if col >= BRICK_COLS {
        acc
    } else {
        let brick = create_brick(row, col)
        create_row_bricks(row, col + 1, push(acc, brick))
    }
}

fn create_all_bricks(row, acc) {
    if row >= BRICK_ROWS {
        acc
    } else {
        let row_bricks = create_row_bricks(row, 0, [])
        let new_acc = concat(acc, row_bricks)
        create_all_bricks(row + 1, new_acc)
    }
}

fn create_bricks() {
    create_all_bricks(0, [])
}

fn count_alive_bricks(bricks, i, count) {
    if i >= length(bricks) {
        count
    } else {
        let brick = bricks[i]
        let new_count = if brick.alive { count + 1 } else { count }
        count_alive_bricks(bricks, i + 1, new_count)
    }
}

// ============================================================
// Initial Game State
// ============================================================

fn create_initial_state() {
    let paddle_x = SCREEN_WIDTH / 2 - PADDLE_WIDTH / 2
    let ball = Ball {
        x: SCREEN_WIDTH / 2,
        y: PADDLE_Y - BALL_RADIUS - 1,
        dx: BALL_SPEED,
        dy: 0 - BALL_SPEED
    }
    GameState {
        paddle_x: paddle_x,
        paddle_prev_x: paddle_x,
        ball: ball,
        bricks: create_bricks(),
        score: 0,
        lives: 3,
        game_over: false,
        won: false,
        ball_attached: true
    }
}

// ============================================================
// Collision Detection
// ============================================================

fn abs(n) {
    if n < 0 { 0 - n } else { n }
}

// Simple sqrt using Newton's method (5 iterations)
fn sqrt_iter(x, guess, i) {
    if i <= 0 {
        guess
    } else {
        let better = (guess + x / guess) / 2
        sqrt_iter(x, better, i - 1)
    }
}

fn sqrt(x) {
    if x <= 0 {
        0
    } else {
        sqrt_iter(x, x / 2, 8)
    }
}

// Clamp a value between min and max
fn clamp(val, min_val, max_val) {
    if val < min_val {
        min_val
    } else if val > max_val {
        max_val
    } else {
        val
    }
}

// Sign function: returns -1, 0, or 1
fn sign(n) {
    if n < 0 { 0 - 1 } else if n > 0 { 1 } else { 0 }
}

fn ball_rect_collision(ball, rx, ry, rw, rh) {
    // Find closest point on rectangle to ball center
    let closest_x = if ball.x < rx {
        rx
    } else if ball.x > rx + rw {
        rx + rw
    } else {
        ball.x
    }

    let closest_y = if ball.y < ry {
        ry
    } else if ball.y > ry + rh {
        ry + rh
    } else {
        ball.y
    }

    // Calculate distance
    let dist_x = ball.x - closest_x
    let dist_y = ball.y - closest_y
    let dist_squared = dist_x * dist_x + dist_y * dist_y

    dist_squared < BALL_RADIUS * BALL_RADIUS
}

// ============================================================
// Game Logic
// ============================================================

fn update_paddle(state) {
    let dx = if is_key_down(KEY_LEFT) { 0 - PADDLE_SPEED } else { 0 }
    let dx2 = if is_key_down(KEY_RIGHT) { dx + PADDLE_SPEED } else { dx }

    let new_x = state.paddle_x + dx2

    // Clamp to screen
    let clamped_x = if new_x < 0 {
        0
    } else if new_x + PADDLE_WIDTH > SCREEN_WIDTH {
        SCREEN_WIDTH - PADDLE_WIDTH
    } else {
        new_x
    }

    GameState {
        paddle_x: clamped_x,
        paddle_prev_x: state.paddle_x,  // Track previous position
        ball: state.ball,
        bricks: state.bricks,
        score: state.score,
        lives: state.lives,
        game_over: state.game_over,
        won: state.won,
        ball_attached: state.ball_attached
    }
}

fn launch_ball(state) {
    if state.ball_attached && is_key_pressed(KEY_SPACE) {
        // Launch with angle based on paddle movement for immediate control feel
        let paddle_velocity = state.paddle_x - state.paddle_prev_x
        // Add paddle influence: moving paddle adds to launch angle
        // Scale: paddle_velocity / 5 gives reasonable influence
        let launch_dx = 2 + (paddle_velocity / 5)
        // Clamp launch_dx to reasonable range
        let clamped_dx = clamp(launch_dx, 0 - 4, 4)

        let new_ball = Ball {
            x: state.ball.x,
            y: state.ball.y,
            dx: clamped_dx,
            dy: 0 - BALL_SPEED
        }
        GameState {
            paddle_x: state.paddle_x,
            paddle_prev_x: state.paddle_prev_x,
            ball: new_ball,
            bricks: state.bricks,
            score: state.score,
            lives: state.lives,
            game_over: state.game_over,
            won: state.won,
            ball_attached: false
        }
    } else {
        state
    }
}

fn update_attached_ball(state) {
    if state.ball_attached {
        let ball_x = state.paddle_x + PADDLE_WIDTH / 2
        let ball = Ball {
            x: ball_x,
            y: PADDLE_Y - BALL_RADIUS - 1,
            dx: state.ball.dx,
            dy: state.ball.dy
        }
        GameState {
            paddle_x: state.paddle_x,
            paddle_prev_x: state.paddle_prev_x,
            ball: ball,
            bricks: state.bricks,
            score: state.score,
            lives: state.lives,
            game_over: state.game_over,
            won: state.won,
            ball_attached: state.ball_attached
        }
    } else {
        state
    }
}

fn update_ball_position(state) {
    if state.ball_attached {
        state
    } else {
        let ball = state.ball
        let new_x = ball.x + ball.dx
        let new_y = ball.y + ball.dy

        // Wall collisions - bounce preserves speed
        let dx1 = if new_x - BALL_RADIUS <= 0 || new_x + BALL_RADIUS >= SCREEN_WIDTH {
            0 - ball.dx
        } else {
            ball.dx
        }

        // Ceiling collision
        let dy1 = if new_y - BALL_RADIUS <= 0 {
            0 - ball.dy
        } else {
            ball.dy
        }

        // Clamp position
        let clamped_x = if new_x - BALL_RADIUS < 0 {
            BALL_RADIUS
        } else if new_x + BALL_RADIUS > SCREEN_WIDTH {
            SCREEN_WIDTH - BALL_RADIUS
        } else {
            new_x
        }

        let clamped_y = if new_y - BALL_RADIUS < 0 {
            BALL_RADIUS
        } else {
            new_y
        }

        let new_ball = Ball {
            x: clamped_x,
            y: clamped_y,
            dx: dx1,
            dy: dy1
        }

        GameState {
            paddle_x: state.paddle_x,
            paddle_prev_x: state.paddle_prev_x,
            ball: new_ball,
            bricks: state.bricks,
            score: state.score,
            lives: state.lives,
            game_over: state.game_over,
            won: state.won,
            ball_attached: state.ball_attached
        }
    }
}

fn check_paddle_collision(state) {
    if state.ball_attached {
        state
    } else {
        let ball = state.ball
        if ball_rect_collision(ball, state.paddle_x, PADDLE_Y, PADDLE_WIDTH, PADDLE_HEIGHT) {
            // Calculate paddle velocity (how fast the paddle is moving)
            let paddle_velocity = state.paddle_x - state.paddle_prev_x

            // Calculate where on the paddle the ball hit
            // hit_pos: 0 = left edge, PADDLE_WIDTH = right edge
            let hit_pos = ball.x - state.paddle_x

            // Convert to range: -50 to +50 (for PADDLE_WIDTH=100)
            let offset_from_center = hit_pos - (PADDLE_WIDTH / 2)

            // Calculate dx based on hit position
            // At center (offset=0): dx = 0
            // At edges (offset=±50): dx = ±5
            // This gives nice angle control
            let position_dx = (offset_from_center * BALL_SPEED) / (PADDLE_WIDTH / 2)

            // Add paddle velocity influence (key to good control!)
            // Moving paddle adds "english" to the ball
            // Divide by 3 to make it influential but not overwhelming
            let velocity_bonus = paddle_velocity / 3

            // Combine position-based angle with paddle velocity
            let combined_dx = position_dx + velocity_bonus

            // Clamp dx to prevent too-horizontal shots
            let max_dx = BALL_SPEED - 2  // Leave room for dy
            let clamped_dx = clamp(combined_dx, 0 - max_dx, max_dx)

            // Ensure minimum dx magnitude for playability (no straight-up shots)
            let min_dx = 1
            let final_dx = if abs(clamped_dx) < min_dx {
                if clamped_dx < 0 { 0 - min_dx } else { min_dx }
            } else {
                clamped_dx
            }

            let new_ball = Ball {
                x: ball.x,
                y: PADDLE_Y - BALL_RADIUS - 1,
                dx: final_dx,
                dy: 0 - BALL_SPEED  // Always go up at full speed
            }

            GameState {
                paddle_x: state.paddle_x,
                paddle_prev_x: state.paddle_prev_x,
                ball: new_ball,
                bricks: state.bricks,
                score: state.score,
                lives: state.lives,
                game_over: state.game_over,
                won: state.won,
                ball_attached: state.ball_attached
            }
        } else {
            state
        }
    }
}

fn check_brick_collision_single(ball, brick) {
    if brick.alive && ball_rect_collision(ball, brick.x, brick.y, BRICK_WIDTH, BRICK_HEIGHT) {
        true
    } else {
        false
    }
}

fn update_bricks_after_collision(bricks, ball, i, new_bricks, hit) {
    if i >= length(bricks) {
        [new_bricks, hit]
    } else {
        let brick = bricks[i]
        if brick.alive && ball_rect_collision(ball, brick.x, brick.y, BRICK_WIDTH, BRICK_HEIGHT) {
            let dead_brick = Brick {
                x: brick.x,
                y: brick.y,
                alive: false,
                color: brick.color
            }
            update_bricks_after_collision(bricks, ball, i + 1, push(new_bricks, dead_brick), true)
        } else {
            update_bricks_after_collision(bricks, ball, i + 1, push(new_bricks, brick), hit)
        }
    }
}

fn check_brick_collisions(state) {
    if state.ball_attached {
        state
    } else {
        let result = update_bricks_after_collision(state.bricks, state.ball, 0, [], false)
        let new_bricks = result[0]
        let hit = result[1]

        if hit {
            // Bounce ball (simple vertical bounce)
            let ball = state.ball
            let new_ball = Ball {
                x: ball.x,
                y: ball.y,
                dx: ball.dx,
                dy: 0 - ball.dy
            }

            GameState {
                paddle_x: state.paddle_x,
                paddle_prev_x: state.paddle_prev_x,
                ball: new_ball,
                bricks: new_bricks,
                score: state.score + 10,
                lives: state.lives,
                game_over: state.game_over,
                won: state.won,
                ball_attached: state.ball_attached
            }
        } else {
            state
        }
    }
}

fn check_ball_lost(state) {
    if state.ball_attached {
        state
    } else {
        let ball = state.ball
        if ball.y + BALL_RADIUS > SCREEN_HEIGHT {
            let new_lives = state.lives - 1
            if new_lives <= 0 {
                GameState {
                    paddle_x: state.paddle_x,
                    paddle_prev_x: state.paddle_prev_x,
                    ball: state.ball,
                    bricks: state.bricks,
                    score: state.score,
                    lives: 0,
                    game_over: true,
                    won: false,
                    ball_attached: state.ball_attached
                }
            } else {
                // Reset ball to paddle
                let paddle_x = SCREEN_WIDTH / 2 - PADDLE_WIDTH / 2
                let new_ball = Ball {
                    x: paddle_x + PADDLE_WIDTH / 2,
                    y: PADDLE_Y - BALL_RADIUS - 1,
                    dx: BALL_SPEED,
                    dy: 0 - BALL_SPEED
                }
                GameState {
                    paddle_x: paddle_x,
                    paddle_prev_x: paddle_x,
                    ball: new_ball,
                    bricks: state.bricks,
                    score: state.score,
                    lives: new_lives,
                    game_over: false,
                    won: false,
                    ball_attached: true
                }
            }
        } else {
            state
        }
    }
}

fn check_win(state) {
    let alive = count_alive_bricks(state.bricks, 0, 0)
    if alive == 0 {
        GameState {
            paddle_x: state.paddle_x,
            paddle_prev_x: state.paddle_prev_x,
            ball: state.ball,
            bricks: state.bricks,
            score: state.score,
            lives: state.lives,
            game_over: true,
            won: true,
            ball_attached: state.ball_attached
        }
    } else {
        state
    }
}

fn update_game(state) {
    if state.game_over {
        // Check for restart
        if is_key_pressed(KEY_R) {
            create_initial_state()
        } else {
            state
        }
    } else {
        let s1 = update_paddle(state)
        let s2 = launch_ball(s1)
        let s3 = update_attached_ball(s2)
        let s4 = update_ball_position(s3)
        let s5 = check_paddle_collision(s4)
        let s6 = check_brick_collisions(s5)
        let s7 = check_ball_lost(s6)
        let s8 = check_win(s7)
        s8
    }
}

// ============================================================
// Rendering
// ============================================================

fn draw_bricks(bricks, i) {
    if i >= length(bricks) {
        0
    } else {
        let brick = bricks[i]
        if brick.alive {
            draw_rectangle(brick.x, brick.y, BRICK_WIDTH, BRICK_HEIGHT, brick.color)
            draw_rectangle_lines(brick.x, brick.y, BRICK_WIDTH, BRICK_HEIGHT, WHITE)
        }
        draw_bricks(bricks, i + 1)
    }
}

fn draw_lives(lives, i, x) {
    if i >= lives {
        0
    } else {
        draw_rectangle(x + i * 25, 10, 20, 10, RED)
        draw_lives(lives, i + 1, x)
    }
}

fn render(state, shader_ctx, frame) {
    begin_drawing()
    clear_background(rgb(20, 20, 30))

    // Update shader frame uniform for pulsing effect
    ffi/set-i32(shader_ctx.frame_buffer, 0, frame)
    set_shader_value_int(shader_ctx.shader, shader_ctx.frame_loc, shader_ctx.frame_buffer)

    // Draw bricks with shader for glowing effect
    begin_shader_mode(shader_ctx.shader)
    draw_bricks(state.bricks, 0)
    end_shader_mode()

    // Draw paddle
    draw_rectangle(state.paddle_x, PADDLE_Y, PADDLE_WIDTH, PADDLE_HEIGHT, SKYBLUE)
    draw_rectangle_lines(state.paddle_x, PADDLE_Y, PADDLE_WIDTH, PADDLE_HEIGHT, WHITE)

    // Draw ball with shader for glowing effect
    begin_shader_mode(shader_ctx.shader)
    draw_circle(state.ball.x, state.ball.y, BALL_RADIUS, GOLD)
    // Draw a larger, more transparent circle for glow halo
    draw_circle(state.ball.x, state.ball.y, BALL_RADIUS + 4, color(255, 200, 50, 100))
    end_shader_mode()

    // Draw UI
    let score_text = "Score: " ++ to-string(state.score)
    draw_text(score_text, 10, 10, 20, WHITE)

    // FPS counter
    let fps_text = "FPS: " ++ to-string(get_fps())
    draw_text(fps_text, 10, 35, 16, LIGHTGRAY)

    draw_text("Lives:", SCREEN_WIDTH - 150, 10, 20, WHITE)
    draw_lives(state.lives, 0, SCREEN_WIDTH - 80)

    if state.ball_attached {
        draw_text("Press SPACE to launch", SCREEN_WIDTH / 2 - 100, SCREEN_HEIGHT / 2, 20, LIGHTGRAY)
    }

    if state.game_over {
        if state.won {
            draw_text("YOU WIN!", SCREEN_WIDTH / 2 - 80, SCREEN_HEIGHT / 2 - 20, 40, GREEN)
        } else {
            draw_text("GAME OVER", SCREEN_WIDTH / 2 - 100, SCREEN_HEIGHT / 2 - 20, 40, RED)
        }
        draw_text("Press R to restart", SCREEN_WIDTH / 2 - 80, SCREEN_HEIGHT / 2 + 30, 20, LIGHTGRAY)
    }

    end_drawing()
}

// ============================================================
// History Tree System
// ============================================================

// A node in the history tree
struct TreeNode {
    state           // Game state at this node
    cont            // Continuation to resume from here
    frame_number    // Frame counter (global across all branches)
    parent_idx      // Index of parent node (-1 for root)
    children        // Array of child node indices
    depth           // Depth in tree (for limit enforcement)
    branch_id       // Which branch this node belongs to
}

// The history tree container
struct HistoryTree {
    nodes           // Raw mutable array of TreeNode
    node_count      // Atom tracking number of nodes
    current_idx     // Atom for currently active node
    branch_counter  // Atom for generating unique branch IDs
    current_branch  // Atom for current branch_id (for new frames)
}

// Create a new empty history tree
fn create_history_tree() {
    HistoryTree {
        nodes: arr/new-array(MAX_TREE_NODES),
        node_count: atom(0),
        current_idx: atom(-1),
        branch_counter: atom(0),
        current_branch: atom(0)
    }
}

// Get a node by index
fn tree_get_node(tree, idx) {
    if idx < 0 || idx >= deref(tree.node_count) {
        null
    } else {
        arr/read-field(tree.nodes, idx)
    }
}

// Get parent node index
fn tree_get_parent(tree, idx) {
    let node = tree_get_node(tree, idx)
    if node == null {
        -1
    } else {
        node.parent_idx
    }
}

// Get children of a node
fn tree_get_children(tree, idx) {
    let node = tree_get_node(tree, idx)
    if node == null {
        []
    } else {
        node.children
    }
}

// Get siblings of a node (other children of the same parent)
fn tree_get_siblings(tree, idx) {
    let node = tree_get_node(tree, idx)
    if node == null {
        []
    } else {
        let parent_idx = node.parent_idx
        if parent_idx < 0 {
            // Root has no siblings
            []
        } else {
            let parent = tree_get_node(tree, parent_idx)
            if parent == null {
                []
            } else {
                // Filter out current node from parent's children
                filter_out_idx(parent.children, idx, 0, [])
            }
        }
    }
}

// Helper to filter out an index from an array
fn filter_out_idx(arr, exclude_idx, i, acc) {
    if i >= length(arr) {
        acc
    } else {
        let item = arr[i]
        if item == exclude_idx {
            filter_out_idx(arr, exclude_idx, i + 1, acc)
        } else {
            filter_out_idx(arr, exclude_idx, i + 1, push(acc, item))
        }
    }
}

// Add a child to a node's children array (mutates the node in the array)
fn tree_add_child_to_node(tree, parent_idx, child_idx) {
    let parent = tree_get_node(tree, parent_idx)
    if parent != null {
        let new_children = push(parent.children, child_idx)
        let updated_parent = TreeNode {
            state: parent.state,
            cont: parent.cont,
            frame_number: parent.frame_number,
            parent_idx: parent.parent_idx,
            children: new_children,
            depth: parent.depth,
            branch_id: parent.branch_id
        }
        arr/write-field(tree.nodes, parent_idx, updated_parent)
    }
}

// Prune oldest nodes if tree exceeds limit
// Always preserves: path from root to current, branch points
fn tree_prune_if_needed(tree) {
    let count = deref(tree.node_count)
    if count <= MAX_TREE_NODES {
        // No pruning needed
        null
    } else {
        // For now, simple pruning: just cap at max
        // A more sophisticated approach would preserve branch points
        // and paths to current. This is a basic implementation.
        // TODO: Implement smarter pruning that preserves important nodes
        null
    }
}

// Prune oldest frames by shifting array down
fn tree_prune_oldest(tree, num_to_remove) {
    let count = deref(tree.node_count)
    let new_count = count - num_to_remove

    // Shift all nodes down and update their parent_idx
    shift_nodes_loop(tree, num_to_remove, count, 0)

    // Update count and current_idx
    let old_current = deref(tree.current_idx)
    let new_current = old_current - num_to_remove
    reset!(tree.node_count, new_count)
    reset!(tree.current_idx, if new_current < 0 { 0 } else { new_current })
    new_count
}

fn shift_nodes_loop(tree, offset, old_count, i) {
    let new_idx = i
    let old_idx = i + offset
    if old_idx >= old_count {
        null
    } else {
        let node = arr/read-field(tree.nodes, old_idx)
        if node != null {
            // Update parent_idx to reflect new positions
            let new_parent = node.parent_idx - offset
            // Update children indices
            let new_children = shift_children_indices(node.children, offset, 0, [])
            let updated_node = TreeNode {
                state: node.state,
                cont: node.cont,
                frame_number: node.frame_number,
                parent_idx: if new_parent < 0 { -1 } else { new_parent },
                children: new_children,
                depth: node.depth,
                branch_id: node.branch_id
            }
            arr/write-field(tree.nodes, new_idx, updated_node)
        }
        shift_nodes_loop(tree, offset, old_count, i + 1)
    }
}

fn shift_children_indices(children, offset, i, acc) {
    if i >= length(children) {
        acc
    } else {
        let old_child = children[i]
        let new_child = old_child - offset
        // Only keep children that are still valid (>= 0)
        if new_child >= 0 {
            shift_children_indices(children, offset, i + 1, push(acc, new_child))
        } else {
            shift_children_indices(children, offset, i + 1, acc)
        }
    }
}

// Add a frame to the tree as a child of the current node
fn tree_add_frame(tree, state, cont, frame_num) {
    let count = deref(tree.node_count)

    // Check if we're at capacity - prune oldest 25% of frames
    if count >= MAX_TREE_NODES {
        let prune_count = MAX_TREE_NODES / 4
        tree_prune_oldest(tree, prune_count)
    }

    // Now add the new frame (count may have changed after pruning)
    let current_count = deref(tree.node_count)
    if current_count >= MAX_TREE_NODES {
        // Still full after pruning (shouldn't happen), just return current
        deref(tree.current_idx)
    } else {
        let current = deref(tree.current_idx)
        let branch = deref(tree.current_branch)

        let parent_idx = current
        let depth = if parent_idx < 0 {
            0
        } else {
            let parent = tree_get_node(tree, parent_idx)
            if parent == null {
                // Parent should exist but doesn't - use 0 as fallback depth
                println("Warning: parent node " ++ to-string(parent_idx) ++ " is null, count=" ++ to-string(count))
                0
            } else {
                parent.depth + 1
            }
        }

        let new_node = TreeNode {
            state: state,
            cont: cont,
            frame_number: frame_num,
            parent_idx: parent_idx,
            children: [],
            depth: depth,
            branch_id: branch
        }

        // Write the new node
        let new_idx = current_count
        arr/write-field(tree.nodes, new_idx, new_node)
        reset!(tree.node_count, current_count + 1)
        reset!(tree.current_idx, new_idx)

        // Update parent's children list
        if parent_idx >= 0 {
            tree_add_child_to_node(tree, parent_idx, new_idx)
        }

        new_idx
    }
}

// Start a new branch from a given node
fn tree_start_new_branch(tree, fork_idx) {
    let new_branch_id = deref(tree.branch_counter) + 1
    reset!(tree.branch_counter, new_branch_id)
    reset!(tree.current_branch, new_branch_id)
    reset!(tree.current_idx, fork_idx)
    new_branch_id
}

// Get path from a node to root (returns array of indices, root first)
fn tree_path_to_root_helper(tree, idx, acc) {
    if idx < 0 {
        acc
    } else {
        let node = tree_get_node(tree, idx)
        if node == null {
            acc
        } else {
            tree_path_to_root_helper(tree, node.parent_idx, push(acc, idx))
        }
    }
}

fn tree_path_to_root(tree, idx) {
    reverse_array(tree_path_to_root_helper(tree, idx, []))
}

// Helper to reverse an array
fn reverse_array_helper(arr, i, acc) {
    if i < 0 {
        acc
    } else {
        reverse_array_helper(arr, i - 1, push(acc, arr[i]))
    }
}

fn reverse_array(arr) {
    reverse_array_helper(arr, length(arr) - 1, [])
}

// Find the last node on a given branch
fn tree_find_last_on_branch(tree, branch_id) {
    let count = deref(tree.node_count)
    find_last_on_branch_helper(tree, branch_id, count - 1)
}

fn find_last_on_branch_helper(tree, branch_id, idx) {
    if idx < 0 {
        -1
    } else {
        let node = tree_get_node(tree, idx)
        if node != null && node.branch_id == branch_id {
            idx
        } else {
            find_last_on_branch_helper(tree, branch_id, idx - 1)
        }
    }
}

// Get all unique branch IDs in the tree - optimized version
// Uses branch_counter to know max possible branch ID
fn tree_get_all_branches(tree) {
    let max_branch = deref(tree.branch_counter)
    // Simply return 0 to max_branch - branches are sequential
    collect_sequential_branches(0, max_branch, [])
}

fn collect_sequential_branches(i, max, acc) {
    if i > max {
        acc
    } else {
        collect_sequential_branches(i + 1, max, push(acc, i))
    }
}

fn array_contains(arr, val) {
    array_contains_helper(arr, val, 0)
}

fn array_contains_helper(arr, val, i) {
    if i >= length(arr) {
        false
    } else if arr[i] == val {
        true
    } else {
        array_contains_helper(arr, val, i + 1)
    }
}

// Navigate to the next child (first child or specified index)
fn tree_navigate_to_child(tree, idx, child_preference) {
    let children = tree_get_children(tree, idx)
    if length(children) == 0 {
        idx  // No children, stay at current
    } else if child_preference >= 0 && child_preference < length(children) {
        children[child_preference]
    } else {
        children[0]  // Default to first child
    }
}

// Find a sibling branch at the same depth
fn tree_find_sibling_at_depth(tree, current_idx, direction) {
    let node = tree_get_node(tree, current_idx)
    if node == null {
        current_idx
    } else {
        let parent_idx = node.parent_idx
        if parent_idx < 0 {
            current_idx  // Root has no siblings
        } else {
            let parent = tree_get_node(tree, parent_idx)
            let siblings = parent.children
            let current_pos = find_in_array(siblings, current_idx, 0)
            if current_pos < 0 {
                current_idx
            } else {
                let new_pos = current_pos + direction
                if new_pos < 0 || new_pos >= length(siblings) {
                    current_idx  // No more siblings in that direction
                } else {
                    siblings[new_pos]
                }
            }
        }
    }
}

fn find_in_array(arr, val, i) {
    if i >= length(arr) {
        -1
    } else if arr[i] == val {
        i
    } else {
        find_in_array(arr, val, i + 1)
    }
}

// Find nearest ancestor that is a branch point (has multiple children)
fn tree_find_nearest_branch_point(tree, idx) {
    let node = tree_get_node(tree, idx)
    if node == null {
        -1
    } else {
        find_branch_point_up(tree, node.parent_idx)
    }
}

fn find_branch_point_up(tree, idx) {
    if idx < 0 {
        -1
    } else {
        let node = tree_get_node(tree, idx)
        if node == null {
            -1
        } else if length(node.children) > 1 {
            idx  // Found a branch point
        } else {
            find_branch_point_up(tree, node.parent_idx)
        }
    }
}

// Navigate to a sibling branch - finds branch point, switches sibling, follows to same depth
fn tree_switch_branch(tree, current_idx, direction) {
    let node = tree_get_node(tree, current_idx)
    if node == null {
        current_idx
    } else {
        let target_depth = node.depth

        // Find nearest branch point
        let branch_point_idx = tree_find_nearest_branch_point(tree, current_idx)
        if branch_point_idx < 0 {
            current_idx  // No branch points above
        } else {
            // Find which child of branch point is our ancestor
            let path = tree_path_to_root(tree, current_idx)
            let branch_point_node = tree_get_node(tree, branch_point_idx)
            let siblings = branch_point_node.children

            // Find which sibling is in our path
            let our_sibling_idx = find_sibling_in_path(siblings, path, 0)
            if our_sibling_idx < 0 {
                current_idx
            } else {
                let sibling_pos = find_in_array(siblings, our_sibling_idx, 0)
                let new_pos = sibling_pos + direction
                if new_pos < 0 || new_pos >= length(siblings) {
                    current_idx  // No sibling in that direction
                } else {
                    // Switch to sibling and follow to target depth
                    let new_sibling_idx = siblings[new_pos]
                    follow_to_depth(tree, new_sibling_idx, target_depth)
                }
            }
        }
    }
}

fn find_sibling_in_path(siblings, path, i) {
    if i >= length(siblings) {
        -1
    } else {
        let sib = siblings[i]
        if array_contains(path, sib) {
            sib
        } else {
            find_sibling_in_path(siblings, path, i + 1)
        }
    }
}

// Follow first children until reaching target depth or leaf
fn follow_to_depth(tree, idx, target_depth) {
    let node = tree_get_node(tree, idx)
    if node == null {
        idx
    } else if node.depth >= target_depth {
        idx
    } else {
        let children = node.children
        if length(children) == 0 {
            idx  // Leaf node, can't go deeper
        } else {
            follow_to_depth(tree, children[0], target_depth)
        }
    }
}

// ============================================================
// Tree Visualization - Compact Full-Tree View
// ============================================================

// Tree display constants
let TREE_AREA_X = 50
let TREE_AREA_Y = SCREEN_HEIGHT - 130
let TREE_AREA_WIDTH = SCREEN_WIDTH - 70
let BRANCH_ROW_HEIGHT = 18
let MAX_VISIBLE_BRANCHES = 5
let VISIBLE_DEPTH_WINDOW = 200  // Show this many frames of depth at a time

// Branch info for rendering
struct BranchInfo {
    branch_id
    start_depth     // Depth where this branch starts
    end_depth       // Depth of last node in this branch
    fork_node_idx   // Node index where this branch forks from parent
    row             // Assigned vertical row for rendering
}

// Branch colors for visualization
fn get_branch_color(branch_id) {
    let colors = [SKYBLUE, GREEN, ORANGE, PINK, PURPLE, LIME, GOLD, MAROON]
    let idx = branch_id % 8
    colors[idx]
}

// Collect info about all branches in the tree (limited to MAX_VISIBLE_BRANCHES)
fn collect_branch_info(tree) {
    let branches = tree_get_all_branches(tree)
    let limit = if length(branches) > MAX_VISIBLE_BRANCHES { MAX_VISIBLE_BRANCHES } else { length(branches) }
    build_branch_info_list(tree, branches, 0, limit, [])
}

fn build_branch_info_list(tree, branches, i, limit, acc) {
    if i >= limit {
        acc
    } else {
        let branch_id = branches[i]
        let info = get_single_branch_info(tree, branch_id)
        build_branch_info_list(tree, branches, i + 1, limit, push(acc, info))
    }
}

fn get_single_branch_info(tree, branch_id) {
    let count = deref(tree.node_count)
    let bounds = find_branch_bounds(tree, branch_id, 0, count, -1, -1, -1, 9999999)
    BranchInfo {
        branch_id: branch_id,
        start_depth: bounds[0],
        end_depth: bounds[1],
        fork_node_idx: bounds[2],
        row: 0
    }
}

// Returns [start_depth, end_depth, fork_node_idx]
fn find_branch_bounds(tree, branch_id, i, count, fork_idx, first_idx, max_depth, min_depth) {
    if i >= count {
        [min_depth, max_depth, fork_idx]
    } else {
        let node = tree_get_node(tree, i)
        if node == null || node.branch_id != branch_id {
            find_branch_bounds(tree, branch_id, i + 1, count, fork_idx, first_idx, max_depth, min_depth)
        } else {
            let new_max = if node.depth > max_depth { node.depth } else { max_depth }
            let new_min = if node.depth < min_depth { node.depth } else { min_depth }
            let new_fork = if first_idx < 0 { node.parent_idx } else { fork_idx }
            let new_first = if first_idx < 0 { i } else { first_idx }
            find_branch_bounds(tree, branch_id, i + 1, count, new_fork, new_first, new_max, new_min)
        }
    }
}

// Assign row numbers to branches
fn assign_branch_rows(branch_infos) {
    let sorted = sort_branches_by_start(branch_infos)
    assign_rows_helper(sorted, 0, [])
}

fn assign_rows_helper(branches, row, acc) {
    if row >= length(branches) {
        acc
    } else {
        let info = branches[row]
        let updated = BranchInfo {
            branch_id: info.branch_id,
            start_depth: info.start_depth,
            end_depth: info.end_depth,
            fork_node_idx: info.fork_node_idx,
            row: row
        }
        assign_rows_helper(branches, row + 1, push(acc, updated))
    }
}

fn sort_branches_by_start(branches) {
    bubble_sort_branches(branches, 0, length(branches))
}

fn bubble_sort_branches(branches, pass, n) {
    if pass >= n - 1 {
        branches
    } else {
        let swapped = bubble_pass(branches, 0, n - pass - 1)
        bubble_sort_branches(swapped, pass + 1, n)
    }
}

fn bubble_pass(branches, i, limit) {
    if i >= limit {
        branches
    } else {
        let a = branches[i]
        let b = branches[i + 1]
        if a.start_depth > b.start_depth {
            let swapped = array_swap(branches, i, i + 1)
            bubble_pass(swapped, i + 1, limit)
        } else {
            bubble_pass(branches, i + 1, limit)
        }
    }
}

fn array_swap(arr, i, j) {
    let a = arr[i]
    let b = arr[j]
    array_set(array_set(arr, i, b), j, a)
}

fn array_set(arr, idx, val) {
    array_set_helper(arr, idx, val, 0, [])
}

fn array_set_helper(arr, idx, val, i, acc) {
    if i >= length(arr) {
        acc
    } else if i == idx {
        array_set_helper(arr, idx, val, i + 1, push(acc, val))
    } else {
        array_set_helper(arr, idx, val, i + 1, push(acc, arr[i]))
    }
}

fn find_branch_info(branch_infos, branch_id) {
    find_branch_info_helper(branch_infos, branch_id, 0)
}

fn find_branch_info_helper(branch_infos, branch_id, i) {
    if i >= length(branch_infos) {
        null
    } else {
        let info = branch_infos[i]
        if info.branch_id == branch_id {
            info
        } else {
            find_branch_info_helper(branch_infos, branch_id, i + 1)
        }
    }
}

// Get max depth - just use node count as approximation since depth ~ index for linear play
// This avoids scanning all nodes
fn get_max_depth(tree) {
    let count = deref(tree.node_count)
    if count <= 0 {
        0
    } else {
        // Check the last few nodes to find actual max
        let last_node = tree_get_node(tree, count - 1)
        if last_node != null {
            last_node.depth
        } else {
            count - 1
        }
    }
}

// Convert depth to X coordinate - maps view window to available width
fn depth_to_x_scaled(depth, view_min, view_max, x_start, width) {
    let view_range = view_max - view_min
    if view_range <= 0 {
        x_start + width / 2
    } else {
        let relative_depth = depth - view_min
        x_start + (relative_depth * width) / view_range
    }
}

// Render the tree during pause - uses pre-computed branch info
fn render_tree_paused(state, shader_ctx, frame_num, tree, pause_idx, branch_infos, max_depth) {
    begin_drawing()
    clear_background(rgb(20, 20, 30))

    // Draw the full game state
    draw_bricks(state.bricks, 0)
    draw_rectangle(state.paddle_x, PADDLE_Y, PADDLE_WIDTH, PADDLE_HEIGHT, SKYBLUE)
    draw_circle(state.ball.x, state.ball.y, BALL_RADIUS, GOLD)

    // Draw score
    let score_text = "Score: " ++ to-string(state.score)
    draw_text(score_text, 10, 10, 20, WHITE)

    // Get current node info
    let current_node = tree_get_node(tree, pause_idx)
    let total_nodes = deref(tree.node_count)
    let num_branches = length(branch_infos)

    // Calculate tree area height
    let visible_branches = if num_branches > MAX_VISIBLE_BRANCHES { MAX_VISIBLE_BRANCHES } else { num_branches }
    let tree_height = visible_branches * BRANCH_ROW_HEIGHT + 10

    // Draw tree area background
    draw_rectangle(TREE_AREA_X - 50, TREE_AREA_Y - 5, TREE_AREA_WIDTH + 60, tree_height + 45, color(0, 0, 0, 220))

    if current_node != null && max_depth > 0 {
        let current_depth = current_node.depth
        let current_branch = current_node.branch_id

        // Draw each branch as a horizontal line
        draw_tree_branches(tree, branch_infos, current_branch, current_depth, max_depth, TREE_AREA_X, TREE_AREA_Y, TREE_AREA_WIDTH, 0)

        // Frame info text
        let info_text = "Frame " ++ to-string(frame_num) ++ " | Branch " ++ to-string(current_branch) ++ " | " ++ to-string(current_depth) ++ "/" ++ to-string(max_depth) ++ " | " ++ to-string(total_nodes) ++ " nodes"
        draw_text(info_text, TREE_AREA_X - 40, TREE_AREA_Y + tree_height + 5, 14, WHITE)
    } else {
        draw_text("No history", TREE_AREA_X, TREE_AREA_Y + 15, 16, LIGHTGRAY)
    }

    // Navigation hints
    let nav_text = "[Hold </> to scrub]  [^/v switch branch]  [SPACE resume]"
    draw_text(nav_text, TREE_AREA_X + 280, TREE_AREA_Y + tree_height + 5, 12, LIGHTGRAY)

    // PAUSED indicator
    draw_text("PAUSED", SCREEN_WIDTH - 100, 10, 20, YELLOW)

    end_drawing()
}

// Bundle draw parameters into a struct to keep tail calls under 8 args
struct DrawCtx {
    tree
    branch_infos
    current_branch
    current_depth
    view_min      // Minimum depth in view window
    view_max      // Maximum depth in view window
    x
    y
    width
}

// Draw a single branch at index i
fn draw_single_branch(ctx, i) {
    let info = ctx.branch_infos[i]
    let row_y = ctx.y + i * BRANCH_ROW_HEIGHT
    let color = get_branch_color(info.branch_id)
    let is_current = info.branch_id == ctx.current_branch

    // Draw branch label
    let label = "B" ++ to-string(info.branch_id)
    draw_text(label, ctx.x - 40, row_y + 1, 12, color)

    // Calculate x positions (clamp to view window)
    let clamped_start = if info.start_depth < ctx.view_min { ctx.view_min } else { info.start_depth }
    let clamped_end = if info.end_depth > ctx.view_max { ctx.view_max } else { info.end_depth }
    let start_x = depth_to_x_scaled(clamped_start, ctx.view_min, ctx.view_max, ctx.x, ctx.width)
    let end_x = depth_to_x_scaled(clamped_end, ctx.view_min, ctx.view_max, ctx.x, ctx.width)
    let line_width = if end_x > start_x { end_x - start_x } else { 4 }

    // Draw vertical connector from fork point (for non-root branches)
    if info.fork_node_idx >= 0 && i > 0 {
        let fork_node = tree_get_node(ctx.tree, info.fork_node_idx)
        if fork_node != null && fork_node.depth >= ctx.view_min && fork_node.depth <= ctx.view_max {
            let fork_x = depth_to_x_scaled(fork_node.depth, ctx.view_min, ctx.view_max, ctx.x, ctx.width)
            let fork_info = find_branch_info(ctx.branch_infos, fork_node.branch_id)
            if fork_info != null {
                let fork_row_y = ctx.y + fork_info.row * BRANCH_ROW_HEIGHT + 7
                // Vertical connector line
                draw_rectangle(fork_x, fork_row_y, 2, row_y - fork_row_y + 7, color)
            }
        }
    }

    // Only draw if branch is visible in current view window
    if clamped_end >= clamped_start {
        // Draw branch line (thicker and brighter if current)
        let thickness = if is_current { 6 } else { 3 }
        let line_y = row_y + 5
        draw_rectangle(start_x, line_y, line_width + 2, thickness, color)
    }

    // Draw playhead on current branch
    if is_current && ctx.current_depth >= ctx.view_min && ctx.current_depth <= ctx.view_max {
        let playhead_x = depth_to_x_scaled(ctx.current_depth, ctx.view_min, ctx.view_max, ctx.x, ctx.width)
        // White playhead marker
        draw_rectangle(playhead_x - 3, row_y - 1, 7, BRANCH_ROW_HEIGHT, WHITE)
        draw_rectangle(playhead_x - 1, row_y + 2, 3, BRANCH_ROW_HEIGHT - 6, color)
    }
}

// Draw branches recursively - now only 2 params so tail call works
fn draw_branches_loop(ctx, i) {
    if i >= length(ctx.branch_infos) || i >= MAX_VISIBLE_BRANCHES {
        null
    } else {
        draw_single_branch(ctx, i)
        draw_branches_loop(ctx, i + 1)
    }
}

// Draw all branches - wrapper that creates context struct
fn draw_tree_branches(tree, branch_infos, current_branch, current_depth, max_depth, x, y, width, i) {
    // Calculate view window centered on current position
    let half_window = VISIBLE_DEPTH_WINDOW / 2
    let view_min = if current_depth > half_window { current_depth - half_window } else { 0 }
    let view_max = view_min + VISIBLE_DEPTH_WINDOW
    // Adjust if view_max exceeds max_depth
    let adjusted_max = if view_max > max_depth { max_depth } else { view_max }
    let adjusted_min = if adjusted_max - view_min < VISIBLE_DEPTH_WINDOW && adjusted_max > VISIBLE_DEPTH_WINDOW {
        adjusted_max - VISIBLE_DEPTH_WINDOW
    } else {
        view_min
    }
    let final_min = if adjusted_min < 0 { 0 } else { adjusted_min }

    let ctx = DrawCtx {
        tree: tree,
        branch_infos: branch_infos,
        current_branch: current_branch,
        current_depth: current_depth,
        view_min: final_min,
        view_max: adjusted_max,
        x: x,
        y: y,
        width: width
    }
    draw_branches_loop(ctx, 0)
}

// Pause loop - handles tree navigation
// Computes branch info once on first frame, then reuses it
fn pause_loop(ctx, first_frame) {
    // Compute branch info once when entering pause
    let tree = ctx.history_tree
    let node_count = deref(tree.node_count)

    if node_count <= 0 {
        null
    } else {
        let branch_infos = collect_branch_info(tree)
        let sorted_branches = assign_branch_rows(branch_infos)
        let max_depth = get_max_depth(tree)

        // Enter the actual pause loop with cached data
        pause_loop_inner(ctx, sorted_branches, max_depth)
    }
}

fn pause_loop_inner(ctx, branch_infos, max_depth) {
    if window_should_close() {
        null
    } else {
        let tree = ctx.history_tree
        let pause_idx = deref(ctx.pause_node_idx)
        let current_node = tree_get_node(tree, pause_idx)

        if current_node == null {
            null
        } else {
            // Handle navigation input - use is_key_down for smooth scrolling
            let new_idx = if is_key_down(KEY_LEFT) {
                let parent = current_node.parent_idx
                if parent >= 0 { parent } else { pause_idx }
            } else if is_key_down(KEY_RIGHT) {
                let children = current_node.children
                if length(children) > 0 { children[0] } else { pause_idx }
            } else if is_key_pressed(KEY_UP) {
                tree_switch_branch(tree, pause_idx, -1)
            } else if is_key_pressed(KEY_DOWN) {
                tree_switch_branch(tree, pause_idx, 1)
            } else {
                pause_idx
            }

            reset!(ctx.pause_node_idx, new_idx)
            let display_node = tree_get_node(tree, new_idx)

            if is_key_pressed(KEY_SPACE) {
                let new_branch = tree_start_new_branch(tree, new_idx)
                reset!(ctx.just_resumed, true)
                display_node.cont
            } else {
                // Render paused state with tree (using cached branch info)
                render_tree_paused(display_node.state, ctx.shader_ctx, display_node.frame_number, tree, new_idx, branch_infos, max_depth)
                pause_loop_inner(ctx, branch_infos, max_depth)
            }
        }
    }
}

// ============================================================
// Main Loop
// ============================================================

fn game_step(state, frame, ctx) {
    reset {
        // Copy into locals inside reset so continuations restore the selected frame.
        let step_state = state
        let step_frame = frame

        // Capture this frame's continuation and add to history tree
        shift(fn(k) {
            tree_add_frame(ctx.history_tree, step_state, k, step_frame)
            k(null)  // Continue execution
        })

        // Check if we just resumed - if so, skip pause check this frame
        if deref(ctx.just_resumed) {
            reset!(ctx.just_resumed, false)
            // Continue with normal game loop
            if window_should_close() {
                StepResult { done: true, score: step_state.score, state: step_state, frame: step_frame, resume_cont: null }
            } else {
                let new_state = update_game(step_state)
                render(new_state, ctx.shader_ctx, step_frame)
                StepResult { done: false, score: 0, state: new_state, frame: step_frame + 1, resume_cont: null }
            }
        } else if is_key_pressed(KEY_P) {
            println("Paused at frame " ++ to-string(step_frame))
            // Set pause index to current node (most recent)
            reset!(ctx.pause_node_idx, deref(ctx.history_tree.current_idx))
            // Enter pause loop (first_frame=true to skip immediate resume check)
            let resume_cont = pause_loop(ctx, true)
            StepResult { done: false, score: 0, state: step_state, frame: step_frame, resume_cont: resume_cont }
        } else {
            // Normal game loop
            if window_should_close() {
                StepResult { done: true, score: step_state.score, state: step_state, frame: step_frame, resume_cont: null }
            } else {
                let new_state = update_game(step_state)
                render(new_state, ctx.shader_ctx, step_frame)
                StepResult { done: false, score: 0, state: new_state, frame: step_frame + 1, resume_cont: null }
            }
        }
    }
}

fn game_loop(state, frame, ctx) {
    let result = game_step(state, frame, ctx)
    if result.resume_cont != null {
        let k = result.resume_cont
        let resumed = k(null)
        if resumed.done {
            resumed.score
        } else {
            game_loop(resumed.state, resumed.frame, ctx)
        }
    } else if result.done {
        result.score
    } else {
        game_loop(result.state, result.frame, ctx)
    }
}

// Shader context holds shader and uniform locations
struct ShaderCtx {
    shader
    frame_loc
    frame_buffer
}

fn main() {
    println("Initializing Breakout...")
    init_window(SCREEN_WIDTH, SCREEN_HEIGHT, "Breakout - Beagle + Raylib")
    set_target_fps(60)

    println("Loading shader...")
    // Load the glow shader (null for vertex shader = use default)
    let shader = load_shader_from_memory(null, GLOW_FRAGMENT_SHADER)
    let frame_loc = get_shader_location(shader, "frame")
    // Allocate a 4-byte buffer for the int frame value
    let frame_buffer = ffi/allocate(4)
    println("Shader loaded! Frame uniform location: " ++ to-string(frame_loc))

    let shader_ctx = ShaderCtx {
        shader: shader,
        frame_loc: frame_loc,
        frame_buffer: frame_buffer
    }

    // Create history tree for time-travel system
    let history_tree = create_history_tree()
    let pause_node_idx = atom(-1)   // Current position when paused
    let just_resumed = atom(false)  // Flag to skip pause check after resume

    println("Starting game...")
    println("Controls:")
    println("  LEFT/RIGHT arrows - Move paddle")
    println("  SPACE - Launch ball")
    println("  P - Pause and enter time-travel mode")
    println("    In pause mode:")
    println("      LEFT/RIGHT - Navigate along current branch")
    println("      UP/DOWN - Switch between branches")
    println("      SPACE - Resume from current point (creates new branch)")
    println("  ESC - Quit")
    println("")
    println("Tip: Move paddle while hitting the ball to add 'english'!")

    let initial_state = create_initial_state()
    let ctx = LoopCtx {
        shader_ctx: shader_ctx,
        history_tree: history_tree,
        pause_node_idx: pause_node_idx,
        just_resumed: just_resumed
    }

    let final_score = game_loop(initial_state, 0, ctx)

    println("Game over! Final score: " ++ to-string(final_score))
    ffi/deallocate(frame_buffer)
    unload_shader(shader)
    close_window()
    final_score
}
