namespace hash_table_uppercase_test

use beagle.builtin as builtin
use beagle.mutable-array as arr
let HT_KEYS = 0
let HT_COUNTS = 1
let HT_SIZE = 2
let HT_CAPACITY = 3

fn new_hash_table(capacity) {
    let ht = arr/new-array(4)
    arr/write-field(ht, HT_KEYS, arr/new-array(capacity))
    arr/write-field(ht, HT_COUNTS, arr/new-array(capacity))
    arr/write-field(ht, HT_SIZE, 0)
    arr/write-field(ht, HT_CAPACITY, capacity)
    ht
}

fn hash_string(s, capacity) {
    let h = builtin/hash(s)
    let h2 = if h < 0 { 0 - h } else { h }
    h2 - (h2 / capacity) * capacity
}

fn ht_increment(ht, key) {
    let keys = arr/read-field(ht, HT_KEYS)
    let counts = arr/read-field(ht, HT_COUNTS)
    let capacity = arr/read-field(ht, HT_CAPACITY)
    let idx = hash_string(key, capacity)
    ht_probe_and_increment(ht, keys, counts, capacity, key, idx, 0)
}

fn ht_probe_and_increment(ht, keys, counts, capacity, key, idx, probes) {
    if probes >= capacity {
        null
    } else {
        let existing_key = arr/read-field(keys, idx)
        if existing_key == null {
            arr/write-field(keys, idx, key)
            arr/write-field(counts, idx, 1)
            let size = arr/read-field(ht, HT_SIZE)
            arr/write-field(ht, HT_SIZE, size + 1)
            null
        } else {
            if existing_key == key {
                let count = arr/read-field(counts, idx)
                arr/write-field(counts, idx, count + 1)
                null
            } else {
                let next_idx = idx + 1
                let wrapped_idx = if next_idx >= capacity { 0 } else { next_idx }
                ht_probe_and_increment(ht, keys, counts, capacity, key, wrapped_idx, probes + 1)
            }
        }
    }
}

fn main() {
    // Simulate what knucleotide does: uppercase then substring
    let line1 = "acgt"
    let line2 = "acgt"
    let upper1 = uppercase(line1)
    let upper2 = uppercase(line2)

    // Concatenate like knucleotide does
    let seq = upper1 ++ upper2

    println("Sequence:")
    println(seq)

    let ht = new_hash_table(16)

    // Insert all 1-mers
    let mut i = 0
    while i < 8 {
        let kmer = substring(seq, i, 1)
        ht_increment(ht, kmer)
        i = i + 1
    }

    let size = arr/read-field(ht, HT_SIZE)
    println("Hash table size (should be 4):")
    println(size)

    ""
}

// @beagle.core.snapshot
// Sequence:
// ACGTACGT
// Hash table size (should be 4):
// 4
