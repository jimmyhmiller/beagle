namespace test_warnings_eval_accumulate

enum Color {
    Red,
    Green,
}

fn main() {
    let c = Color.Red
    match c {
        Color.Red => "red",
        // Missing Green - generates 1 diagnostic
    }

    println("Diagnostics after initial compilation:")
    let diags1 = diagnostics()
    println(length(diags1))

    // Now eval some code that also has a diagnostic
    eval("
        enum Shape {
            Circle,
            Square,
        }

        fn test() {
            let s = Shape.Circle
            match s {
                Shape.Circle => \"circle\",
            }
        }
        test()
    ")

    // With the new per-file diagnostic system:
    // - Main file's diagnostic is still stored
    // - eval() stores its diagnostic under "repl" file
    // - diagnostics() returns all diagnostics across all files
    println("Diagnostics after eval:")
    let diags2 = diagnostics()
    println(length(diags2))

    // We should have 2 diagnostics (1 from main file, 1 from eval)
    let count = length(diags2)
    if count == 2 {
        println("PASS: Got 2 diagnostics as expected (per-file storage)")
    } else {
        println("FAIL: Expected 2 diagnostics, got:")
        println(count)
    }

    "done"
}

// Expect
// Diagnostics after initial compilation:
// 1
// Diagnostics after eval:
// 2
// PASS: Got 2 diagnostics as expected (per-file storage)
