namespace match_compiler_warning_struct_id_test

import "beagle.primitive" as primitive
import "beagle.core" as core
import "generate_warning_for_test" as warn_gen

struct TestStruct { count, data }

fn main() {
    // Create a normal struct
    let normal = TestStruct { count: 5, data: "test" }

    // Trigger generation of a compiler warning by compiling code with non-exhaustive match
    eval("generate_warning_for_test/main()")

    // Get warnings vector (should have at least one warning now)
    let warnings_vec = core/compiler-warnings()

    // Check if vector is empty (no warnings expected)
    println("Warnings vector length:")
    println(core/length(warnings_vec))

    // Normal struct checks
    println("Normal struct_id:")
    let normal_id = primitive/read_struct_id(normal)
    println(normal_id)

    println("Normal struct expected id:")
    println(match_compiler_warning_struct_id_test/TestStruct.id)

    println("Normal struct ID matches:")
    println(normal_id == match_compiler_warning_struct_id_test/TestStruct.id)

    // If there are any warnings, check the first one's struct ID
    // This would fail if the struct ID is corrupted (double-tagged)
    if core/length(warnings_vec) > 0 {
        println("About to get first warning...")
        let first_warning = core/get(warnings_vec, 0)
        println(warnings_vec)
    }

    "done"
}

// Expect
// Warnings vector length:
// 1
// Normal struct_id:
// 27
// Normal struct expected id:
// 27
// Normal struct ID matches:
// true
// About to get first warning...
// [CompilerWarning { kind: "NonExhaustiveMatch", file_name: "resources/generate_warning_for_test.bg", line: 12, column: 10, message: "Non-exhaustive match on enum 'MyEnum'. Missing variants: Variant3", enum_name: "MyEnum", missing_variants: PersistentVector { count: 1, shift: 5, root: [  ], tail: [ "Variant3" ] } }]
// done
