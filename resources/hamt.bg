namespace hamt
import "raw_mutable_array" as array
import "beagle.primitive" as primitive


struct PersistentVector {
    count
    shift
    root
    tail
}

// TODO:
// This was all failing because of this namespace
// constant here. My GC was not working correctly with it
// This was true for both generational and compacting
// Based on the stuff I did with extra roots
// I need to make namespace roots more sensible
let EMPTY = PersistentVector {
    count: 0
    shift: 5
    root: array/new_array(0)
    tail: array/new_array(0)
}

fn tailOffset(vec) {
    if vec.count < 32 {
        0
    } else {
        ((vec.count - 1) >>> 5) << 5
    }
}

fn get_node_for_level(node, level, index) {
    // So I'm guessing my parsing code is parsing
    // this incorrectly if I don't assign a variable...
    if level == 0 {
        node
    } else {
        let new_node = array/read_field(node, (index >>> level) & 31)
        get_node_for_level(new_node, level - 5, index)
    }
}

fn get(vec, index) {
    if index < 0 || index >= vec.count {
        primitive/panic("Index out of bounds")
    }

    if index >= tailOffset(vec) {
        array/read_field(vec.tail, index & 31)
    } else {
        let node = get_node_for_level(vec.root, vec.shift, index)
        array/read_field(node, index & 31)
    }
}

fn push(vec, value) {
    let tail_length = array/count(vec.tail)
    if tail_length < 32 {
        // Tail has space, create a new tail array with one extra slot
        let new_tail_size = tail_length + 1
        let new_tail = array/new_array(new_tail_size)
        // Copy existing tail into new tail
        array/copy_from_array_to(vec.tail, new_tail)
        // Add the new value
        array/write_field(new_tail, tail_length, value)
        // Return a new PersistentVector with the updated tail
        PersistentVector {
            count: vec.count + 1
            shift: vec.shift
            root: vec.root
            tail: new_tail
        }
    } else {
        // Tail is full, need to push into the tree
        let tail_node = vec.tail
        // Start a new tail with the new value
        let new_tail = array/new_array(1)
        array/write_field(new_tail, 0, value)
        let cnt_shifted = vec.count >>> 5
        let shifted_one = 1 << vec.shift

        if cnt_shifted > shifted_one {

            // Need to create a new root and increase shift
            let new_root_array = array/new_array(32)
            array/write_field(new_root_array, 0, vec.root)
            let new_path_node = new_path(vec, vec.shift, tail_node)
            array/write_field(new_root_array, 1, new_path_node)
            let new_root = new_root_array
            // Return a new PersistentVector with the increased shift and new root
            PersistentVector {
                count: vec.count + 1
                shift: vec.shift + 5
                root: new_root
                tail: new_tail
            }
        } else {
            // Insert into existing tree
            
            let new_root = push_tail(vec, vec.shift, vec.root, tail_node)
            // Return a new PersistentVector with the same shift and the new root
            PersistentVector {
                count: vec.count + 1
                shift: vec.shift
                root: new_root
                tail: new_tail
            }
        }
    }
}

fn new_path(vec, level, node) {
    if level == 0 {
        node
    } else {
        let path = array/new_array(32)
        array/write_field(path, 0, new_path(vec, level - 5, node))
        path
    }
}


fn print_array_summary_single_level(array, index) {
    let count = array/count(array)
    print("Array(")
    print(count)
    print(")")
}


fn print_array_summary(array, index) {

    if array/is_array(array) == false {
        print(" ")
        print(array)
        println(" ")
    } else {
        let count = array/count(array)
        if index == count {
            println("")
        } else {
            let elem = array/read_field(array, index)
            if array/is_array(elem) {
                print_array_summary_single_level(elem, 0)
                print(" ")
                print_array_summary(array, index + 1)
            } else {
                print(" ")
                print(elem)
                print(" ")
                print_array_summary(array, index + 1)
            }
        }
    }
}

fn push_tail(vec, level, parent, tail_node) {
    let new_array = array/new_array(32)
    if array/is_array(parent) == false {
        primitive/panic("Parent is not an array")
    }
    let new_parent = array/copy_from_array_to(parent, new_array)
    let sub_index = ((vec.count - 1) >>> level) & 31

    let updated_node = if level == 5 {
        // Level is 5, insert the tail node here
        array/write_field(new_parent, sub_index, tail_node)
        new_parent
    } else {
        let child = array/read_field(parent, sub_index)
        let new_child = if child != null {
            push_tail(vec, level - 5, child, tail_node)
        } else {
            new_path(vec, level - 5, tail_node)
        }
        array/write_field(new_parent, sub_index, new_child)
        new_parent
    }
    updated_node
}

fn assoc(vec, index, value) {
    if index < 0 || index >= vec.count {
        primitive/panic("Index out of bounds")
    }

    if index >= tailOffset(vec) {
        // Update the tail
        let new_tail = array/copy_array(vec.tail)
        array/write_field(new_tail, index & 31, value)
        PersistentVector {
            count: vec.count
            shift: vec.shift
            root: vec.root
            tail: new_tail
        }
    } else {
        // Update the tree
        let new_root = doAssoc(vec, vec.shift, vec.root, index, value)
        PersistentVector {
            count: vec.count
            shift: vec.shift
            root: new_root
            tail: vec.tail
        }
    }
}

fn doAssoc(vec, level, node, index, value) {
    let new_node = array/copy_array(node)
    if level == 0 {
        array/write_field(new_node, index & 31, value)
        new_node
    } else {
        let sub_index = (index >>> level) & 31
        let child = array/read_field(node, sub_index)
        let new_child = doAssoc(vec, level - 5, child, index, value)
        array/write_field(new_node, sub_index, new_child)
        new_node
    }
}


fn fill_vec_n(vec, i, n) {
    // println(n)
    if i == n {
        vec
    } else {
        // println(vec)
        let new_vec = push(vec, i)
        fill_vec_n(new_vec, i + 1, n)
    }
}

fn get_and_verify(vec, index) {
    let value = get(vec, index)
    if value != index {
        println("Error: Expected ")
        println(index)
        println(" but got ")
        println(value)
        primitive/panic("Value mismatch")
    }
    if index != vec.count - 1 {
        get_and_verify(vec, index + 1)
    } else {
        "done"
    }
}

fn make_vec_of_every_size_and_verify(n) {
    if n == 0 {
        "done"
    } else {
        println(n)
        let vec = fill_vec_n(PersistentVector {
            count: 0
            shift: 5
            root: array/new_array(0)
            tail: array/new_array(0)
        }, 0, n)
        get_and_verify(vec, 0)
        make_vec_of_every_size_and_verify(n - 1)
    }
}


fn main() {

    // TODO: Okay I think I've tracked this down to a gc/allocation bug
    // This code seems to work fule with mark and sweep
    // but fails with compacting and generational
    // So it could be the moving
    // it could be the size thing
    // it could be something else,
    // but I think the actual code *might* be working properly

    // let vec = EMPTY
    // let vec2 = push(vec, 1)
    // let vec3 = push(vec2, 2)
    // let vec4 = push(vec3, 3)
    // let vec5 = assoc(vec4, 1, 4)
    // println(get(vec5, 0))
    // println(get(vec5, 1))
    // println(get(vec5, 2))

    // As soon as I do 10 million, it crashes
    // not 100% sure why yet

    // Okay, from what I can tell, I am one level too shallow
    // let vec6 = fill_vec_n(EMPTY, 0, 10000000)
    // get_and_verify(vec6, 0)

    make_vec_of_every_size_and_verify(10000)
    
    // println(array/read_field(vec6.root, 0))
    // get_and_verify(vec6, 0)
    
    // println(vec6)
    // println("here!!!")
    // println(vec6)
    // TODO: get has a problem
    // println(get(vec6, 0))
    // let vec6 = assoc(vec6, 1, 99)
    // println(get(vec6, 1))
    // println(get(vec6, 2))
    // println(get(vec6, 99))
    "done"
}
