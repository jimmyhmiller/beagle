namespace large_concat_test

use beagle.builtin as builtin
use raw-mutable-array as arr
fn build_string(n, acc) {
    if n <= 0 {
        acc
    } else {
        build_string(n - 1, acc ++ "ACGT")
    }
}

let HT_KEYS = 0
let HT_COUNTS = 1
let HT_SIZE = 2
let HT_CAPACITY = 3

fn new_hash_table(capacity) {
    let ht = arr/new-array(4)
    arr/write-field(ht, HT_KEYS, arr/new-array(capacity))
    arr/write-field(ht, HT_COUNTS, arr/new-array(capacity))
    arr/write-field(ht, HT_SIZE, 0)
    arr/write-field(ht, HT_CAPACITY, capacity)
    ht
}

fn hash_string(s, capacity) {
    let h = builtin/hash(s)
    let h2 = if h < 0 { 0 - h } else { h }
    h2 - (h2 / capacity) * capacity
}

fn ht_increment(ht, key) {
    let keys = arr/read-field(ht, HT_KEYS)
    let counts = arr/read-field(ht, HT_COUNTS)
    let capacity = arr/read-field(ht, HT_CAPACITY)
    let idx = hash_string(key, capacity)
    ht_probe_and_increment(ht, keys, counts, capacity, key, idx, 0)
}

fn ht_probe_and_increment(ht, keys, counts, capacity, key, idx, probes) {
    if probes >= capacity {
        null
    } else {
        let existing_key = arr/read-field(keys, idx)
        if existing_key == null {
            arr/write-field(keys, idx, key)
            arr/write-field(counts, idx, 1)
            let size = arr/read-field(ht, HT_SIZE)
            arr/write-field(ht, HT_SIZE, size + 1)
            null
        } else {
            if existing_key == key {
                let count = arr/read-field(counts, idx)
                arr/write-field(counts, idx, count + 1)
                null
            } else {
                let next_idx = idx + 1
                let wrapped_idx = if next_idx >= capacity { 0 } else { next_idx }
                ht_probe_and_increment(ht, keys, counts, capacity, key, wrapped_idx, probes + 1)
            }
        }
    }
}

fn count_kmers_loop(seq, len, ht, i) {
    if i >= len {
        null
    } else {
        let kmer = substring(seq, i, 1)
        ht_increment(ht, kmer)
        count_kmers_loop(seq, len, ht, i + 1)
    }
}

fn main() {
    // Build a string of 1000 * 4 = 4000 characters
    let seq = build_string(1000, "")
    let len = length(seq)

    println("Length:")
    println(len)

    println("First 20 chars:")
    println(substring(seq, 0, 20))

    // Count 1-mers
    let ht = new_hash_table(64)
    count_kmers_loop(seq, len, ht, 0)

    let size = arr/read-field(ht, HT_SIZE)
    println("Hash table size (should be 4):")
    println(size)

    ""
}

// Expect
// Length:
// 4000
// First 20 chars:
// ACGTACGTACGTACGTACGT
// Hash table size (should be 4):
// 4
