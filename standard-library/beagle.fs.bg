namespace beagle.fs

use beagle.core as core
use beagle.effect as effect

// ============================================================================
// Filesystem Effect
// ============================================================================
// The Fs effect provides all file and directory operations.
// Handlers determine how operations execute (blocking, async, etc.)
// but the return type is always the same: Result<T> for most operations.
//
// Usage:
//   use beagle.fs as fs
//
//   // With a handler installed:
//   handle effect/Handler(fs/Fs) with some_handler {
//       let result = fs/read-file("/tmp/test.txt")
//       match result {
//           Result.Ok { value } => println("Content:", value),
//           Result.Err { error } => println("Error:", error)
//       }
//   }
//
// For blocking synchronous I/O (no handler required):
//   let result = fs/blocking-read-file("/tmp/test.txt")

// ============================================================================
// Fs Effect Enum
// ============================================================================
// Each variant represents a filesystem operation.

enum Fs {
    // File operations
    ReadFile { path },
    WriteFile { path, content },
    AppendFile { path, content },
    DeleteFile { path },
    FileExists { path },
    FileSize { path },
    IsFile { path },
    RenameFile { old_path, new_path },
    CopyFile { src_path, dest_path },

    // Directory operations
    ReadDir { path },
    CreateDir { path },
    CreateDirAll { path },
    RemoveDir { path },
    RemoveDirAll { path },
    IsDirectory { path },

    // Low-level file handle operations
    Open { path, mode },
    Close { file },
    Read { file, n },
    Write { file, content },
    ReadLine { file },
    Flush { file }
}

// ============================================================================
// High-Level File Operations
// ============================================================================
// These functions perform Fs effects. They must be called within a
// `handle effect/Handler(Fs) with handler { ... }` block.

/// Read the entire contents of a file as a string.
///
/// Must be called within an Fs effect handler block.
/// Returns Result.Ok with content or Result.Err on failure.
///
/// Examples:
///   handle effect/Handler(Fs) with handler {
///       match (fs/read-file "/tmp/test.txt") {
///           Result.Ok { value } => println(value),
///           Result.Err { error } => println("Error:", error)
///       }
///   }
fn read-file(path) {
    perform Fs.ReadFile { path: path }
}

/// Write content to a file (creates or overwrites).
///
/// Returns Result.Ok with bytes written, or Result.Err on failure.
///
/// Examples:
///   (fs/write-file "/tmp/test.txt" "Hello, World!")
fn write-file(path, content) {
    perform Fs.WriteFile { path: path, content: content }
}

/// Append content to a file (creates if doesn't exist).
///
/// Returns Result.Ok with bytes written, or Result.Err on failure.
///
/// Examples:
///   (fs/append-file "/tmp/log.txt" "New log entry\n")
fn append-file(path, content) {
    perform Fs.AppendFile { path: path, content: content }
}

/// Delete a file.
///
/// Returns Result.Ok on success, or Result.Err if file doesn't exist.
///
/// Examples:
///   (fs/delete-file "/tmp/test.txt")
fn delete-file(path) {
    perform Fs.DeleteFile { path: path }
}

/// Check if a file or directory exists.
///
/// Returns Result.Ok { value: true/false }.
///
/// Examples:
///   (fs/exists? "/tmp/test.txt")  ; => Result.Ok { value: true }
fn exists?(path) {
    perform Fs.FileExists { path: path }
}

/// Get file size in bytes.
///
/// Returns Result.Ok with the size, or Result.Err if file doesn't exist.
///
/// Examples:
///   (fs/file-size "/tmp/test.txt")  ; => Result.Ok { value: 1024 }
fn file-size(path) {
    perform Fs.FileSize { path: path }
}

/// Check if path is a regular file (not a directory).
///
/// Returns Result.Ok { value: true/false }.
///
/// Examples:
///   (fs/is-file? "/tmp/test.txt")  ; => Result.Ok { value: true }
fn is-file?(path) {
    perform Fs.IsFile { path: path }
}

/// Rename or move a file or directory.
///
/// Returns Result.Ok on success, or Result.Err on failure.
///
/// Examples:
///   (fs/rename "/tmp/old.txt" "/tmp/new.txt")
fn rename(old-path, new-path) {
    perform Fs.RenameFile { old_path: old-path, new_path: new-path }
}

/// Copy a file from source to destination.
///
/// Returns Result.Ok on success, or Result.Err on failure.
///
/// Examples:
///   (fs/copy "/tmp/source.txt" "/tmp/dest.txt")
fn copy(src-path, dest-path) {
    perform Fs.CopyFile { src_path: src-path, dest_path: dest-path }
}

// ============================================================================
// Directory Operations
// ============================================================================

/// List directory contents.
///
/// Returns Result.Ok with vector of entry names, or Result.Err on failure.
///
/// Examples:
///   (fs/read-dir "/tmp")  ; => Result.Ok { value: ["file1.txt", "file2.txt"] }
fn read-dir(path) {
    perform Fs.ReadDir { path: path }
}

/// Create a directory.
///
/// Parent directories must exist. Use create-dir-all for recursive creation.
///
/// Examples:
///   (fs/create-dir "/tmp/mydir")
fn create-dir(path) {
    perform Fs.CreateDir { path: path }
}

/// Create a directory and all parent directories.
///
/// Like mkdir -p. Creates any missing parent directories.
///
/// Examples:
///   (fs/create-dir-all "/tmp/a/b/c")
fn create-dir-all(path) {
    perform Fs.CreateDirAll { path: path }
}

/// Remove an empty directory.
///
/// Fails if directory is not empty. Use remove-dir-all for recursive removal.
///
/// Examples:
///   (fs/remove-dir "/tmp/empty-dir")
fn remove-dir(path) {
    perform Fs.RemoveDir { path: path }
}

/// Remove a directory and all its contents recursively.
///
/// Like rm -rf. Removes files and subdirectories.
///
/// Examples:
///   (fs/remove-dir-all "/tmp/mydir")
fn remove-dir-all(path) {
    perform Fs.RemoveDirAll { path: path }
}

/// Check if path is a directory.
///
/// Returns Result.Ok { value: true/false }.
///
/// Examples:
///   (fs/is-directory? "/tmp")  ; => Result.Ok { value: true }
fn is-directory?(path) {
    perform Fs.IsDirectory { path: path }
}

// ============================================================================
// Low-Level File Handle Operations
// ============================================================================

/// Open a file with a mode string.
///
/// Modes: "r" (read), "w" (write/create), "a" (append), "r+" (read/write).
/// Returns a File handle for low-level operations.
///
/// Examples:
///   (let file (unwrap (fs/open "/tmp/test.txt" "r")))
fn open(path, mode) {
    perform Fs.Open { path: path, mode: mode }
}

/// Close a file handle.
///
/// Always close files when done to release resources.
///
/// Examples:
///   (fs/close file)
fn close(file) {
    perform Fs.Close { file: file }
}

/// Read up to n bytes from a file handle.
///
/// Returns the data read as a string.
///
/// Examples:
///   (fs/read file 1024)
fn read(file, n) {
    perform Fs.Read { file: file, n: n }
}

/// Write content to a file handle.
///
/// Returns the number of bytes written.
///
/// Examples:
///   (fs/write file "Hello, World!")
fn write(file, content) {
    perform Fs.Write { file: file, content: content }
}

/// Read a line from a file handle.
///
/// Reads until newline or end of file.
///
/// Examples:
///   (fs/read-line file)  ; => "First line\n"
fn read-line(file) {
    perform Fs.ReadLine { file: file }
}

/// Flush a file's buffers to disk.
///
/// Ensures all buffered writes are actually written.
///
/// Examples:
///   (fs/flush file)
fn flush(file) {
    perform Fs.Flush { file: file }
}

// ============================================================================
// Blocking Synchronous Operations
// ============================================================================
// These functions perform I/O synchronously without requiring a handler.
// They install their own BlockingFsHandler internally.

// Import the blocking handler implementations
use beagle.io as io
use beagle.ffi as ffi
use beagle.builtin as builtin

// ============================================================================
// BlockingFsHandler - Synchronous filesystem handler
// ============================================================================

struct BlockingFsHandler {}

extend BlockingFsHandler with effect/Handler(Fs) {
    fn handle(self, op, resume) {
        let result = match op {
            Fs.ReadFile { path } => {
                handle-read-file(path)
            },
            Fs.WriteFile { path, content } => {
                handle-write-file(path, content)
            },
            Fs.AppendFile { path, content } => {
                handle-append-file(path, content)
            },
            Fs.DeleteFile { path } => {
                handle-delete-file(path)
            },
            Fs.FileExists { path } => {
                handle-file-exists(path)
            },
            Fs.FileSize { path } => {
                handle-file-size(path)
            },
            Fs.IsFile { path } => {
                handle-is-file(path)
            },
            Fs.RenameFile { old_path, new_path } => {
                handle-rename-file(old_path, new_path)
            },
            Fs.CopyFile { src_path, dest_path } => {
                handle-copy-file(src_path, dest_path)
            },
            Fs.ReadDir { path } => {
                handle-read-dir(path)
            },
            Fs.CreateDir { path } => {
                handle-create-dir(path)
            },
            Fs.CreateDirAll { path } => {
                handle-create-dir-all(path)
            },
            Fs.RemoveDir { path } => {
                handle-remove-dir(path)
            },
            Fs.RemoveDirAll { path } => {
                handle-remove-dir-all(path)
            },
            Fs.IsDirectory { path } => {
                handle-is-directory(path)
            },
            Fs.Open { path, mode } => {
                handle-open(path, mode)
            },
            Fs.Close { file } => {
                handle-close(file)
            },
            Fs.Read { file, n } => {
                handle-read(file, n)
            },
            Fs.Write { file, content } => {
                handle-write(file, content)
            },
            Fs.ReadLine { file } => {
                handle-read-line(file)
            },
            Fs.Flush { file } => {
                handle-flush(file)
            }
        }
        resume(result)
    }
}

// ============================================================================
// Handler Implementation Functions
// ============================================================================

fn handle-read-file(path) {
    try {
        let content = read-full-file(path)
        ok(content)
    } catch (e) {
        err(Error.NotFound { path: path })
    }
}

fn handle-write-file(path, content) {
    let file-result = io/open(path, "w")
    match file-result {
        Result.Ok { value } => {
            let file = value
            let write-result = io/write-string(file, content)
            io/close(file)
            match write-result {
                Result.Ok { value } => ok(value),
                Result.Err { error } => err(error)
            }
        },
        Result.Err { error } => {
            err(error)
        }
    }
}

fn handle-append-file(path, content) {
    let file-result = io/open(path, "a")
    match file-result {
        Result.Ok { value } => {
            let file = value
            let write-result = io/write-string(file, content)
            io/close(file)
            match write-result {
                Result.Ok { value } => ok(value),
                Result.Err { error } => err(error)
            }
        },
        Result.Err { error } => {
            err(error)
        }
    }
}

fn handle-delete-file(path) {
    let result = core/fs-unlink(path)
    if result == 0 {
        ok(null)
    } else {
        err(Error.NotFound { path: path })
    }
}

fn handle-file-exists(path) {
    let result = core/fs-access(path, 0) // F_OK = 0
    ok(result == 0)
}

fn handle-file-size(path) {
    let size = core/fs-file-size(path)
    if size < 0 {
        err(Error.NotFound { path: path })
    } else {
        ok(size)
    }
}

fn handle-is-file(path) {
    let result = core/fs-is-file?(path)
    ok(result)
}

fn handle-is-directory(path) {
    let result = core/fs-is-directory?(path)
    ok(result)
}

fn handle-rename-file(old-path, new-path) {
    let result = core/fs-rename(old-path, new-path)
    if result == 0 {
        ok(null)
    } else {
        err(Error.IO { message: "Failed to rename " ++ old-path ++ " to " ++ new-path })
    }
}

fn handle-copy-file(src-path, dest-path) {
    let read-result = handle-read-file(src-path)
    match read-result {
        Result.Ok { value } => {
            handle-write-file(dest-path, value)
        },
        Result.Err { error } => {
            err(error)
        }
    }
}

fn handle-read-dir(path) {
    let entries = core/fs-readdir(path)
    if entries == null {
        err(Error.NotFound { path: path })
    } else {
        ok(entries)
    }
}

fn handle-create-dir(path) {
    let result = core/fs-mkdir(path, 493) // 0755 in octal
    if result == 0 {
        ok(null)
    } else if result == -17 {
        err(Error.AlreadyExists { path: path })
    } else {
        err(Error.IO { message: "Failed to create directory" })
    }
}

fn handle-create-dir-all(path) {
    if path == "" || path == "/" {
        ok(null)
    } else {
        let components = core/split(path, "/")
        let mut current-path = ""
        let mut i = 0
        let len = length(components)
        let mut found-error = null

        while i < len && found-error == null {
            let component = get(components, i)
            if component != "" {
                if current-path == "" && core/starts-with?(path, "/") {
                    current-path = "/" ++ component
                } else if current-path == "" {
                    current-path = component
                } else {
                    current-path = current-path ++ "/" ++ component
                }

                let result = core/fs-mkdir(current-path, 493) // 0755 in octal
                // 0 = success, -17 = EEXIST (already exists, that's ok)
                if result != 0 && result != -17 {
                    found-error = err(Error.IO { message: "Failed to create directory: " ++ current-path })
                }
            }
            i = i + 1
        }

        if found-error == null {
            ok(null)
        } else {
            found-error
        }
    }
}

fn handle-remove-dir(path) {
    let result = core/fs-rmdir(path)
    if result == 0 {
        ok(null)
    } else {
        err(Error.IO { message: "Failed to remove directory" })
    }
}

fn handle-remove-dir-all(path) {
    let entries = core/fs-readdir(path)
    if entries == null {
        // Not a directory or doesn't exist - try to unlink as file
        let result = core/fs-unlink(path)
        if result == 0 {
            ok(null)
        } else {
            err(Error.IO { message: "Failed to remove: " ++ path })
        }
    } else {
        // It's a directory - remove all entries first
        let mut i = 0
        let len = length(entries)
        let mut found-error = null

        while i < len && found-error == null {
            let entry = get(entries, i)
            // Skip . and ..
            if entry != "." && entry != ".." {
                let entry-path = path ++ "/" ++ entry

                // Try to unlink as file first
                let unlink-result = core/fs-unlink(entry-path)
                if unlink-result != 0 {
                    // unlink failed - might be a directory, try recursive remove
                    let recursive-result = handle-remove-dir-all(entry-path)
                    match recursive-result {
                        Result.Ok { value } => {},
                        _ => {
                            found-error = recursive-result
                        }
                    }
                }
            }
            i = i + 1
        }

        if found-error != null {
            found-error
        } else {
            // Now remove the empty directory
            let result = core/fs-rmdir(path)
            if result == 0 {
                ok(null)
            } else {
                err(Error.IO { message: "Failed to remove directory: " ++ path })
            }
        }
    }
}

fn handle-open(path, mode) {
    let result = io/open(path, mode)
    match result {
        Result.Ok { value } => ok(value),
        Result.Err { error } => err(error)
    }
}

fn handle-close(file) {
    let result = io/close(file)
    match result {
        Result.Ok { value } => ok(null),
        Result.Err { error } => err(error)
    }
}

fn handle-read(file, n) {
    let result = io/read-bytes(file, n)
    match result {
        Result.Ok { value } => {
            let s = ffi/get-string(value.buffer, 0, value.length)
            ffi/deallocate(value.buffer)
            ok(s)
        },
        Result.Err { error } => err(error)
    }
}

fn handle-write(file, content) {
    let result = io/write-string(file, content)
    match result {
        Result.Ok { value } => ok(value),
        Result.Err { error } => err(error)
    }
}

fn handle-read-line(file) {
    let result = io/read-line(file, 4096)
    match result {
        Result.Ok { value } => ok(value),
        Result.Err { error } => err(error)
    }
}

fn handle-flush(file) {
    let result = io/flush(file)
    match result {
        Result.Ok { value } => ok(null),
        Result.Err { error } => err(error)
    }
}

// ============================================================================
// Blocking Convenience Functions
// ============================================================================
// These wrap each operation in its own handler block for easy use.

fn run-blocking(thunk) {
    let handler = BlockingFsHandler {}
    handle effect/Handler(Fs) with handler {
        thunk()
    }
}

/// Read the entire contents of a file synchronously.
///
/// This is the simplest way to read a file. No handler required.
///
/// Examples:
///   match (fs/blocking-read-file "/tmp/test.txt") {
///       Result.Ok { value } => println(value),
///       Result.Err { error } => println("Error:", error)
///   }
fn blocking-read-file(path) {
    run-blocking(fn() { read-file(path) })
}

/// Write content to a file synchronously (creates or overwrites).
///
/// This is the simplest way to write a file. No handler required.
///
/// Examples:
///   (fs/blocking-write-file "/tmp/test.txt" "Hello, World!")
fn blocking-write-file(path, content) {
    run-blocking(fn() { write-file(path, content) })
}

fn blocking-append-file(path, content) {
    run-blocking(fn() { append-file(path, content) })
}

/// Delete a file synchronously.
///
/// Examples:
///   (fs/blocking-delete-file "/tmp/test.txt")
fn blocking-delete-file(path) {
    run-blocking(fn() { delete-file(path) })
}

/// Check if a file or directory exists synchronously.
///
/// Examples:
///   (fs/blocking-exists? "/tmp/test.txt")  ; => Result.Ok { value: true }
fn blocking-exists?(path) {
    run-blocking(fn() { exists?(path) })
}

fn blocking-file-size(path) {
    run-blocking(fn() { file-size(path) })
}

fn blocking-is-file?(path) {
    run-blocking(fn() { is-file?(path) })
}

fn blocking-is-directory?(path) {
    run-blocking(fn() { is-directory?(path) })
}

fn blocking-rename(old-path, new-path) {
    run-blocking(fn() { rename(old-path, new-path) })
}

fn blocking-copy(src-path, dest-path) {
    run-blocking(fn() { copy(src-path, dest-path) })
}

/// List directory contents synchronously.
///
/// Returns a Result containing a vector of filenames.
///
/// Examples:
///   (fs/blocking-read-dir "/tmp")  ; => Result.Ok { value: ["file1.txt", "file2.txt"] }
fn blocking-read-dir(path) {
    run-blocking(fn() { read-dir(path) })
}

/// Create a directory synchronously.
///
/// Examples:
///   (fs/blocking-create-dir "/tmp/mydir")
fn blocking-create-dir(path) {
    run-blocking(fn() { create-dir(path) })
}

fn blocking-create-dir-all(path) {
    run-blocking(fn() { create-dir-all(path) })
}

fn blocking-remove-dir(path) {
    run-blocking(fn() { remove-dir(path) })
}

fn blocking-remove-dir-all(path) {
    run-blocking(fn() { remove-dir-all(path) })
}
