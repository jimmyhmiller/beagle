namespace beagle.io

use beagle.ffi as ffi
use beagle.builtin as builtin

// Load libc (platform-specific path)
fn get-libc-path() {
    let os = get-os()
    if os == "macos" {
        "/usr/lib/libSystem.dylib"
    } else if os == "linux" {
        "libc.so.6"
    } else {
        // Windows or unknown - this will fail but provides a clear error
        "libc"
    }
}

let libc = ffi/load-library(get-libc-path())

// Result type for error handling
enum Result {
    Ok { value },
    Err { code, message }
}

fn ok(value) { Result.Ok { value: value } }
fn err(code, msg) { Result.Err { code: code, message: msg } }

// Check if a result is ok
fn ok?(result) {
    match result {
        Result.Ok { value } => true,
        Result.Err { code, message } => false
    }
}

// Unwrap a result, printing error and returning null on error
fn unwrap(result) {
    match result {
        Result.Ok { value } => value,
        Result.Err { code, message } => {
            println("Error: ", message)
            null
        }
    }
}

// FFI function bindings for FILE* operations
let _fopen = ffi/get-function(libc, "fopen",
    [ffi/Type.String, ffi/Type.String], ffi/Type.Pointer)
let _fclose = ffi/get-function(libc, "fclose",
    [ffi/Type.Pointer], ffi/Type.I32)
let _fread = ffi/get-function(libc, "fread",
    [ffi/Type.Pointer, ffi/Type.U64, ffi/Type.U64, ffi/Type.Pointer], ffi/Type.U64)
let _fwrite = ffi/get-function(libc, "fwrite",
    [ffi/Type.Pointer, ffi/Type.U64, ffi/Type.U64, ffi/Type.Pointer], ffi/Type.U64)
let _fgetc = ffi/get-function(libc, "fgetc",
    [ffi/Type.Pointer], ffi/Type.I32)
let _fputc = ffi/get-function(libc, "fputc",
    [ffi/Type.I32, ffi/Type.Pointer], ffi/Type.I32)
let _fflush = ffi/get-function(libc, "fflush",
    [ffi/Type.Pointer], ffi/Type.I32)
let _feof = ffi/get-function(libc, "feof",
    [ffi/Type.Pointer], ffi/Type.I32)

// FFI bindings for fd-based operations (stdin/stdout/stderr)
let _read = ffi/get-function(libc, "read",
    [ffi/Type.I32, ffi/Type.Pointer, ffi/Type.U64], ffi/Type.I32)
let _write = ffi/get-function(libc, "write",
    [ffi/Type.I32, ffi/Type.Pointer, ffi/Type.U64], ffi/Type.I32)

// File struct wrapper
struct File { handle }

// Buffer result for read operations
struct BufferResult { buffer, length }

// Standard file descriptors
let STDIN-FD = 0
let STDOUT-FD = 1
let STDERR-FD = 2

// Helper: check if a pointer is null
fn is-null(pointer) {
    pointer.ptr == 0
}

// Helper: copy string bytes to a buffer
// Returns a buffer containing the string bytes
fn string-to-buffer(s) {
    let len = length(s)
    let buf = ffi/allocate(len)
    let mut i = 0
    while i < len {
        let char = get(s, i)
        let byte = builtin/char-code(char)
        ffi/set-u8(buf, i, byte)
        i = i + 1
    }
    buf
}

// === FILE* based operations (for regular files) ===

fn open(path, mode) {
    let handle = _fopen(path, mode, 0, 0, 0, 0)
    if is-null(handle) {
        err(-1, "Failed to open file")
    } else {
        ok(File { handle: handle })
    }
}

fn close(file) {
    let result = _fclose(file.handle, 0, 0, 0, 0, 0)
    if result == 0 {
        ok(null)
    } else {
        err(result, "Failed to close file")
    }
}

fn read-bytes(file, n) {
    let buf = ffi/allocate(n)
    let bytes-read = _fread(buf, 1, n, file.handle, 0, 0)
    ok(BufferResult { buffer: buf, length: bytes-read })
}

fn read-char(file) {
    let c = _fgetc(file.handle, 0, 0, 0, 0, 0)
    if c == -1 {
        err(-1, "EOF or error")
    } else {
        ok(c)
    }
}

fn write-bytes(file, buf, len) {
    let written = _fwrite(buf, 1, len, file.handle, 0, 0)
    ok(written)
}

fn write-string(file, s) {
    let len = length(s)
    let buf = string-to-buffer(s)
    let written = _fwrite(buf, 1, len, file.handle, 0, 0)
    ffi/deallocate(buf)
    ok(written)
}

fn flush(file) {
    let result = _fflush(file.handle, 0, 0, 0, 0, 0)
    if result == 0 {
        ok(null)
    } else {
        err(result, "Failed to flush file")
    }
}

fn eof?(file) {
    _feof(file.handle, 0, 0, 0, 0, 0) != 0
}

// Read a line from a file (up to newline or max-len bytes)
fn read-line(file, max-len) {
    let buf = ffi/allocate(max-len)
    let mut i = 0
    let mut done = false
    // Use done == false instead of !done for while condition
    while i < max-len && done == false {
        let c = _fgetc(file.handle, 0, 0, 0, 0, 0)
        if c == -1 {
            done = true
        } else if c == 10 {
            // newline character
            ffi/set-u8(buf, i, c)
            i = i + 1
            done = true
        } else {
            ffi/set-u8(buf, i, c)
            i = i + 1
        }
    }
    if i == 0 && done {
        ffi/deallocate(buf)
        err(-1, "EOF")
    } else {
        let s = ffi/get-string(buf, 0, i)
        ffi/deallocate(buf)
        ok(s)
    }
}

// === FD-based operations (for stdin/stdout/stderr) ===

fn read-stdin(n) {
    let buf = ffi/allocate(n)
    let bytes-read = _read(STDIN-FD, buf, n, 0, 0, 0)
    if bytes-read < 0 {
        ffi/deallocate(buf)
        err(bytes-read, "Read error")
    } else {
        ok(BufferResult { buffer: buf, length: bytes-read })
    }
}

fn read-stdin-string(n) {
    let result = read-stdin(n)
    match result {
        Result.Ok { value } => {
            let s = ffi/get-string(value.buffer, 0, value.length)
            ffi/deallocate(value.buffer)
            ok(s)
        },
        Result.Err { code, message } => err(code, message)
    }
}

fn write-stdout(s) {
    let len = length(s)
    let buf = string-to-buffer(s)
    let written = _write(STDOUT-FD, buf, len, 0, 0, 0)
    ffi/deallocate(buf)
    if written < 0 {
        err(written, "Write error")
    } else {
        ok(written)
    }
}

// Write raw buffer to stdout - no string conversion overhead
fn write-stdout-buffer(buf, len) {
    let written = _write(STDOUT-FD, buf, len, 0, 0, 0)
    if written < 0 {
        err(written, "Write error")
    } else {
        ok(written)
    }
}

fn write-stderr(s) {
    let len = length(s)
    let buf = string-to-buffer(s)
    let written = _write(STDERR-FD, buf, len, 0, 0, 0)
    ffi/deallocate(buf)
    if written < 0 {
        err(written, "Write error")
    } else {
        ok(written)
    }
}

// Write from buffer at offset to stdout - for efficient partial buffer writes
fn write-stdout-buffer-offset(buf, offset, len) {
    let written = ffi/write-buffer-offset(STDOUT-FD, buf, offset, len)
    if written < 0 {
        err(written, "Write error")
    } else {
        ok(written)
    }
}

// Read a line from stdin (up to max-len bytes)
fn read-stdin-line(max-len) {
    let buf = ffi/allocate(max-len)
    let one-byte-buf = ffi/allocate(1)
    let mut i = 0
    let mut done = false
    // Use done == false instead of !done for while condition
    while i < max-len && done == false {
        let bytes-read = _read(STDIN-FD, one-byte-buf, 1, 0, 0, 0)
        if bytes-read <= 0 {
            done = true
        } else {
            // Read the byte we just got and copy to main buffer
            let char-str = ffi/get-string(one-byte-buf, 0, 1)
            let c = builtin/char-code(char-str)
            ffi/set-u8(buf, i, c)
            if c == 10 {
                // newline
                i = i + 1
                done = true
            } else {
                i = i + 1
            }
        }
    }
    ffi/deallocate(one-byte-buf)
    if i == 0 {
        ffi/deallocate(buf)
        err(-1, "EOF")
    } else {
        let s = ffi/get-string(buf, 0, i)
        ffi/deallocate(buf)
        ok(s)
    }
}
