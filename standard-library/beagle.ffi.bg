namespace beagle.ffi

use beagle.builtin as builtin


// Probably should move this stuff to an ffi namespace
struct Library {
    id
}

fn __make_lib_struct(id) {
    Library { id: id }
}


struct Pointer {
    ptr
}

struct Buffer {
    ptr
    size
}

fn __make_pointer_struct(ptr) {
    Pointer { ptr: ptr }
}

fn __make_buffer_struct(ptr, size) {
    Buffer { ptr: ptr, size: size }
}

// Struct for holding raw C struct returns (up to 16 bytes)
// low = first 8 bytes, high = second 8 bytes
struct StructReturn {
    low
    high
}

fn __make_struct_return(low, high) {
    StructReturn { low: low, high: high }
}

enum Type {
    U8,
    U16,
    U32,
    U64,
    I32,
    F32,
    Pointer,
    MutablePointer,
    String,
    Void,
    Structure {
        types
    }
}

// TODO: I could make a function that maps between a type an integer
// but I don't actually have equality defined for structures

fn __create_ffi_function(ffi-info) {
    fn(...args) {
        builtin/__register_c_call();
        let result = call-ffi-info(ffi-info, args)
        builtin/__unregister_c_call()
        result
    }
}

// These functions are implemented as builtins in Rust:
// - allocate(size) -> Buffer
// - deallocate(buffer) -> null
// - get-u8(buffer, offset) -> byte
// - set-u8(buffer, offset, value) -> null
// - get-i32(buffer, offset) -> i32
// - set-i32(buffer, offset, value) -> null
// - get-u32(buffer, offset) -> u32
// - set-i16(buffer, offset, value) -> null
// - get-string(buffer, offset, len) -> string
// - copy-bytes(src, src-off, dst, dst-off, len) -> null  (memcpy)
// - realloc(buffer, new-size) -> new-buffer
// - buffer-size(buffer) -> size
// - write-buffer-offset(fd, buffer, offset, len) -> bytes-written
