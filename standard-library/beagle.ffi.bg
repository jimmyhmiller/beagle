namespace beagle.ffi

import "beagle.builtin" as builtin


// Probably should move this stuff to an ffi namespace
struct Library {
    id
}

fn __make_lib_struct(id) {
    Library { id: id }
}


struct Pointer {
    ptr
}

struct Buffer {
    ptr
    size
}

fn __make_pointer_struct(ptr) {
    Pointer { ptr: ptr }
}

fn __make_buffer_struct(ptr, size) {
    Buffer { ptr: ptr, size: size }
}

enum Type {
    U8,
    U16,
    U32,
    U64,
    I32,
    Pointer,
    MutablePointer,
    String,
    Void,
    Structure {
        types
    }
}

// TODO: I could make a function that maps between a type an integer
// but I don't actually have equality defined for structures

fn __create_ffi_function(ffi_info) {
    // Wrapper takes exactly 6 args - callers must pass all 6
    fn(a1, a2, a3, a4, a5, a6) {
        builtin/__register_c_call();
        let result = call_ffi_info(ffi_info, a1, a2, a3, a4, a5, a6)
        builtin/__unregister_c_call()
        result
    }
}

// These functions are implemented as builtins in Rust:
// - allocate(size) -> Buffer
// - deallocate(buffer) -> null
// - get_u8(buffer, offset) -> byte
// - set_u8(buffer, offset, value) -> null
// - get_i32(buffer, offset) -> i32
// - set_i32(buffer, offset, value) -> null
// - get_u32(buffer, offset) -> u32
// - set_i16(buffer, offset, value) -> null
// - get_string(buffer, offset, len) -> string
// - copy_bytes(src, src_off, dst, dst_off, len) -> null  (memcpy)
// - realloc(buffer, new_size) -> new_buffer
// - buffer_size(buffer) -> size
// - write_buffer_offset(fd, buffer, offset, len) -> bytes_written