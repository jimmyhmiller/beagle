namespace beagle.core;
import "beagle.primitive" as primitive
import "beagle.builtin" as builtin
import "beagle.collections" as rust-coll
// TODO: I need to figure out how I deal with the circular nature
// of having persistent vector not be in this namespace
// One answer is to have dynamic imports
// so that after I define the things persistent vector depends on
// I can import it dynamically

// I need to think about execution order as well
// If I import a namespace, does that namespaces top level
// get called before I compile the current namespace
// It seems like it should.
// But I need to do that on the calling thread
// so I will need some back and forth going on there

// TODO: This is hack because 0 is making the fast path cache activate
// fix by changing id or filling the cache
struct NEVER {}

struct Struct {
    name
    id
}

extend Struct with Format {
    fn format(self, depth) {
        self.name
    }
}

// Type descriptors for primitive types
// These are Struct instances that describe each built-in type
// Negative IDs distinguish primitives from custom structs (which have positive IDs)
let Array = Struct {
    name: "Array",
    id: -1
}

let String = Struct {
    name: "String",
    id: -2
}

let Int = Struct {
    name: "Int",
    id: -3
}

let Float = Struct {
    name: "Float",
    id: -4
}

let Bool = Struct {
    name: "Bool",
    id: -5
}

let Null = Struct {
    name: "Null",
    id: -6
}

let Function = Struct {
    name: "Function",
    id: -7
}

let Closure = Struct {
    name: "Closure",
    id: -8
}

let Keyword = Struct {
    name: "Keyword",
    id: -9
}

// Persistent collection types (Rust-backed HAMT implementations)
// These use negative IDs that map to the runtime type IDs
// (negative ID gets converted to primitive_dispatch index)
let PersistentVector = Struct {
    name: "PersistentVector",
    id: -20
}

let PersistentMap = Struct {
    name: "PersistentMap",
    id: -22
}

let PersistentSet = Struct {
    name: "PersistentSet",
    id: -28
}

let MultiArityFunction = Struct {
    name: "MultiArityFunction",
    id: -29
}

// ============================================================================
// Math Constants
// ============================================================================

let PI = 3.141592653589793
let E = 2.718281828459045
let TAU = 6.283185307179586

// ============================================================================
// Protocol Definitions
// ============================================================================

struct Protocol {
    name
}

protocol Indexed {
    fn get(coll, index)
}

protocol Push {
    fn push(coll, value)
}

protocol Length {
    fn length(coll)
}

protocol Format {
    fn format(self, depth) {
        to-string(self)
    }
}

protocol Associable {
    fn assoc(coll, key, value)
}

protocol Keys {
    fn keys(coll)
}

protocol Seqable {
    fn seq(coll)
}

protocol Seq {
    fn first(seq)
    fn next(seq)
}

extend String with Format {
    fn format(self, depth) {
        if depth > 0 {
            "\"" ++ self ++ "\""
        } else {
            self
        }
    }
}

// ============================================================================
// Rust PersistentVector Protocol Implementations
// ============================================================================

extend PersistentVector with Indexed {
    fn get(vec, index) {
        rust-coll/vec-get(vec, index)
    }
}

extend PersistentVector with Length {
    fn length(vec) {
        rust-coll/vec-count(vec)
    }
}

extend PersistentVector with Push {
    fn push(vec, value) {
        rust-coll/vec-push(vec, value)
    }
}

extend PersistentVector with Format {
    fn format(vec, depth) {
        let len = rust-coll/vec-count(vec)
        format-rust-vec-helper(vec, 0, len, "[")
    }
}

fn format-rust-vec-helper(vec, idx, len, acc) {
    if idx >= len {
        acc ++ "]"
    } else {
        let elem = rust-coll/vec-get(vec, idx)
        let elem-str = format(elem, 1)
        let new-acc = if idx == 0 {
            acc ++ elem-str
        } else {
            acc ++ ", " ++ elem-str
        }
        format-rust-vec-helper(vec, idx + 1, len, new-acc)
    }
}

extend PersistentVector with Associable {
    fn assoc(vec, index, value) {
        rust-coll/vec-assoc(vec, index, value)
    }
}

// ============================================================================
// Rust PersistentMap Protocol Implementations
// ============================================================================

extend PersistentMap with Indexed {
    fn get(map, key) {
        rust-coll/map-get(map, key)
    }
}

extend PersistentMap with Length {
    fn length(map) {
        rust-coll/map-count(map)
    }
}

extend PersistentMap with Associable {
    fn assoc(map, key, value) {
        rust-coll/map-assoc(map, key, value)
    }
}

extend PersistentMap with Keys {
    fn keys(map) {
        rust-coll/map-keys(map)
    }
}

extend PersistentMap with Format {
    fn format(map, depth) {
        let ks = rust-coll/map-keys(map)
        let len = rust-coll/vec-count(ks)
        if len == 0 {
            "{}"
        } else {
            format-rust-map-entries(map, ks, 0, len, "{")
        }
    }
}

fn format-rust-map-entries(map, keys-vec, idx, len, acc) {
    if idx >= len {
        acc ++ "}"
    } else {
        let key = rust-coll/vec-get(keys-vec, idx)
        let val = rust-coll/map-get(map, key)
        let key-str = format(key, 1)
        let val-str = format(val, 1)
        let entry = key-str ++ ": " ++ val-str
        let new-acc = if idx == 0 {
            acc ++ entry
        } else {
            acc ++ ", " ++ entry
        }
        format-rust-map-entries(map, keys-vec, idx + 1, len, new-acc)
    }
}

// This may seem weird
// but we need our runtime to know
// how to call a function if it is a closure
// or a regular function
// this makes that idea simple
fn __call_fn(f) { f() }

// Thread struct - holds the closure to be executed and serves as a GC root
// for running threads. The Thread object keeps the closure alive while the
// thread is running.
struct Thread {
    closure
}

// Called by the runtime to start a thread. This function takes no arguments
// and reads the Thread object via a builtin. This ensures GC can properly
// update the stack slot containing the Thread object.
fn __run_thread_start() {
    let thread-obj = primitive/__get-my-thread-obj();
    let f = thread-obj.closure;
    f()
}

// Legacy function - kept for compatibility but no longer used.
fn __run_thread_closure(thread-obj) {
    let f = thread-obj.closure;
    f()
}

struct Atom {
    value
}

fn deref(atom) {
    // assert!(atom is Atom)
    primitive/deref(atom)
}

fn swap!(atom, f) {
    let initial = deref(atom);
    let new = f(initial);
    let result = compare-and-swap!(atom, initial, new);
    if result {
        new
    } else {
        swap!(atom, f)
    }
}

fn reset!(atom, value) {
    // assert!(atom is Atom)
    primitive/reset!(atom, value)
}

fn compare-and-swap!(atom, old, new) {
    // assert!(atom is Atom)
    primitive/compare-and-swap!(atom, old, new)
}

fn atom(value) {
    // TODO: Allow punning
    Atom { value: value }
}

// TODO: If I move the || on the next line,
// my parser is unhappy
// TODO: Need to make sure type is instance-of Struct
// but how do I do that in a reasonable way?
fn instance-of(value, type) {
    if type.id < 0 {
        // Primitive type - use type-of equality
        equal(type-of(value), type)
    } else {
        // Custom struct - check struct-id
        primitive/is-object(value) && primitive/read-struct-id(value) == type.id
    }
}


extend String with Indexed {
    fn get(str, i) {
        builtin/get-string-index(str, i)
    }
}

extend String with Length {
    fn length(str) {
        builtin/get-string-length(str)
    }
}

// Array protocol extensions for variadic function arguments
// Arrays are raw mutable arrays with type-id = 1
extend Array with Indexed {
    fn get(arr, i) {
        if i < 0 || i >= primitive/size(arr) {
            null
        } else {
            primitive/read-field(arr, i)
        }
    }
}

extend Array with Length {
    fn length(arr) {
        primitive/size(arr)
    }
}

// PersistentVector protocol extensions (Rust-backed vector from literals)
extend PersistentVector with Length {
    fn length(vec) {
        rust-coll/vec-count(vec)
    }
}

extend PersistentVector with Indexed {
    fn get(vec, i) {
        rust-coll/vec-get(vec, i)
    }
}

extend PersistentVector with Push {
    fn push(vec, value) {
        rust-coll/vec-push(vec, value)
    }
}

extend PersistentVector with Seqable {
    fn seq(vec) {
        if rust-coll/vec-count(vec) == 0 {
            null
        } else {
            PersistentVectorSeq { vec: vec, index: 0 }
        }
    }
}

// PersistentMap protocol extensions (Rust-backed map from literals)
extend PersistentMap with Length {
    fn length(m) {
        rust-coll/map-count(m)
    }
}

extend PersistentMap with Indexed {
    fn get(m, key) {
        rust-coll/map-get(m, key)
    }
}

extend PersistentMap with Associable {
    fn assoc(m, key, value) {
        rust-coll/map-assoc(m, key, value)
    }
}

// Sequence type for iterating over PersistentVector
struct PersistentVectorSeq {
    vec
    index
}

extend PersistentVectorSeq with Seq {
    fn first(seq) {
        rust-coll/vec-get(seq.vec, seq.index)
    }

    fn next(seq) {
        let next-index = seq.index + 1
        if next-index >= rust-coll/vec-count(seq.vec) {
            null
        } else {
            PersistentVectorSeq { vec: seq.vec, index: next-index }
        }
    }
}

// Helper for formatting PersistentVector
fn format-persistent-vector-helper(vec, idx, acc, depth) {
    if idx >= rust-coll/vec-count(vec) {
        acc
    } else {
        let elem = rust-coll/vec-get(vec, idx)
        let elem-str = format(elem, depth + 1)
        let new-acc = if idx == 0 {
            acc ++ elem-str
        } else {
            acc ++ ", " ++ elem-str
        }
        format-persistent-vector-helper(vec, idx + 1, new-acc, depth)
    }
}

extend PersistentVector with Format {
    fn format(self, depth) {
        "[" ++ format-persistent-vector-helper(self, 0, "", depth) ++ "]"
    }
}

// // TODO: Need a way to re-export rather than wrap
// fn get(coll, i) {
//     persistent-vector/get(coll, i)
// }

// fn push(coll, value) {
//     persistent-vector/push(coll, value)
// }

// print: prints arguments separated by spaces, NO newline at end
fn print(...args) {
    let len = length(args)
    if len == 0 {
        null
    } else {
        let mut last = null
        let mut i = 0
        while i < len {
            if i > 0 {
                _print(" ")
            }
            last = get(args, i)
            _print(format(last, 0))
            i = i + 1
        }
        last
    }
}

// println: prints arguments separated by spaces, WITH newline at end
fn println(...args) {
    let len = length(args)
    if len == 0 {
        _print("\n")
        null
    } else {
        let mut last = null
        let mut i = 0
        while i < len {
            if i > 0 {
                _print(" ")
            }
            last = get(args, i)
            _print(format(last, 0))
            i = i + 1
        }
        _print("\n")
        last
    }
}

// Keyword functions
fn keyword?(value) {
    builtin/is-keyword(value)
}

fn keyword->string(kw) {
    builtin/keyword-to-string(kw)
}

fn string->keyword(str) {
    builtin/string-to-keyword(str)
}


struct __Box__ {
    value
}

// System error enum for exception handling
enum SystemError {
    StructError { message, location }
    ParseError { message, location }
    CompileError { message, location }
    TypeError { message, location }
    ArityError { message, location }
    RuntimeError { message, location }
    ThreadError { message, location }
    FFIError { message, location }
    FunctionError { message, location }
    FieldError { message, location }
    IndexError { message, location }
    MutabilityError { message, location }
}

// Compiler warning information for programmatic inspection
struct CompilerWarning {
    kind             // String: warning type identifier
    file-name        // String: source file path
    line             // Int: 1-based line number
    column           // Int: 1-based column number
    message          // String: human-readable description
    enum-name        // String or null: for NonExhaustiveMatch warnings
    missing-variants // PersistentVector or null: for NonExhaustiveMatch warnings
}

// Range type for iteration
struct Range {
    current
    end
    step
}

fn range(start, end) {
    Range { current: start, end: end, step: 1 }
}

fn range-step(start, end, step) {
    Range { current: start, end: end, step: step }
}

extend Range with Seqable {
    fn seq(r) {
        if r.current >= r.end {
            null
        } else {
            r
        }
    }
}

extend Range with Seq {
    fn first(r) {
        r.current
    }

    fn next(r) {
        let next-val = r.current + r.step
        if next-val >= r.end {
            null
        } else {
            Range { current: next-val, end: r.end, step: r.step }
        }
    }
}

// String sequence for iteration
struct StringSeq {
    str
    index
}

extend String with Seqable {
    fn seq(str) {
        if length(str) == 0 {
            null
        } else {
            StringSeq { str: str, index: 0 }
        }
    }
}

extend StringSeq with Seq {
    fn first(seq) {
        get(seq.str, seq.index)
    }

    fn next(seq) {
        let next-index = seq.index + 1
        if next-index >= length(seq.str) {
            null
        } else {
            StringSeq { str: seq.str, index: next-index }
        }
    }
}

// ============================================================================
// Higher-Order Collection Functions
// ============================================================================

// reduce: Fold a collection with an accumulator
// Works with any Seqable type
fn reduce(coll, init, f) {
    let mut s = seq(coll)
    let mut acc = init
    while s != null {
        let elem = first(s)
        acc = f(acc, elem)
        s = next(s)
    }
    acc
}

// map: Apply f to each element, return new vector
fn map(coll, f) {
    let mut s = seq(coll)
    let mut acc = []
    while s != null {
        let elem = first(s)
        acc = push(acc, f(elem))
        s = next(s)
    }
    acc
}

// filter: Keep elements where pred returns true
fn filter(coll, pred) {
    let mut s = seq(coll)
    let mut acc = []
    while s != null {
        let elem = first(s)
        if pred(elem) {
            acc = push(acc, elem)
        }
        s = next(s)
    }
    acc
}

// any?: True if any element matches predicate
fn any?(coll, pred) {
    let mut s = seq(coll)
    let mut found = false
    while s != null && found == false {
        if pred(first(s)) {
            found = true
        }
        s = next(s)
    }
    found
}

// all?: True if all elements match predicate
fn all?(coll, pred) {
    let mut s = seq(coll)
    let mut all-match = true
    while s != null && all-match {
        if pred(first(s)) == false {
            all-match = false
        }
        s = next(s)
    }
    all-match
}

// none?: True if no elements match predicate
fn none?(coll, pred) {
    let mut s = seq(coll)
    let mut none-match = true
    while s != null && none-match {
        if pred(first(s)) {
            none-match = false
        }
        s = next(s)
    }
    none-match
}

// find: Return first element matching predicate, or null
fn find(coll, pred) {
    let mut s = seq(coll)
    let mut result = null
    let mut found = false
    while s != null && found == false {
        let elem = first(s)
        if pred(elem) {
            result = elem
            found = true
        }
        s = next(s)
    }
    result
}

// find-index: Return index of first element matching predicate, or -1
fn find-index(coll, pred) {
    let mut s = seq(coll)
    let mut idx = 0
    let mut result = -1
    let mut found = false
    while s != null && found == false {
        if pred(first(s)) {
            result = idx
            found = true
        }
        s = next(s)
        idx = idx + 1
    }
    result
}

// take: Return first n elements
fn take(coll, n) {
    let mut s = seq(coll)
    let mut remaining = n
    let mut acc = []
    while s != null && remaining > 0 {
        acc = push(acc, first(s))
        s = next(s)
        remaining = remaining - 1
    }
    acc
}

// drop: Skip first n elements, return rest
fn drop(coll, n) {
    let mut s = seq(coll)
    let mut remaining = n
    while s != null && remaining > 0 {
        s = next(s)
        remaining = remaining - 1
    }
    let mut acc = []
    while s != null {
        acc = push(acc, first(s))
        s = next(s)
    }
    acc
}

// take-while: Take elements while predicate is true
fn take-while(coll, pred) {
    let mut s = seq(coll)
    let mut acc = []
    let mut taking = true
    while s != null && taking {
        let elem = first(s)
        if pred(elem) {
            acc = push(acc, elem)
            s = next(s)
        } else {
            taking = false
        }
    }
    acc
}

// drop-while: Drop elements while predicate is true, return rest
fn drop-while(coll, pred) {
    let mut s = seq(coll)
    while s != null && pred(first(s)) {
        s = next(s)
    }
    let mut acc = []
    while s != null {
        acc = push(acc, first(s))
        s = next(s)
    }
    acc
}

// slice: Get sub-collection from start (inclusive) to end (exclusive)
fn slice(coll, start, end) {
    take(drop(coll, start), end - start)
}

// ============================================================================
// Element Access Functions
// ============================================================================

// count: Alias for length (more idiomatic for collections)
fn count(coll) {
    length(coll)
}

// empty?: True if collection has no elements
fn empty?(coll) {
    length(coll) == 0
}

// first-of: Get first element of a collection (works with any Seqable)
// Named differently to avoid conflict with Seq protocol's first
fn first-of(coll) {
    let s = seq(coll)
    if s == null {
        null
    } else {
        first(s)
    }
}

// last: Get last element of a collection
fn last(coll) {
    let mut s = seq(coll)
    let mut prev = null
    while s != null {
        prev = first(s)
        s = next(s)
    }
    prev
}

// rest: All elements except the first
fn rest(coll) {
    drop(coll, 1)
}

// butlast: All elements except the last
fn butlast(coll) {
    let len = length(coll)
    if len <= 1 {
        []
    } else {
        take(coll, len - 1)
    }
}

// nth: Get element at index with bounds checking (returns null if out of bounds)
fn nth(coll, n) {
    get(coll, n)
}

// second: Get second element
fn second(coll) {
    nth(coll, 1)
}

// third: Get third element
fn third(coll) {
    nth(coll, 2)
}

// ============================================================================
// Min/Max Functions
// ============================================================================

// min-of: Return minimum element in collection
fn min-of(coll) {
    let mut s = seq(coll)
    if s == null {
        null
    } else {
        let mut min-val = first(s)
        s = next(s)
        while s != null {
            let elem = first(s)
            if elem < min-val {
                min-val = elem
            }
            s = next(s)
        }
        min-val
    }
}

// max-of: Return maximum element in collection
fn max-of(coll) {
    let mut s = seq(coll)
    if s == null {
        null
    } else {
        let mut max-val = first(s)
        s = next(s)
        while s != null {
            let elem = first(s)
            if elem > max-val {
                max-val = elem
            }
            s = next(s)
        }
        max-val
    }
}

// min-by: Return element with minimum value of (f elem)
fn min-by(coll, f) {
    let mut s = seq(coll)
    if s == null {
        null
    } else {
        let mut min-elem = first(s)
        let mut min-val = f(min-elem)
        s = next(s)
        while s != null {
            let elem = first(s)
            let val = f(elem)
            if val < min-val {
                min-elem = elem
                min-val = val
            }
            s = next(s)
        }
        min-elem
    }
}

// max-by: Return element with maximum value of (f elem)
fn max-by(coll, f) {
    let mut s = seq(coll)
    if s == null {
        null
    } else {
        let mut max-elem = first(s)
        let mut max-val = f(max-elem)
        s = next(s)
        while s != null {
            let elem = first(s)
            let val = f(elem)
            if val > max-val {
                max-elem = elem
                max-val = val
            }
            s = next(s)
        }
        max-elem
    }
}

// reduce-right: Reduce from right to left
fn reduce-right(coll, init, f) {
    // Convert to vector and iterate backwards
    let v = if instance-of(coll, PersistentVector) {
        coll
    } else {
        reduce(coll, [], fn(acc, x) { push(acc, x) })
    }
    let len = length(v)
    let mut acc = init
    let mut i = len - 1
    while i >= 0 {
        acc = f(acc, get(v, i))
        i = i - 1
    }
    acc
}

// ============================================================================
// Combining Functions
// ============================================================================

// concat: Combine two collections into one
fn concat(coll1, coll2) {
    let mut acc = []
    let mut s = seq(coll1)
    while s != null {
        acc = push(acc, first(s))
        s = next(s)
    }
    s = seq(coll2)
    while s != null {
        acc = push(acc, first(s))
        s = next(s)
    }
    acc
}

// flatten: Flatten one level of nesting
fn flatten(coll) {
    let mut s = seq(coll)
    let mut acc = []
    while s != null {
        let elem = first(s)
        acc = reduce(elem, acc, fn(a, x) { push(a, x) })
        s = next(s)
    }
    acc
}

// flat-map: Map then flatten
fn flat-map(coll, f) {
    flatten(map(coll, f))
}

// zip: Pair up elements from two collections
fn zip(coll1, coll2) {
    let mut s1 = seq(coll1)
    let mut s2 = seq(coll2)
    let mut acc = []
    while s1 != null && s2 != null {
        acc = push(acc, [first(s1), first(s2)])
        s1 = next(s1)
        s2 = next(s2)
    }
    acc
}

// zip-with: Combine elements from two collections using a function
fn zip-with(coll1, coll2, f) {
    let mut s1 = seq(coll1)
    let mut s2 = seq(coll2)
    let mut acc = []
    while s1 != null && s2 != null {
        acc = push(acc, f(first(s1), first(s2)))
        s1 = next(s1)
        s2 = next(s2)
    }
    acc
}

// interleave: Alternate elements from two collections
fn interleave(coll1, coll2) {
    let mut s1 = seq(coll1)
    let mut s2 = seq(coll2)
    let mut acc = []
    while s1 != null && s2 != null {
        acc = push(acc, first(s1))
        acc = push(acc, first(s2))
        s1 = next(s1)
        s2 = next(s2)
    }
    acc
}

// interpose: Insert separator between elements
fn interpose(coll, sep) {
    let mut s = seq(coll)
    let mut acc = []
    let mut is-first = true
    while s != null {
        if is-first {
            acc = push(acc, first(s))
            is-first = false
        } else {
            acc = push(acc, sep)
            acc = push(acc, first(s))
        }
        s = next(s)
    }
    acc
}

// ============================================================================
// Collection Creation & Transformation
// ============================================================================

// reverse: Reverse order of elements
fn reverse(coll) {
    reduce(coll, [], fn(acc, x) {
        // Build reversed by prepending - but since we only have push,
        // we reduce to a list and then build a new vector
        // Actually, simpler: just collect in reverse order
        concat([x], acc)
    })
}

// repeat: Create a vector with value repeated n times
fn repeat(value, n) {
    let mut remaining = n
    let mut acc = []
    while remaining > 0 {
        acc = push(acc, value)
        remaining = remaining - 1
    }
    acc
}

// repeatedly: Call f n times, collect results
fn repeatedly(f, n) {
    let mut remaining = n
    let mut acc = []
    while remaining > 0 {
        acc = push(acc, f())
        remaining = remaining - 1
    }
    acc
}

// iterate: Repeatedly apply f starting with init, collect n values
fn iterate(f, init, n) {
    let mut remaining = n
    let mut current = init
    let mut acc = []
    while remaining > 0 {
        acc = push(acc, current)
        current = f(current)
        remaining = remaining - 1
    }
    acc
}

// partition: Split collection into groups of n elements
fn partition(coll, n) {
    let mut remaining = coll
    let mut acc = []
    while empty?(remaining) == false {
        let chunk = take(remaining, n)
        remaining = drop(remaining, n)
        acc = push(acc, chunk)
    }
    acc
}

// group-by: Group elements by result of key function
fn group-by(coll, f) {
    let mut s = seq(coll)
    let mut groups = {}
    while s != null {
        let elem = first(s)
        let key = f(elem)
        let existing = get(groups, key)
        let updated = if existing == null {
            [elem]
        } else {
            push(existing, elem)
        }
        groups = assoc(groups, key, updated)
        s = next(s)
    }
    groups
}

// frequencies: Count occurrences of each value
fn frequencies(coll) {
    let mut s = seq(coll)
    let mut counts = {}
    while s != null {
        let elem = first(s)
        let current = get(counts, elem)
        let new-count = if current == null {
            1
        } else {
            current + 1
        }
        counts = assoc(counts, elem, new-count)
        s = next(s)
    }
    counts
}

// distinct: Remove duplicate values (keeps first occurrence)
fn distinct(coll) {
    let mut s = seq(coll)
    let mut seen = {}
    let mut acc = []
    while s != null {
        let elem = first(s)
        let already-seen = get(seen, elem)
        if already-seen == null {
            seen = assoc(seen, elem, true)
            acc = push(acc, elem)
        }
        s = next(s)
    }
    acc
}

// ============================================================================
// Sorting Functions
// ============================================================================

// Helper: insert elem into sorted vector at correct position
fn insert-sorted(sorted, elem) {
    let mut s = seq(sorted)
    let mut before = []
    let mut inserted = false
    let mut result = []

    while s != null && inserted == false {
        let current = first(s)
        if elem < current {
            // Insert elem here, then add rest
            result = concat(before, [elem])
            // Add remaining elements
            while s != null {
                result = push(result, first(s))
                s = next(s)
            }
            inserted = true
        } else {
            before = push(before, current)
            s = next(s)
        }
    }

    if inserted == false {
        // elem is largest, append at end
        result = push(before, elem)
    }

    result
}

// sort: Sort collection in ascending order (requires comparable elements)
// Uses insertion sort for simplicity
fn sort(coll) {
    let mut s = seq(coll)
    let mut sorted = []
    while s != null {
        let elem = first(s)
        sorted = insert-sorted(sorted, elem)
        s = next(s)
    }
    sorted
}

// Helper: insert elem into sorted vector by key at correct position
fn insert-sorted-by(sorted, elem, elem-key, key-fn) {
    let mut s = seq(sorted)
    let mut before = []
    let mut inserted = false
    let mut result = []

    while s != null && inserted == false {
        let current = first(s)
        let current-key = key-fn(current)
        if elem-key < current-key {
            // Insert elem here, then add rest
            result = concat(before, [elem])
            // Add remaining elements
            while s != null {
                result = push(result, first(s))
                s = next(s)
            }
            inserted = true
        } else {
            before = push(before, current)
            s = next(s)
        }
    }

    if inserted == false {
        // elem is largest, append at end
        result = push(before, elem)
    }

    result
}

// sort-by: Sort by key function result
fn sort-by(coll, f) {
    let mut s = seq(coll)
    let mut sorted = []
    while s != null {
        let elem = first(s)
        let elem-key = f(elem)
        sorted = insert-sorted-by(sorted, elem, elem-key, f)
        s = next(s)
    }
    sorted
}

// ============================================================================
// Function Utilities
// ============================================================================

// identity: Return the input unchanged
fn identity(x) {
    x
}

// constantly: Return a function that always returns value
fn constantly(value) {
    fn(ignored) { value }
}

// Note: complement, compose, pipe, partial cannot be implemented as higher-order
// functions that return closures capturing other functions, due to current
// runtime limitations with closures capturing closures.
// These patterns can still be used inline where needed.

// ============================================================================
// Boolean/Logic Utilities
// ============================================================================

// not: Boolean negation
fn not(x) {
    if x {
        false
    } else {
        true
    }
}

// truthy?: Check if value is truthy (not null and not false)
fn truthy?(x) {
    x != null && x != false
}

// falsy?: Check if value is falsy (null or false)
fn falsy?(x) {
    x == null || x == false
}

// ============================================================================
// Type Checking Predicates
// ============================================================================

// nil?: Check if value is null
fn nil?(x) {
    x == null
}

// some?: Check if value is not null
fn some?(x) {
    x != null
}

// ============================================================================
// Map Utilities
// ============================================================================

// vals: Get all values from a map as a vector
fn vals(m) {
    let ks = keys(m)
    map(ks, fn(k) { get(m, k) })
}

// dissoc: Remove a key from a map (returns new map without the key)
// For now, this is implemented by rebuilding the map without the removed key
fn dissoc(m, key) {
    let ks = keys(m)
    let filtered-keys = filter(ks, fn(k) { k != key })
    reduce(filtered-keys, {}, fn(acc, k) { assoc(acc, k, get(m, k)) })
}

// merge: Combine two maps (m2's values take precedence for duplicate keys)
fn merge(m1, m2) {
    let ks = keys(m2)
    reduce(ks, m1, fn(acc, k) { assoc(acc, k, get(m2, k)) })
}

// merge-with: Combine two maps using a function to resolve conflicts
fn merge-with(f, m1, m2) {
    merge-with-helper(f, m1, m2, keys(m2), 0, m1)
}

fn merge-with-helper(f, m1, m2, ks, idx, acc) {
    if idx >= length(ks) {
        acc
    } else {
        let k = get(ks, idx)
        let v2 = get(m2, k)
        let v1 = get(m1, k)
        let new-acc = if v1 == null {
            assoc(acc, k, v2)
        } else {
            assoc(acc, k, f(v1, v2))
        }
        merge-with-helper(f, m1, m2, ks, idx + 1, new-acc)
    }
}

// select-keys: Keep only the specified keys from a map
fn select-keys(m, ks) {
    select-keys-helper(m, ks, 0, {})
}

fn select-keys-helper(m, ks, idx, acc) {
    if idx >= length(ks) {
        acc
    } else {
        let k = get(ks, idx)
        let v = get(m, k)
        let new-acc = if v == null {
            acc
        } else {
            assoc(acc, k, v)
        }
        select-keys-helper(m, ks, idx + 1, new-acc)
    }
}

// update: Update a value at key using function f
fn update(m, key, f) {
    let old-val = get(m, key)
    assoc(m, key, f(old-val))
}

// get-in: Get nested value using path of keys
fn get-in(m, path) {
    let mut current = m
    let mut s = seq(path)
    while s != null && current != null {
        let k = first(s)
        current = get(current, k)
        s = next(s)
    }
    current
}

// assoc-in: Set nested value using path of keys
fn assoc-in(m, path, val) {
    let len = length(path)
    if len == 0 {
        m
    } else {
        if len == 1 {
            assoc(m, get(path, 0), val)
        } else {
            let k = get(path, 0)
            let rest-path = rest(path)
            let nested = get(m, k)
            let new-nested = if nested == null {
                assoc-in({}, rest-path, val)
            } else {
                assoc-in(nested, rest-path, val)
            }
            assoc(m, k, new-nested)
        }
    }
}

// update-in: Update nested value using path of keys and function
fn update-in(m, path, f) {
    let len = length(path)
    if len == 0 {
        m
    } else {
        if len == 1 {
            update(m, get(path, 0), f)
        } else {
            let k = get(path, 0)
            let rest-path = rest(path)
            let nested = get(m, k)
            let new-nested = if nested == null {
                update-in({}, rest-path, f)
            } else {
                update-in(nested, rest-path, f)
            }
            assoc(m, k, new-nested)
        }
    }
}

// contains-key?: Check if map contains a key
fn contains-key?(m, key) {
    let ks = keys(m)
    any?(ks, fn(k) { k == key })
}

// invert: Swap keys and values in a map
fn invert(m) {
    let ks = keys(m)
    reduce(ks, {}, fn(acc, k) {
        let v = get(m, k)
        assoc(acc, v, k)
    })
}

// map-keys: Apply function to all keys
fn map-keys(m, f) {
    map-keys-helper(m, f, keys(m), 0, {})
}

fn map-keys-helper(m, f, ks, idx, acc) {
    if idx >= length(ks) {
        acc
    } else {
        let k = get(ks, idx)
        let v = get(m, k)
        let new-acc = assoc(acc, f(k), v)
        map-keys-helper(m, f, ks, idx + 1, new-acc)
    }
}

// map-vals: Apply function to all values
fn map-vals(m, f) {
    map-vals-helper(m, f, keys(m), 0, {})
}

fn map-vals-helper(m, f, ks, idx, acc) {
    if idx >= length(ks) {
        acc
    } else {
        let k = get(ks, idx)
        let v = get(m, k)
        let new-acc = assoc(acc, k, f(v))
        map-vals-helper(m, f, ks, idx + 1, new-acc)
    }
}

// filter-keys: Keep only keys where predicate returns true
fn filter-keys(m, pred) {
    filter-keys-helper(m, pred, keys(m), 0, {})
}

fn filter-keys-helper(m, pred, ks, idx, acc) {
    if idx >= length(ks) {
        acc
    } else {
        let k = get(ks, idx)
        let new-acc = if pred(k) {
            assoc(acc, k, get(m, k))
        } else {
            acc
        }
        filter-keys-helper(m, pred, ks, idx + 1, new-acc)
    }
}

// filter-vals: Keep only entries where value predicate returns true
fn filter-vals(m, pred) {
    filter-vals-helper(m, pred, keys(m), 0, {})
}

fn filter-vals-helper(m, pred, ks, idx, acc) {
    if idx >= length(ks) {
        acc
    } else {
        let k = get(ks, idx)
        let v = get(m, k)
        let new-acc = if pred(v) {
            assoc(acc, k, v)
        } else {
            acc
        }
        filter-vals-helper(m, pred, ks, idx + 1, new-acc)
    }
}

// ============================================================================
// Rust PersistentSet Protocol Implementations
// ============================================================================

extend PersistentSet with Length {
    fn length(set) {
        rust-coll/set-count(set)
    }
}

extend PersistentSet with Format {
    fn format(set, depth) {
        let elems = rust-coll/set-elements(set)
        let len = rust-coll/vec-count(elems)
        if len == 0 {
            "#{}"
        } else {
            format-rust-set-elements(elems, 0, len, "#{")
        }
    }
}

fn format-rust-set-elements(elems-vec, idx, len, acc) {
    if idx >= len {
        acc ++ "}"
    } else {
        let elem = rust-coll/vec-get(elems-vec, idx)
        let elem-str = format(elem, 1)
        let new-acc = if idx == 0 {
            acc ++ elem-str
        } else {
            acc ++ ", " ++ elem-str
        }
        format-rust-set-elements(elems-vec, idx + 1, len, new-acc)
    }
}

// Sequence type for iterating over PersistentSet
struct PersistentSetSeq {
    elements
    index
}

extend PersistentSetSeq with Seq {
    fn first(seq) {
        rust-coll/vec-get(seq.elements, seq.index)
    }
    fn next(seq) {
        let next-idx = seq.index + 1
        if next-idx >= rust-coll/vec-count(seq.elements) {
            null
        } else {
            PersistentSetSeq { elements: seq.elements, index: next-idx }
        }
    }
}

extend PersistentSet with Seqable {
    fn seq(set) {
        let elems = rust-coll/set-elements(set)
        if rust-coll/vec-count(elems) == 0 {
            null
        } else {
            PersistentSetSeq { elements: elems, index: 0 }
        }
    }
}

// ============================================================================
// Set Utility Functions
// ============================================================================

// set?: Check if a value is a PersistentSet
fn set?(x) {
    instance-of(x, PersistentSet)
}

// set-contains?: Check if an element is in a set
fn set-contains?(set, elem) {
    rust-coll/set-contains?(set, elem)
}

// set-add: Add an element to a set
fn set-add(set, elem) {
    rust-coll/set-add(set, elem)
}

// set-remove: Remove an element from a set (rebuilds the set)
fn set-remove(set, elem) {
    let elems = rust-coll/set-elements(set)
    set-remove-helper(elems, elem, 0, rust-coll/vec-count(elems), #{})
}

fn set-remove-helper(elems, to-remove, idx, len, acc) {
    if idx >= len {
        acc
    } else {
        let elem = rust-coll/vec-get(elems, idx)
        let new-acc = if elem == to-remove {
            acc
        } else {
            rust-coll/set-add(acc, elem)
        }
        set-remove-helper(elems, to-remove, idx + 1, len, new-acc)
    }
}

// set-union: Return a set containing all elements from both sets
fn set-union(s1, s2) {
    let elems2 = rust-coll/set-elements(s2)
    set-union-helper(s1, elems2, 0, rust-coll/vec-count(elems2))
}

fn set-union-helper(s1, elems2, idx, len) {
    if idx >= len {
        s1
    } else {
        let elem = rust-coll/vec-get(elems2, idx)
        let new-s1 = rust-coll/set-add(s1, elem)
        set-union-helper(new-s1, elems2, idx + 1, len)
    }
}

// set-intersection: Return a set containing only elements in both sets
fn set-intersection(s1, s2) {
    let elems1 = rust-coll/set-elements(s1)
    set-intersection-helper(elems1, s2, 0, rust-coll/vec-count(elems1), #{})
}

fn set-intersection-helper(elems1, s2, idx, len, acc) {
    if idx >= len {
        acc
    } else {
        let elem = rust-coll/vec-get(elems1, idx)
        let new-acc = if rust-coll/set-contains?(s2, elem) {
            rust-coll/set-add(acc, elem)
        } else {
            acc
        }
        set-intersection-helper(elems1, s2, idx + 1, len, new-acc)
    }
}

// set-difference: Return a set containing elements in s1 but not in s2
fn set-difference(s1, s2) {
    let elems1 = rust-coll/set-elements(s1)
    set-difference-helper(elems1, s2, 0, rust-coll/vec-count(elems1), #{})
}

fn set-difference-helper(elems1, s2, idx, len, acc) {
    if idx >= len {
        acc
    } else {
        let elem = rust-coll/vec-get(elems1, idx)
        let new-acc = if rust-coll/set-contains?(s2, elem) {
            acc
        } else {
            rust-coll/set-add(acc, elem)
        }
        set-difference-helper(elems1, s2, idx + 1, len, new-acc)
    }
}

// set-subset?: Check if all elements of s1 are in s2
fn set-subset?(s1, s2) {
    let elems1 = rust-coll/set-elements(s1)
    set-subset-helper(elems1, s2, 0, rust-coll/vec-count(elems1))
}

fn set-subset-helper(elems1, s2, idx, len) {
    if idx >= len {
        true
    } else {
        let elem = rust-coll/vec-get(elems1, idx)
        if rust-coll/set-contains?(s2, elem) {
            set-subset-helper(elems1, s2, idx + 1, len)
        } else {
            false
        }
    }
}

// into-set: Convert a collection to a set
fn into-set(coll) {
    reduce(coll, #{}, fn(acc, elem) { rust-coll/set-add(acc, elem) })
}
