namespace beagle.core;
import "beagle.primitive" as primitive
import "beagle.builtin" as builtin
import "beagle.collections" as rust-coll
// TODO: I need to figure out how I deal with the circular nature
// of having persistent vector not be in this namespace
// One answer is to have dynamic imports
// so that after I define the things persistent vector depends on
// I can import it dynamically

// I need to think about execution order as well
// If I import a namespace, does that namespaces top level
// get called before I compile the current namespace
// It seems like it should.
// But I need to do that on the calling thread
// so I will need some back and forth going on there

// TODO: This is hack because 0 is making the fast path cache activate
// fix by changing id or filling the cache
struct NEVER {}

struct Struct {
    name
    id
}

extend Struct with Format {
    fn format(self, depth) {
        self.name
    }
}

// Type descriptors for primitive types
// These are Struct instances that describe each built-in type
// Negative IDs distinguish primitives from custom structs (which have positive IDs)
let Array = Struct {
    name: "Array",
    id: -1
}

let String = Struct {
    name: "String",
    id: -2
}

let Int = Struct {
    name: "Int",
    id: -3
}

let Float = Struct {
    name: "Float",
    id: -4
}

let Bool = Struct {
    name: "Bool",
    id: -5
}

let Null = Struct {
    name: "Null",
    id: -6
}

let Function = Struct {
    name: "Function",
    id: -7
}

let Closure = Struct {
    name: "Closure",
    id: -8
}

let Keyword = Struct {
    name: "Keyword",
    id: -9
}

// Persistent collection types (Rust-backed HAMT implementations)
// These use negative IDs that map to the runtime type IDs
let PersistentVector = Struct {
    name: "PersistentVector",
    id: -20
}

let PersistentMap = Struct {
    name: "PersistentMap",
    id: -22
}

struct Protocol {
    name
}

protocol Indexed {
    fn get(coll, index)
}

protocol Push {
    fn push(coll, value)
}

protocol Length {
    fn length(coll)
}

protocol Format {
    fn format(self, depth) {
        to-string(self)
    }
}

protocol Associable {
    fn assoc(coll, key, value)
}

protocol Keys {
    fn keys(coll)
}

protocol Seqable {
    fn seq(coll)
}

protocol Seq {
    fn first(seq)
    fn next(seq)
}

extend String with Format {
    fn format(self, depth) {
        if depth > 0 {
            "\"" ++ self ++ "\""
        } else {
            self
        }
    }
}

// This may seem weird
// but we need our runtime to know
// how to call a function if it is a closure
// or a regular function
// this makes that idea simple
fn __call_fn(f) { f() }

// Thread struct - holds the closure to be executed and serves as a GC root
// for running threads. The Thread object keeps the closure alive while the
// thread is running.
struct Thread {
    closure
}

// Called by the runtime to start a thread. This function takes no arguments
// and reads the Thread object via a builtin. This ensures GC can properly
// update the stack slot containing the Thread object.
fn __run_thread_start() {
    let thread-obj = primitive/__get-my-thread-obj();
    let f = thread-obj.closure;
    f()
}

// Legacy function - kept for compatibility but no longer used.
fn __run_thread_closure(thread-obj) {
    let f = thread-obj.closure;
    f()
}

struct Atom {
    value
}

fn deref(atom) {
    // assert!(atom is Atom)
    primitive/deref(atom)
}

fn swap!(atom, f) {
    let initial = deref(atom);
    let new = f(initial);
    let result = compare-and-swap!(atom, initial, new);
    if result {
        new
    } else {
        swap!(atom, f)
    }
}

fn reset!(atom, value) {
    // assert!(atom is Atom)
    primitive/reset!(atom, value)
}

fn compare-and-swap!(atom, old, new) {
    // assert!(atom is Atom)
    primitive/compare-and-swap!(atom, old, new)
}

fn atom(value) {
    // TODO: Allow punning
    Atom { value: value }
}

// TODO: If I move the || on the next line,
// my parser is unhappy
// TODO: Need to make sure type is instance-of Struct
// but how do I do that in a reasonable way?
fn instance-of(value, type) {
    if type.id < 0 {
        // Primitive type - use type-of equality
        equal(type-of(value), type)
    } else {
        // Custom struct - check struct-id
        primitive/is-object(value) && primitive/read-struct-id(value) == type.id
    }
}


extend String with Indexed {
    fn get(str, i) {
        builtin/get-string-index(str, i)
    }
}

extend String with Length {
    fn length(str) {
        builtin/get-string-length(str)
    }
}

// Array protocol extensions for variadic function arguments
// Arrays are raw mutable arrays with type-id = 1
extend Array with Indexed {
    fn get(arr, i) {
        if i < 0 || i >= primitive/size(arr) {
            null
        } else {
            primitive/read-field(arr, i)
        }
    }
}

extend Array with Length {
    fn length(arr) {
        primitive/size(arr)
    }
}

// PersistentVector protocol extensions (Rust-backed vector from literals)
extend PersistentVector with Length {
    fn length(vec) {
        rust-coll/vec-count(vec)
    }
}

extend PersistentVector with Indexed {
    fn get(vec, i) {
        rust-coll/vec-get(vec, i)
    }
}

extend PersistentVector with Push {
    fn push(vec, value) {
        rust-coll/vec-push(vec, value)
    }
}

extend PersistentVector with Seqable {
    fn seq(vec) {
        if rust-coll/vec-count(vec) == 0 {
            null
        } else {
            PersistentVectorSeq { vec: vec, index: 0 }
        }
    }
}

// PersistentMap protocol extensions (Rust-backed map from literals)
extend PersistentMap with Length {
    fn length(m) {
        rust-coll/map-count(m)
    }
}

extend PersistentMap with Indexed {
    fn get(m, key) {
        rust-coll/map-get(m, key)
    }
}

extend PersistentMap with Associable {
    fn assoc(m, key, value) {
        rust-coll/map-assoc(m, key, value)
    }
}

// Sequence type for iterating over PersistentVector
struct PersistentVectorSeq {
    vec
    index
}

extend PersistentVectorSeq with Seq {
    fn first(seq) {
        rust-coll/vec-get(seq.vec, seq.index)
    }

    fn next(seq) {
        let next-index = seq.index + 1
        if next-index >= rust-coll/vec-count(seq.vec) {
            null
        } else {
            PersistentVectorSeq { vec: seq.vec, index: next-index }
        }
    }
}

// Helper for formatting PersistentVector
fn format-persistent-vector-helper(vec, idx, acc, depth) {
    if idx >= rust-coll/vec-count(vec) {
        acc
    } else {
        let elem = rust-coll/vec-get(vec, idx)
        let elem-str = format(elem, depth + 1)
        let new-acc = if idx == 0 {
            acc ++ elem-str
        } else {
            acc ++ ", " ++ elem-str
        }
        format-persistent-vector-helper(vec, idx + 1, new-acc, depth)
    }
}

extend PersistentVector with Format {
    fn format(self, depth) {
        "[" ++ format-persistent-vector-helper(self, 0, "", depth) ++ "]"
    }
}

// // TODO: Need a way to re-export rather than wrap
// fn get(coll, i) {
//     persistent-vector/get(coll, i)
// }

// fn push(coll, value) {
//     persistent-vector/push(coll, value)
// }

// print: prints arguments separated by spaces, NO newline at end
fn print(...args) {
    let len = length(args)
    if len == 0 {
        null
    } else {
        let mut last = null
        let mut i = 0
        while i < len {
            if i > 0 {
                _print(" ")
            }
            last = get(args, i)
            _print(format(last, 0))
            i = i + 1
        }
        last
    }
}

// println: prints arguments separated by spaces, WITH newline at end
fn println(...args) {
    let len = length(args)
    if len == 0 {
        _print("\n")
        null
    } else {
        let mut last = null
        let mut i = 0
        while i < len {
            if i > 0 {
                _print(" ")
            }
            last = get(args, i)
            _print(format(last, 0))
            i = i + 1
        }
        _print("\n")
        last
    }
}

// Keyword functions
fn keyword?(value) {
    builtin/is-keyword(value)
}

fn keyword->string(kw) {
    builtin/keyword-to-string(kw)
}

fn string->keyword(str) {
    builtin/string-to-keyword(str)
}


struct __Box__ {
    value
}

// System error enum for exception handling
enum SystemError {
    StructError { message, location }
    ParseError { message, location }
    CompileError { message, location }
    TypeError { message, location }
    ArityError { message, location }
    RuntimeError { message, location }
    ThreadError { message, location }
    FFIError { message, location }
    FunctionError { message, location }
    FieldError { message, location }
    IndexError { message, location }
}

// Compiler warning information for programmatic inspection
struct CompilerWarning {
    kind             // String: warning type identifier
    file-name        // String: source file path
    line             // Int: 1-based line number
    column           // Int: 1-based column number
    message          // String: human-readable description
    enum-name        // String or null: for NonExhaustiveMatch warnings
    missing-variants // PersistentVector or null: for NonExhaustiveMatch warnings
}

// Range type for iteration
struct Range {
    current
    end
    step
}

fn range(start, end) {
    Range { current: start, end: end, step: 1 }
}

fn range-step(start, end, step) {
    Range { current: start, end: end, step: step }
}

extend Range with Seqable {
    fn seq(r) {
        if r.current >= r.end {
            null
        } else {
            r
        }
    }
}

extend Range with Seq {
    fn first(r) {
        r.current
    }

    fn next(r) {
        let next-val = r.current + r.step
        if next-val >= r.end {
            null
        } else {
            Range { current: next-val, end: r.end, step: r.step }
        }
    }
}

// String sequence for iteration
struct StringSeq {
    str
    index
}

extend String with Seqable {
    fn seq(str) {
        if length(str) == 0 {
            null
        } else {
            StringSeq { str: str, index: 0 }
        }
    }
}

extend StringSeq with Seq {
    fn first(seq) {
        get(seq.str, seq.index)
    }

    fn next(seq) {
        let next-index = seq.index + 1
        if next-index >= length(seq.str) {
            null
        } else {
            StringSeq { str: seq.str, index: next-index }
        }
    }
}
