namespace beagle.core;
import "beagle.primitive" as primitive
import "beagle.builtin" as builtin
// TODO: I need to figure out how I deal with the circular nature
// of having persistent vector not be in this namespace
// One answer is to have dynamic imports
// so that after I define the things persistent vector depends on
// I can import it dynamically

// I need to think about execution order as well
// If I import a namespace, does that namespaces top level
// get called before I compile the current namespace
// It seems like it should.
// But I need to do that on the calling thread
// so I will need some back and forth going on there

// TODO: This is hack because 0 is making the fast path cache activate
// fix by changing id or filling the cache
struct NEVER {}

struct Struct {
    name
    id
}

extend Struct with Format {
    fn format(self, depth) {
        self.name
    }
}

// Type descriptors for primitive types
// These are Struct instances that describe each built-in type
// Negative IDs distinguish primitives from custom structs (which have positive IDs)
let Array = Struct {
    name: "Array",
    id: -1
}

let String = Struct {
    name: "String",
    id: -2
}

let Int = Struct {
    name: "Int",
    id: -3
}

let Float = Struct {
    name: "Float",
    id: -4
}

let Bool = Struct {
    name: "Bool",
    id: -5
}

let Null = Struct {
    name: "Null",
    id: -6
}

let Function = Struct {
    name: "Function",
    id: -7
}

let Closure = Struct {
    name: "Closure",
    id: -8
}

let Keyword = Struct {
    name: "Keyword",
    id: -9
}

struct Protocol {
    name
}

protocol Indexed {
    fn get(coll, index)
}

protocol Push {
    fn push(coll, value)
}

protocol Length {
    fn length(coll)
}

protocol Format {
    fn format(self, depth) {
        to-string(self)
    }
}

protocol Associable {
    fn assoc(coll, key, value)
}

protocol Keys {
    fn keys(coll)
}

protocol Seqable {
    fn seq(coll)
}

protocol Seq {
    fn first(seq)
    fn next(seq)
}

extend String with Format {
    fn format(self, depth) {
        if depth > 0 {
            "\"" ++ self ++ "\""
        } else {
            self
        }
    }
}

// This may seem weird
// but we need our runtime to know
// how to call a function if it is a closure
// or a regular function
// this makes that idea simple
fn __call_fn(f) { f() }

// Thread struct - holds the closure to be executed and serves as a GC root
// for running threads. The Thread object keeps the closure alive while the
// thread is running.
struct Thread {
    closure
}

// Called by the runtime to get the closure from a Thread object and execute it.
// The Thread object is registered as a GC root, so the closure it contains
// is protected from collection and properly relocated if GC moves it.
fn __run_thread_closure(thread-obj) {
    let f = thread-obj.closure;
    f()
}

struct Atom {
    value
}

fn deref(atom) {
    // assert!(atom is Atom)
    primitive/deref(atom)
}

fn swap!(atom, f) {
    let initial = deref(atom);
    let new = f(initial);
    let result = compare-and-swap!(atom, initial, new);
    if result {
        new
    } else {
        swap!(atom, f)
    }
}

fn reset!(atom, value) {
    // assert!(atom is Atom)
    primitive/reset!(atom, value)
}

fn compare-and-swap!(atom, old, new) {
    // assert!(atom is Atom)
    primitive/compare-and-swap!(atom, old, new)
}

fn atom(value) {
    // TODO: Allow punning
    Atom { value: value }
}

// TODO: If I move the || on the next line,
// my parser is unhappy
// TODO: Need to make sure type is instance-of Struct
// but how do I do that in a reasonable way?
fn instance-of(value, type) {
    if type.id < 0 {
        // Primitive type - use type-of equality
        equal(type-of(value), type)
    } else {
        // Custom struct - check struct-id
        primitive/is-object(value) && primitive/read-struct-id(value) == type.id
    }
}


extend String with Indexed {
    fn get(str, i) {
        builtin/get-string-index(str, i)
    }
}

extend String with Length {
    fn length(str) {
        builtin/get-string-length(str)
    }
}

// Array protocol extensions for variadic function arguments
// Arrays are raw mutable arrays with type-id = 1
extend Array with Indexed {
    fn get(arr, i) {
        if i < 0 || i >= primitive/size(arr) {
            null
        } else {
            primitive/read-field(arr, i)
        }
    }
}

extend Array with Length {
    fn length(arr) {
        primitive/size(arr)
    }
}


// // TODO: Need a way to re-export rather than wrap
// fn get(coll, i) {
//     persistent-vector/get(coll, i)
// }

// fn push(coll, value) {
//     persistent-vector/push(coll, value)
// }

// print: prints arguments separated by spaces, NO newline at end
fn print(...args) {
    let len = length(args)
    if len == 0 {
        null
    } else {
        let mut last = null
        let mut i = 0
        while i < len {
            if i > 0 {
                _print(" ")
            }
            last = get(args, i)
            _print(format(last, 0))
            i = i + 1
        }
        last
    }
}

// println: prints arguments separated by spaces, WITH newline at end
fn println(...args) {
    let len = length(args)
    if len == 0 {
        _print("\n")
        null
    } else {
        let mut last = null
        let mut i = 0
        while i < len {
            if i > 0 {
                _print(" ")
            }
            last = get(args, i)
            _print(format(last, 0))
            i = i + 1
        }
        _print("\n")
        last
    }
}

// Keyword functions
fn keyword?(value) {
    builtin/is-keyword(value)
}

fn keyword->string(kw) {
    builtin/keyword-to-string(kw)
}

fn string->keyword(str) {
    builtin/string-to-keyword(str)
}


struct __Box__ {
    value
}

// System error enum for exception handling
enum SystemError {
    StructError { message, location }
    ParseError { message, location }
    CompileError { message, location }
    TypeError { message, location }
    ArityError { message, location }
    RuntimeError { message, location }
    ThreadError { message, location }
    FFIError { message, location }
    FunctionError { message, location }
    FieldError { message, location }
    IndexError { message, location }
}

// Compiler warning information for programmatic inspection
struct CompilerWarning {
    kind             // String: warning type identifier
    file-name        // String: source file path
    line             // Int: 1-based line number
    column           // Int: 1-based column number
    message          // String: human-readable description
    enum-name        // String or null: for NonExhaustiveMatch warnings
    missing-variants // PersistentVector or null: for NonExhaustiveMatch warnings
}

// Range type for iteration
struct Range {
    current
    end
    step
}

fn range(start, end) {
    Range { current: start, end: end, step: 1 }
}

fn range-step(start, end, step) {
    Range { current: start, end: end, step: step }
}

extend Range with Seqable {
    fn seq(r) {
        if r.current >= r.end {
            null
        } else {
            r
        }
    }
}

extend Range with Seq {
    fn first(r) {
        r.current
    }

    fn next(r) {
        let next-val = r.current + r.step
        if next-val >= r.end {
            null
        } else {
            Range { current: next-val, end: r.end, step: r.step }
        }
    }
}

// String sequence for iteration
struct StringSeq {
    str
    index
}

extend String with Seqable {
    fn seq(str) {
        if length(str) == 0 {
            null
        } else {
            StringSeq { str: str, index: 0 }
        }
    }
}

extend StringSeq with Seq {
    fn first(seq) {
        get(seq.str, seq.index)
    }

    fn next(seq) {
        let next-index = seq.index + 1
        if next-index >= length(seq.str) {
            null
        } else {
            StringSeq { str: seq.str, index: next-index }
        }
    }
}
