namespace beagle.core;
import "beagle.primitive" as primitive
import "beagle.builtin" as builtin
// TODO: I need to figure out how I deal with the circular nature
// of having persistent vector not be in this namespace
// One answer is to have dynamic imports
// so that after I define the things persistent vector depends on
// I can import it dynamically

// I need to think about execution order as well
// If I import a namespace, does that namespaces top level
// get called before I compile the current namespace
// It seems like it should.
// But I need to do that on the calling thread
// so I will need some back and forth going on there

// TODO: This is hack because 0 is making the fast path cache activate
// fix by changing id or filling the cache
struct NEVER {}

struct Struct {
    name
    id
}

extend Struct with Format {
    fn format(self, depth) {
        self.name
    }
}

// Type descriptors for primitive types
// These are Struct instances that describe each built-in type
// Negative IDs distinguish primitives from custom structs (which have positive IDs)
let Array = Struct {
    name: "Array",
    id: -1
}

let String = Struct {
    name: "String",
    id: -2
}

let Int = Struct {
    name: "Int",
    id: -3
}

let Float = Struct {
    name: "Float",
    id: -4
}

let Bool = Struct {
    name: "Bool",
    id: -5
}

let Null = Struct {
    name: "Null",
    id: -6
}

let Function = Struct {
    name: "Function",
    id: -7
}

let Closure = Struct {
    name: "Closure",
    id: -8
}

let Keyword = Struct {
    name: "Keyword",
    id: -9
}

struct Protocol {
    name
}

protocol Indexed {
    fn get(coll, index)
}

protocol Push {
    fn push(coll, value)
}

protocol Length {
    fn length(coll)
}

protocol Format {
    fn format(self, depth) {
        to_string(self)
    }
}

protocol Associable {
    fn assoc(coll, key, value)
}

protocol Keys {
    fn keys(coll)
}

protocol Seqable {
    fn seq(coll)
}

protocol Seq {
    fn first(seq)
    fn next(seq)
}

extend String with Format {
    fn format(self, depth) {
        if depth > 0 {
            "\"" ++ self ++ "\""
        } else {
            self
        }
    }
}

// This may seem weird
// but we need our runtime to know
// how to call a function if it is a closure
// or a regular function
// this makes that idea simple
fn __call_fn(f) { f() }

struct Atom {
    value
}

fn deref(atom) {
    // assert!(atom is Atom)
    primitive/deref(atom)
}

fn swap!(atom, f) {
    let initial = deref(atom);
    let new = f(initial);
    let result = compare_and_swap!(atom, initial, new);
    if result {
        new
    } else {
        swap!(atom, f)
    }
}

fn reset!(atom, value) {
    // assert!(atom is Atom)
    primitive/reset!(atom, value)
}

fn compare_and_swap!(atom, old, new) {
    // assert!(atom is Atom)
    primitive/compare_and_swap!(atom, old, new)
}

fn atom(value) {
    // TODO: Allow punning
    Atom { value: value }
}

// TODO: If I move the || on the next line,
// my parser is unhappy
// TODO: Need to make sure type is instance_of Struct
// but how do I do that in a reasonable way?
fn instance_of(value, type) {
    if type.id < 0 {
        // Primitive type - use type-of equality
        equal(type-of(value), type)
    } else {
        // Custom struct - check struct_id
        primitive/is_object(value) && primitive/read_struct_id(value) == type.id
    }
}


extend String with Indexed {
    fn get(str, i) {
        builtin/get_string_index(str, i)
    }
}

extend String with Length {
    fn length(str) {
        builtin/get_string_length(str)
    }
}


// // TODO: Need a way to re-export rather than wrap
// fn get(coll, i) {
//     persistent_vector/get(coll, i)
// }

// fn push(coll, value) {
//     persistent_vector/push(coll, value)
// }

fn println(value) {
    _println(format(value, 0))
}

fn print(value) {
    _print(format(value, 0))
}

// Keyword functions
fn keyword?(value) {
    builtin/is_keyword(value)
}

fn keyword->string(kw) {
    builtin/keyword_to_string(kw)
}

fn string->keyword(str) {
    builtin/string_to_keyword(str)
}


struct __Box__ {
    value
}

// System error enum for exception handling
enum SystemError {
    StructError { message, location }
    ParseError { message, location }
    CompileError { message, location }
    TypeError { message, location }
    ArityError { message, location }
    RuntimeError { message, location }
    ThreadError { message, location }
    FFIError { message, location }
    FunctionError { message, location }
    FieldError { message, location }
    IndexError { message, location }
}

// Compiler warning information for programmatic inspection
struct CompilerWarning {
    kind             // String: warning type identifier
    file_name        // String: source file path
    line             // Int: 1-based line number
    column           // Int: 1-based column number
    message          // String: human-readable description
    enum_name        // String or null: for NonExhaustiveMatch warnings
    missing_variants // PersistentVector or null: for NonExhaustiveMatch warnings
}

// Range type for iteration
struct Range {
    current
    end
    step
}

fn range(start, end) {
    Range { current: start, end: end, step: 1 }
}

fn range_step(start, end, step) {
    Range { current: start, end: end, step: step }
}

extend Range with Seqable {
    fn seq(r) {
        if r.current >= r.end {
            null
        } else {
            r
        }
    }
}

extend Range with Seq {
    fn first(r) {
        r.current
    }

    fn next(r) {
        let next_val = r.current + r.step
        if next_val >= r.end {
            null
        } else {
            Range { current: next_val, end: r.end, step: r.step }
        }
    }
}

// String sequence for iteration
struct StringSeq {
    str
    index
}

extend String with Seqable {
    fn seq(str) {
        if length(str) == 0 {
            null
        } else {
            StringSeq { str: str, index: 0 }
        }
    }
}

extend StringSeq with Seq {
    fn first(seq) {
        get(seq.str, seq.index)
    }

    fn next(seq) {
        let next_index = seq.index + 1
        if next_index >= length(seq.str) {
            null
        } else {
            StringSeq { str: seq.str, index: next_index }
        }
    }
}

