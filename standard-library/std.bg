namespace beagle.core;
use beagle.primitive as primitive
use beagle.builtin as builtin
use beagle.collections as rust-coll

// ============================================================================

// TODO: I need to figure out how I deal with the circular nature
// of having persistent vector not be in this namespace
// One answer is to have dynamic imports
// so that after I define the things persistent vector depends on
// I can import it dynamically

// I need to think about execution order as well
// If I import a namespace, does that namespaces top level
// get called before I compile the current namespace
// It seems like it should.
// But I need to do that on the calling thread
// so I will need some back and forth going on there

// TODO: This is hack because 0 is making the fast path cache activate
// fix by changing id or filling the cache
struct NEVER {}

struct Struct {
    name
    id
}

extend Struct with Format {
    fn format(self, depth) {
        self.name
    }
}

// Type descriptors for primitive types
// These are Struct instances that describe each built-in type
// Negative IDs distinguish primitives from custom structs (which have positive IDs)
let Array = Struct {
    name: "Array",
    id: -1
}

let String = Struct {
    name: "String",
    id: -2
}

let Int = Struct {
    name: "Int",
    id: -3
}

let Float = Struct {
    name: "Float",
    id: -4
}

let Bool = Struct {
    name: "Bool",
    id: -5
}

let Null = Struct {
    name: "Null",
    id: -6
}

let Function = Struct {
    name: "Function",
    id: -7
}

let Closure = Struct {
    name: "Closure",
    id: -8
}

let Keyword = Struct {
    name: "Keyword",
    id: -9
}

// Persistent collection types (Rust-backed HAMT implementations)
// These use negative IDs that map to the runtime type IDs
// (negative ID gets converted to primitive_dispatch index)
let PersistentVector = Struct {
    name: "PersistentVector",
    id: -20
}

let PersistentMap = Struct {
    name: "PersistentMap",
    id: -22
}

let PersistentSet = Struct {
    name: "PersistentSet",
    id: -28
}

let MultiArityFunction = Struct {
    name: "MultiArityFunction",
    id: -29
}

let Regex = Struct {
    name: "Regex",
    id: -30
}

// ============================================================================
// Math Constants
// ============================================================================

let PI = 3.141592653589793
let E = 2.718281828459045
let TAU = 6.283185307179586

// ============================================================================
// Protocol Definitions
// ============================================================================

struct Protocol {
    name
}

protocol Indexed {
    fn get {
        (coll, index)
        (coll, index, default) => {
            let result = get(coll, index)
            if result == null {
                default
            } else {
                result
            }
        }
    }
}

protocol Push {
    fn push(coll, value)
}

protocol Length {
    fn length(coll)
}

protocol Format {
    fn format(self, depth) {
        to-string(self)
    }
}

protocol Associable {
    fn assoc(coll, key, value)
}

protocol Keys {
    fn keys(coll)
}

protocol Seqable {
    fn seq(coll)
}

protocol Seq {
    fn first(seq)
    fn next(seq)
}

extend String with Format {
    fn format(self, depth) {
        if depth > 0 {
            "\"" ++ self ++ "\""
        } else {
            self
        }
    }
}

// ============================================================================
// Rust PersistentVector Protocol Implementations
// ============================================================================

extend PersistentVector with Indexed {
    fn get(vec, index) {
        rust-coll/vec-get(vec, index)
    }
}

extend PersistentVector with Length {
    fn length(vec) {
        rust-coll/vec-count(vec)
    }
}

extend PersistentVector with Push {
    fn push(vec, value) {
        rust-coll/vec-push(vec, value)
    }
}

extend PersistentVector with Format {
    fn format(vec, depth) {
        let len = rust-coll/vec-count(vec)
        format-rust-vec-helper(vec, 0, len, "[")
    }
}

fn format-rust-vec-helper(vec, idx, len, acc) {
    if idx >= len {
        acc ++ "]"
    } else {
        let elem = rust-coll/vec-get(vec, idx)
        let elem-str = format(elem, 1)
        let new-acc = if idx == 0 {
            acc ++ elem-str
        } else {
            acc ++ ", " ++ elem-str
        }
        format-rust-vec-helper(vec, idx + 1, len, new-acc)
    }
}

extend PersistentVector with Associable {
    fn assoc(vec, index, value) {
        rust-coll/vec-assoc(vec, index, value)
    }
}

// ============================================================================
// Rust PersistentMap Protocol Implementations
// ============================================================================

extend PersistentMap with Indexed {
    fn get(map, key) {
        rust-coll/map-get(map, key)
    }
}

extend PersistentMap with Length {
    fn length(map) {
        rust-coll/map-count(map)
    }
}

extend PersistentMap with Associable {
    fn assoc(map, key, value) {
        rust-coll/map-assoc(map, key, value)
    }
}

extend PersistentMap with Keys {
    fn keys(map) {
        rust-coll/map-keys(map)
    }
}

extend PersistentMap with Format {
    fn format(map, depth) {
        let ks = rust-coll/map-keys(map)
        let len = rust-coll/vec-count(ks)
        if len == 0 {
            "{}"
        } else {
            format-rust-map-entries(map, ks, 0, len, "{")
        }
    }
}

fn format-rust-map-entries(map, keys-vec, idx, len, acc) {
    if idx >= len {
        acc ++ "}"
    } else {
        let key = rust-coll/vec-get(keys-vec, idx)
        let val = rust-coll/map-get(map, key)
        let key-str = format(key, 1)
        let val-str = format(val, 1)
        let entry = key-str ++ " " ++ val-str
        let new-acc = if idx == 0 {
            acc ++ entry
        } else {
            acc ++ ", " ++ entry
        }
        format-rust-map-entries(map, keys-vec, idx + 1, len, new-acc)
    }
}

// This may seem weird
// but we need our runtime to know
// how to call a function if it is a closure
// or a regular function
// this makes that idea simple
fn __call_fn(f) { f() }

// Thread struct - holds the closure to be executed and serves as a GC root
// for running threads. The Thread object keeps the closure alive while the
// thread is running.
struct Thread {
    closure
}

// Called by the runtime to start a thread. This function takes no arguments
// and reads the Thread object via a builtin. This ensures GC can properly
// update the stack slot containing the Thread object.
fn __run_thread_start() {
    let thread-obj = primitive/__get-my-thread-obj();
    let f = thread-obj.closure;
    f()
}

// Legacy function - kept for compatibility but no longer used.
fn __run_thread_closure(thread-obj) {
    let f = thread-obj.closure;
    f()
}

struct Atom {
    value
}

/// Dereference an atom to get its current value.
///
/// Atoms provide thread-safe mutable state. Use `deref` to read the value.
///
/// Examples:
///   (let a (atom 0))
///   (deref a)  ; => 0
fn deref(atom) {
    // assert!(atom is Atom)
    primitive/deref(atom)
}

/// Atomically update an atom's value by applying a function.
///
/// Takes the current value, applies f to it, and attempts to set the new value.
/// Retries if another thread changed the value concurrently.
///
/// Examples:
///   (let counter (atom 0))
///   (swap! counter fn(x) { x + 1 })  ; => 1
fn swap!(atom, f) {
    let initial = deref(atom);
    let new = f(initial);
    let result = compare-and-swap!(atom, initial, new);
    if result {
        new
    } else {
        swap!(atom, f)
    }
}

/// Reset an atom to a new value unconditionally.
///
/// Unlike `swap!`, this does not read the current value first.
///
/// Examples:
///   (let a (atom 0))
///   (reset! a 42)
///   (deref a)  ; => 42
fn reset!(atom, value) {
    // assert!(atom is Atom)
    primitive/reset!(atom, value)
}

/// Atomically compare and swap an atom's value.
///
/// If the atom's current value equals `old`, set it to `new` and return true.
/// Otherwise return false without changing the value.
///
/// Examples:
///   (let a (atom 0))
///   (compare-and-swap! a 0 1)  ; => true, a is now 1
///   (compare-and-swap! a 0 2)  ; => false, a is still 1
fn compare-and-swap!(atom, old, new) {
    // assert!(atom is Atom)
    primitive/compare-and-swap!(atom, old, new)
}

/// Create a new atom with the given initial value.
///
/// Atoms provide thread-safe mutable state.
///
/// Examples:
///   (let counter (atom 0))
///   (swap! counter fn(x) { x + 1 })
///   (deref counter)  ; => 1
fn atom(value) {
    // TODO: Allow punning
    Atom { value: value }
}

// TODO: If I move the || on the next line,
// my parser is unhappy
// TODO: Need to make sure type is instance-of Struct
// but how do I do that in a reasonable way?
fn instance-of(value, type) {
    if type.id < 0 {
        // Primitive type - use type-of equality
        equal(type-of(value), type)
    } else {
        // Custom struct - check struct-id
        primitive/is-object(value) && primitive/read-struct-id(value) == type.id
    }
}


extend String with Indexed {
    fn get(str, i) {
        builtin/get-string-index(str, i)
    }
}

extend String with Length {
    fn length(str) {
        builtin/get-string-length(str)
    }
}

// Array protocol extensions for variadic function arguments
// Arrays are raw mutable arrays with type-id = 1
extend Array with Indexed {
    fn get(arr, i) {
        if i < 0 || i >= primitive/size(arr) {
            null
        } else {
            primitive/read-field(arr, i)
        }
    }
}

extend Array with Length {
    fn length(arr) {
        primitive/size(arr)
    }
}

// PersistentVector protocol extensions (Rust-backed vector from literals)
extend PersistentVector with Length {
    fn length(vec) {
        rust-coll/vec-count(vec)
    }
}

extend PersistentVector with Indexed {
    fn get(vec, i) {
        rust-coll/vec-get(vec, i)
    }
}

extend PersistentVector with Push {
    fn push(vec, value) {
        rust-coll/vec-push(vec, value)
    }
}

extend PersistentVector with Seqable {
    fn seq(vec) {
        if rust-coll/vec-count(vec) == 0 {
            null
        } else {
            PersistentVectorSeq { vec: vec, index: 0 }
        }
    }
}

// PersistentMap protocol extensions (Rust-backed map from literals)
extend PersistentMap with Length {
    fn length(m) {
        rust-coll/map-count(m)
    }
}

extend PersistentMap with Indexed {
    fn get(m, key) {
        rust-coll/map-get(m, key)
    }
}

extend PersistentMap with Associable {
    fn assoc(m, key, value) {
        rust-coll/map-assoc(m, key, value)
    }
}

// Sequence type for iterating over PersistentVector
struct PersistentVectorSeq {
    vec
    index
}

extend PersistentVectorSeq with Seq {
    fn first(seq) {
        rust-coll/vec-get(seq.vec, seq.index)
    }

    fn next(seq) {
        let next-index = seq.index + 1
        if next-index >= rust-coll/vec-count(seq.vec) {
            null
        } else {
            PersistentVectorSeq { vec: seq.vec, index: next-index }
        }
    }
}

// Helper for formatting PersistentVector
fn format-persistent-vector-helper(vec, idx, acc, depth) {
    if idx >= rust-coll/vec-count(vec) {
        acc
    } else {
        let elem = rust-coll/vec-get(vec, idx)
        let elem-str = format(elem, depth + 1)
        let new-acc = if idx == 0 {
            acc ++ elem-str
        } else {
            acc ++ ", " ++ elem-str
        }
        format-persistent-vector-helper(vec, idx + 1, new-acc, depth)
    }
}

extend PersistentVector with Format {
    fn format(self, depth) {
        "[" ++ format-persistent-vector-helper(self, 0, "", depth) ++ "]"
    }
}

// ============================================================================
// String Operations (Protocol-based)
// ============================================================================

/// Join elements of a collection into a string with a separator.
///
/// Works with any collection that implements Indexed and Length protocols.
///
/// Examples:
///   (join [1 2 3] ", ")  ; => "1, 2, 3"
///   (join ["a" "b"] "-") ; => "a-b"
fn join(coll, sep) {
    join-helper(coll, sep, 0, "")
}

fn join-helper(coll, sep, idx, acc) {
    let len = length(coll)
    if idx >= len {
        acc
    } else {
        let elem = get(coll, idx)
        let elem-str = to-string(elem)
        let new-acc = if idx == 0 {
            acc ++ elem-str
        } else {
            acc ++ sep ++ elem-str
        }
        join-helper(coll, sep, idx + 1, new-acc)
    }
}

/// Parse a string into an integer.
///
/// Returns null if the string is not a valid integer.
/// Supports negative numbers with leading '-'.
///
/// Examples:
///   (parse-int "42")   ; => 42
///   (parse-int "-5")   ; => -5
///   (parse-int "abc")  ; => null
fn parse-int(s) {
    let len = length(s)
    if len == 0 {
        null
    } else {
        // Check for negative sign
        let first-char = get(s, 0)
        let first-code = builtin/char-code(first-char)
        if first-code == 45 {
            // '-' sign
            if len == 1 {
                null
            } else {
                let result = parse-int-helper(s, 1, 0)
                if result == null {
                    null
                } else {
                    0 - result
                }
            }
        } else {
            parse-int-helper(s, 0, 0)
        }
    }
}

fn parse-int-helper(s, idx, acc) {
    if idx >= length(s) {
        acc
    } else {
        let c = get(s, idx)
        let code = builtin/char-code(c)
        // '0' is 48, '9' is 57
        if code >= 48 && code <= 57 {
            let digit = code - 48
            parse-int-helper(s, idx + 1, acc * 10 + digit)
        } else {
            null
        }
    }
}

// // TODO: Need a way to re-export rather than wrap
// fn push(coll, value) {
//     persistent-vector/push(coll, value)
// }

// ============================================================================
// Writer Protocol for Stdout Rebinding
// ============================================================================

// Writer protocol - anything that can receive output
protocol Writer {
    fn write(self, s)
}

// Default stdout writer struct
struct Stdout {}

// Stdout implementation - calls builtin printer directly
extend Stdout with Writer {
    fn write(self, s) {
        _print(s)
        null
    }
}

// StringBuffer - mutable accumulator for captured output
// With cons strings, each write() is O(1) concatenation.
struct StringBuffer {
    mut content
}

// Factory function to create a new StringBuffer
fn new-string-buffer() {
    StringBuffer {
        content: ""
    }
}

// StringBuffer implementation - concatenates to content string
extend StringBuffer with Writer {
    fn write(self, s) {
        self.content = self.content ++ s
        null
    }
}

// Define *out* dynamic var, default to stdout
let dynamic out = Stdout {}

// ============================================================================

/// Print arguments separated by spaces without a trailing newline.
///
/// Accepts any number of arguments. Each is formatted and printed.
/// Returns the last argument.
///
/// Examples:
///   (print "Hello" "World")  ; prints: Hello World
fn print(...args) {
    let len = length(args)
    if len == 0 {
        null
    } else {
        let mut last = null
        let mut i = 0
        while i < len {
            if i > 0 {
                write(out, " ")
            }
            last = get(args, i)
            write(out, format(last, 0))
            i = i + 1
        }
        last
    }
}

/// Print arguments separated by spaces with a trailing newline.
///
/// Accepts any number of arguments. Each is formatted and printed.
/// Returns the last argument.
///
/// Examples:
///   (println "Hello" "World")  ; prints: Hello World\n
///   (println 1 2 3)            ; prints: 1 2 3\n
fn println(...args) {
    let len = length(args)
    if len == 0 {
        write(out, "\n")
        null
    } else {
        let mut last = null
        let mut i = 0
        while i < len {
            if i > 0 {
                write(out, " ")
            }
            last = get(args, i)
            write(out, format(last, 0))
            i = i + 1
        }
        write(out, "\n")
        last
    }
}

/// Check if a value is a keyword.
///
/// Examples:
///   (keyword? :foo)  ; => true
///   (keyword? "foo") ; => false
fn keyword?(value) {
    builtin/is-keyword(value)
}

/// Convert a keyword to a string.
///
/// Examples:
///   (keyword->string :foo)  ; => "foo"
fn keyword->string(kw) {
    builtin/keyword-to-string(kw)
}

/// Convert a string to a keyword.
///
/// Examples:
///   (string->keyword "foo")  ; => :foo
fn string->keyword(str) {
    builtin/string-to-keyword(str)
}


struct __Box__ {
    value
}

// System error enum for exception handling
enum SystemError {
    StructError { message, location }
    ParseError { message, location }
    CompileError { message, location }
    TypeError { message, location }
    ArityError { message, location }
    RuntimeError { message, location }
    ThreadError { message, location }
    FFIError { message, location }
    FunctionError { message, location }
    FieldError { message, location }
    IndexError { message, location }
    MutabilityError { message, location }
    JsonError { message, location }
    AssertError { message, location }
}

// Diagnostic severity levels
enum DiagnosticSeverity {
    error,
    warning,
    info,
    hint,
}

// Diagnostic information for programmatic inspection
// Returned by (diagnostics), (diagnostics-for-file path), etc.
struct Diagnostic {
    severity         // DiagnosticSeverity enum variant
    kind             // String: diagnostic type identifier (e.g., "NonExhaustiveMatch")
    file-name        // String: source file path
    line             // Int: 1-based line number
    column           // Int: 1-based column number
    message          // String: human-readable description
    enum-name        // String or null: for NonExhaustiveMatch diagnostics
    missing-variants // [String] or null: for NonExhaustiveMatch diagnostics
}

// Range type for iteration
struct Range {
    current
    end
    step
}

/// Create a range from start (inclusive) to end (exclusive).
///
/// Ranges are iterable and can be used with for loops and seq functions.
///
/// Examples:
///   (for i in (range 0 5) { println(i) })  ; prints 0, 1, 2, 3, 4
///   (reduce (range 1 5) 0 fn(a x) { a + x })  ; => 10
fn range(start, end) {
    Range { current: start, end: end, step: 1 }
}

/// Create a range with a custom step value.
///
/// Examples:
///   (range-step 0 10 2)  ; => 0, 2, 4, 6, 8
fn range-step(start, end, step) {
    Range { current: start, end: end, step: step }
}

extend Range with Seqable {
    fn seq(r) {
        if r.current >= r.end {
            null
        } else {
            r
        }
    }
}

extend Range with Seq {
    fn first(r) {
        r.current
    }

    fn next(r) {
        let next-val = r.current + r.step
        if next-val >= r.end {
            null
        } else {
            Range { current: next-val, end: r.end, step: r.step }
        }
    }
}

// String sequence for iteration
struct StringSeq {
    str
    index
}

extend String with Seqable {
    fn seq(str) {
        if length(str) == 0 {
            null
        } else {
            StringSeq { str: str, index: 0 }
        }
    }
}

extend StringSeq with Seq {
    fn first(seq) {
        get(seq.str, seq.index)
    }

    fn next(seq) {
        let next-index = seq.index + 1
        if next-index >= length(seq.str) {
            null
        } else {
            StringSeq { str: seq.str, index: next-index }
        }
    }
}

// ============================================================================
// Higher-Order Collection Functions
// ============================================================================

/// Fold a collection with an accumulator function.
///
/// Calls (f acc elem) for each element, threading the accumulator through.
/// Works with any Seqable type.
///
/// Examples:
///   (reduce [1 2 3] 0 fn(acc x) { acc + x })  ; => 6
///   (reduce [1 2 3] [] fn(acc x) { push acc (* x 2) })  ; => [2 4 6]
fn reduce(coll, init, f) {
    let mut s = seq(coll)
    let mut acc = init
    while s != null {
        let elem = first(s)
        acc = f(acc, elem)
        s = next(s)
    }
    acc
}

/// Apply a function to each element of a collection.
///
/// Returns a new vector with the transformed elements.
///
/// Examples:
///   (map [1 2 3] fn(x) { x * 2 })  ; => [2 4 6]
///   (map ["a" "b"] uppercase)      ; => ["A" "B"]
fn map(coll, f) {
    let mut s = seq(coll)
    let mut acc = []
    while s != null {
        let elem = first(s)
        acc = push(acc, f(elem))
        s = next(s)
    }
    acc
}

/// Keep elements where the predicate returns true.
///
/// Returns a new vector containing only matching elements.
///
/// Examples:
///   (filter [1 2 3 4] even?)  ; => [2 4]
///   (filter ["" "a" ""] fn(s) { length(s) > 0 })  ; => ["a"]
fn filter(coll, pred) {
    let mut s = seq(coll)
    let mut acc = []
    while s != null {
        let elem = first(s)
        if pred(elem) {
            acc = push(acc, elem)
        }
        s = next(s)
    }
    acc
}

/// Check if any element matches the predicate.
///
/// Returns true if pred returns true for at least one element.
///
/// Examples:
///   (any? [1 2 3] even?)  ; => true
///   (any? [1 3 5] even?)  ; => false
fn any?(coll, pred) {
    let mut s = seq(coll)
    let mut found = false
    while s != null && found == false {
        if pred(first(s)) {
            found = true
        }
        s = next(s)
    }
    found
}

/// Check if all elements match the predicate.
///
/// Returns true if pred returns true for every element.
///
/// Examples:
///   (all? [2 4 6] even?)  ; => true
///   (all? [1 2 3] even?)  ; => false
fn all?(coll, pred) {
    let mut s = seq(coll)
    let mut all-match = true
    while s != null && all-match {
        if pred(first(s)) == false {
            all-match = false
        }
        s = next(s)
    }
    all-match
}

/// Check if no elements match the predicate.
///
/// Returns true if pred returns false for every element.
///
/// Examples:
///   (none? [1 3 5] even?)  ; => true
///   (none? [1 2 3] even?)  ; => false
fn none?(coll, pred) {
    let mut s = seq(coll)
    let mut none-match = true
    while s != null && none-match {
        if pred(first(s)) {
            none-match = false
        }
        s = next(s)
    }
    none-match
}

/// Check if at least one element does NOT match the predicate.
///
/// Equivalent to (not (all? coll pred)).
///
/// Examples:
///   (not-every? [1 2 3] even?)  ; => true
///   (not-every? [2 4 6] even?)  ; => false
fn not-every?(coll, pred) {
    not(all?(coll, pred))
}

/// Find the first element matching the predicate.
///
/// Returns the element or null if no match.
///
/// Examples:
///   (find [1 2 3 4] even?)  ; => 2
///   (find [1 3 5] even?)    ; => null
fn find(coll, pred) {
    let mut s = seq(coll)
    let mut result = null
    let mut found = false
    while s != null && found == false {
        let elem = first(s)
        if pred(elem) {
            result = elem
            found = true
        }
        s = next(s)
    }
    result
}

/// Find the index of the first element matching the predicate.
///
/// Returns the index or -1 if no match.
///
/// Examples:
///   (find-index [1 2 3 4] even?)  ; => 1
///   (find-index [1 3 5] even?)    ; => -1
fn find-index(coll, pred) {
    let mut s = seq(coll)
    let mut idx = 0
    let mut result = -1
    let mut found = false
    while s != null && found == false {
        if pred(first(s)) {
            result = idx
            found = true
        }
        s = next(s)
        idx = idx + 1
    }
    result
}

/// Take the first n elements from a collection.
///
/// Returns a new vector with at most n elements.
///
/// Examples:
///   (take [1 2 3 4 5] 3)  ; => [1 2 3]
///   (take [1 2] 5)        ; => [1 2]
fn take(coll, n) {
    let mut s = seq(coll)
    let mut remaining = n
    let mut acc = []
    while s != null && remaining > 0 {
        acc = push(acc, first(s))
        s = next(s)
        remaining = remaining - 1
    }
    acc
}

/// Drop the first n elements from a collection.
///
/// Returns a new vector with the remaining elements.
///
/// Examples:
///   (drop [1 2 3 4 5] 2)  ; => [3 4 5]
///   (drop [1 2] 5)        ; => []
fn drop(coll, n) {
    let mut s = seq(coll)
    let mut remaining = n
    while s != null && remaining > 0 {
        s = next(s)
        remaining = remaining - 1
    }
    let mut acc = []
    while s != null {
        acc = push(acc, first(s))
        s = next(s)
    }
    acc
}

/// Take elements while the predicate returns true.
///
/// Stops at the first element where pred returns false.
///
/// Examples:
///   (take-while [1 2 3 4 1] fn(x) { x < 4 })  ; => [1 2 3]
fn take-while(coll, pred) {
    let mut s = seq(coll)
    let mut acc = []
    let mut taking = true
    while s != null && taking {
        let elem = first(s)
        if pred(elem) {
            acc = push(acc, elem)
            s = next(s)
        } else {
            taking = false
        }
    }
    acc
}

/// Drop elements while the predicate returns true.
///
/// Returns elements starting from the first where pred returns false.
///
/// Examples:
///   (drop-while [1 2 3 4 1] fn(x) { x < 3 })  ; => [3 4 1]
fn drop-while(coll, pred) {
    let mut s = seq(coll)
    while s != null && pred(first(s)) {
        s = next(s)
    }
    let mut acc = []
    while s != null {
        acc = push(acc, first(s))
        s = next(s)
    }
    acc
}

/// Get a sub-collection from start (inclusive) to end (exclusive).
///
/// Examples:
///   (slice [0 1 2 3 4] 1 4)  ; => [1 2 3]
fn slice(coll, start, end) {
    take(drop(coll, start), end - start)
}

/// Return pairs of [index, element] for each element.
///
/// Examples:
///   (enumerate ["a" "b" "c"])  ; => [[0 "a"] [1 "b"] [2 "c"]]
fn enumerate(coll) {
    let mut s = seq(coll)
    let mut idx = 0
    let mut acc = []
    while s != null {
        acc = push(acc, [idx, first(s)])
        s = next(s)
        idx = idx + 1
    }
    acc
}

/// Remove element at the specified index.
///
/// Returns the collection unchanged if index is out of bounds.
///
/// Examples:
///   (remove-at [1 2 3 4] 1)  ; => [1 3 4]
fn remove-at(coll, idx) {
    let len = length(coll)
    if idx < 0 || idx >= len {
        coll
    } else {
        concat(take(coll, idx), drop(coll, idx + 1))
    }
}

// ============================================================================
// Element Access Functions
// ============================================================================

/// Return the number of elements in a collection.
///
/// Alias for length, more idiomatic for collections.
///
/// Examples:
///   (count [1 2 3])  ; => 3
///   (count "hello")  ; => 5
fn count(coll) {
    length(coll)
}

/// Check if a collection has no elements.
///
/// Examples:
///   (empty? [])    ; => true
///   (empty? [1])   ; => false
///   (empty? "")    ; => true
fn empty?(coll) {
    length(coll) == 0
}

/// Get the first element of a collection.
///
/// Returns null if the collection is empty.
/// Named differently to avoid conflict with Seq protocol's first.
///
/// Examples:
///   (first-of [1 2 3])  ; => 1
///   (first-of [])       ; => null
fn first-of(coll) {
    let s = seq(coll)
    if s == null {
        null
    } else {
        first(s)
    }
}

/// Get the last element of a collection.
///
/// Returns null if the collection is empty.
///
/// Examples:
///   (last [1 2 3])  ; => 3
///   (last [])       ; => null
fn last(coll) {
    let mut s = seq(coll)
    let mut prev = null
    while s != null {
        prev = first(s)
        s = next(s)
    }
    prev
}

/// Get all elements except the first.
///
/// Examples:
///   (rest [1 2 3])  ; => [2 3]
///   (rest [1])      ; => []
fn rest(coll) {
    drop(coll, 1)
}

/// Get all elements except the last one.
///
/// Examples:
///   (butlast [1 2 3])  ; => [1 2]
///   (butlast [1])      ; => []
fn butlast(coll) {
    let len = length(coll)
    if len <= 1 {
        []
    } else {
        take(coll, len - 1)
    }
}

/// Get the element at index n with bounds checking.
///
/// Returns null if index is out of bounds.
///
/// Examples:
///   (nth [1 2 3] 1)   ; => 2
///   (nth [1 2 3] 10)  ; => null
fn nth(coll, n) {
    get(coll, n)
}

/// Get the second element of a collection.
///
/// Examples:
///   (second [1 2 3])  ; => 2
fn second(coll) {
    nth(coll, 1)
}

/// Get the third element of a collection.
///
/// Examples:
///   (third [1 2 3])  ; => 3
fn third(coll) {
    nth(coll, 2)
}

// ============================================================================
// Min/Max Functions
// ============================================================================

/// Return the minimum element in a collection.
///
/// Elements must be comparable with <.
///
/// Examples:
///   (min-of [3 1 4 1 5])  ; => 1
///   (min-of [])           ; => null
fn min-of(coll) {
    let mut s = seq(coll)
    if s == null {
        null
    } else {
        let mut min-val = first(s)
        s = next(s)
        while s != null {
            let elem = first(s)
            if elem < min-val {
                min-val = elem
            }
            s = next(s)
        }
        min-val
    }
}

/// Return the maximum element in a collection.
///
/// Elements must be comparable with >.
///
/// Examples:
///   (max-of [3 1 4 1 5])  ; => 5
///   (max-of [])           ; => null
fn max-of(coll) {
    let mut s = seq(coll)
    if s == null {
        null
    } else {
        let mut max-val = first(s)
        s = next(s)
        while s != null {
            let elem = first(s)
            if elem > max-val {
                max-val = elem
            }
            s = next(s)
        }
        max-val
    }
}

/// Return the element with the minimum key value.
///
/// Compares elements by applying f to each and using < on the results.
///
/// Examples:
///   (min-by ["abc" "a" "ab"] length)  ; => "a"
fn min-by(coll, f) {
    let mut s = seq(coll)
    if s == null {
        null
    } else {
        let mut min-elem = first(s)
        let mut min-val = f(min-elem)
        s = next(s)
        while s != null {
            let elem = first(s)
            let val = f(elem)
            if val < min-val {
                min-elem = elem
                min-val = val
            }
            s = next(s)
        }
        min-elem
    }
}

/// Return the element with the maximum key value.
///
/// Compares elements by applying f to each and using > on the results.
///
/// Examples:
///   (max-by ["a" "abc" "ab"] length)  ; => "abc"
fn max-by(coll, f) {
    let mut s = seq(coll)
    if s == null {
        null
    } else {
        let mut max-elem = first(s)
        let mut max-val = f(max-elem)
        s = next(s)
        while s != null {
            let elem = first(s)
            let val = f(elem)
            if val > max-val {
                max-elem = elem
                max-val = val
            }
            s = next(s)
        }
        max-elem
    }
}

/// Reduce a collection from right to left.
///
/// Like reduce, but processes elements in reverse order.
///
/// Examples:
///   (reduce-right [1 2 3] [] fn(acc x) { push(acc, x) })  ; => [3 2 1]
fn reduce-right(coll, init, f) {
    // Convert to vector and iterate backwards
    let v = if instance-of(coll, PersistentVector) {
        coll
    } else {
        reduce(coll, [], fn(acc, x) { push(acc, x) })
    }
    let len = length(v)
    let mut acc = init
    let mut i = len - 1
    while i >= 0 {
        acc = f(acc, get(v, i))
        i = i - 1
    }
    acc
}

// ============================================================================
// Combining Functions
// ============================================================================

/// Concatenate two collections into one.
///
/// Returns a new vector with elements from both collections.
///
/// Examples:
///   (concat [1 2] [3 4])  ; => [1 2 3 4]
fn concat(coll1, coll2) {
    let mut acc = []
    let mut s = seq(coll1)
    while s != null {
        acc = push(acc, first(s))
        s = next(s)
    }
    s = seq(coll2)
    while s != null {
        acc = push(acc, first(s))
        s = next(s)
    }
    acc
}

/// Flatten one level of nesting in a collection.
///
/// Examples:
///   (flatten [[1 2] [3 4]])  ; => [1 2 3 4]
fn flatten(coll) {
    let mut s = seq(coll)
    let mut acc = []
    while s != null {
        let elem = first(s)
        acc = reduce(elem, acc, fn(a, x) { push(a, x) })
        s = next(s)
    }
    acc
}

/// Map a function over a collection then flatten the result.
///
/// Examples:
///   (flat-map [1 2 3] fn(x) { [x, x] })  ; => [1 1 2 2 3 3]
fn flat-map(coll, f) {
    flatten(map(coll, f))
}

/// Pair up elements from two collections into a vector of pairs.
///
/// Examples:
///   (zip [1 2 3] ["a" "b" "c"])  ; => [[1 "a"] [2 "b"] [3 "c"]]
fn zip(coll1, coll2) {
    let mut s1 = seq(coll1)
    let mut s2 = seq(coll2)
    let mut acc = []
    while s1 != null && s2 != null {
        acc = push(acc, [first(s1), first(s2)])
        s1 = next(s1)
        s2 = next(s2)
    }
    acc
}

/// Combine elements from two collections using a function.
///
/// Like zip, but applies f to each pair instead of creating tuples.
///
/// Examples:
///   (zip-with [1 2 3] [10 20 30] fn(a b) { a + b })  ; => [11 22 33]
fn zip-with(coll1, coll2, f) {
    let mut s1 = seq(coll1)
    let mut s2 = seq(coll2)
    let mut acc = []
    while s1 != null && s2 != null {
        acc = push(acc, f(first(s1), first(s2)))
        s1 = next(s1)
        s2 = next(s2)
    }
    acc
}

/// Create a map from parallel key and value collections.
///
/// Pairs up keys[i] with vals[i] to form map entries.
///
/// Examples:
///   (zipmap [:a :b :c] [1 2 3])  ; => {:a 1, :b 2, :c 3}
fn zipmap(keys-coll, vals-coll) {
    let mut ks = seq(keys-coll)
    let mut vs = seq(vals-coll)
    let mut acc = {}
    while ks != null && vs != null {
        acc = assoc(acc, first(ks), first(vs))
        ks = next(ks)
        vs = next(vs)
    }
    acc
}

/// Interleave elements from two collections.
///
/// Returns a vector alternating between elements of coll1 and coll2.
///
/// Examples:
///   (interleave [1 2 3] [:a :b :c])  ; => [1 :a 2 :b 3 :c]
fn interleave(coll1, coll2) {
    let mut s1 = seq(coll1)
    let mut s2 = seq(coll2)
    let mut acc = []
    while s1 != null && s2 != null {
        acc = push(acc, first(s1))
        acc = push(acc, first(s2))
        s1 = next(s1)
        s2 = next(s2)
    }
    acc
}

/// Insert a separator between each element of a collection.
///
/// Examples:
///   (interpose [1 2 3] 0)  ; => [1 0 2 0 3]
fn interpose(coll, sep) {
    let mut s = seq(coll)
    let mut acc = []
    let mut is-first = true
    while s != null {
        if is-first {
            acc = push(acc, first(s))
            is-first = false
        } else {
            acc = push(acc, sep)
            acc = push(acc, first(s))
        }
        s = next(s)
    }
    acc
}

// ============================================================================
// Collection Creation & Transformation
// ============================================================================

/// Pour elements from source collection into target collection.
///
/// For vectors: appends elements. For maps: source should be [key, value] pairs.
/// For sets: adds elements.
///
/// Examples:
///   (into [1 2] [3 4])          ; => [1 2 3 4]
///   (into {} [[:a 1] [:b 2]])   ; => {:a 1, :b 2}
///   (into #{1 2} [2 3 4])       ; => #{1 2 3 4}
fn into(target, source) {
    if set?(target) {
        reduce(source, target, fn(acc, elem) { set-add(acc, elem) })
    } else {
        if instance-of(target, PersistentMap) {
            // Source elements should be [key, value] pairs
            reduce(source, target, fn(acc, pair) {
                assoc(acc, get(pair, 0), get(pair, 1))
            })
        } else {
            // Assume vector-like target
            reduce(source, target, fn(acc, elem) { push(acc, elem) })
        }
    }
}

/// Reverse the order of elements in a collection.
///
/// Returns a new vector with elements in reverse order.
///
/// Examples:
///   (reverse [1 2 3])  ; => [3 2 1]
fn reverse(coll) {
    reduce(coll, [], fn(acc, x) {
        // Build reversed by prepending - but since we only have push,
        // we reduce to a list and then build a new vector
        // Actually, simpler: just collect in reverse order
        concat([x], acc)
    })
}

/// Create a vector with a value repeated n times.
///
/// Examples:
///   (repeat "x" 3)  ; => ["x" "x" "x"]
fn repeat(value, n) {
    let mut remaining = n
    let mut acc = []
    while remaining > 0 {
        acc = push(acc, value)
        remaining = remaining - 1
    }
    acc
}

/// Call a function n times and collect the results.
///
/// Examples:
///   (repeatedly fn() { random() } 3)  ; => [0.1 0.7 0.4] (random values)
fn repeatedly(f, n) {
    let mut remaining = n
    let mut acc = []
    while remaining > 0 {
        acc = push(acc, f())
        remaining = remaining - 1
    }
    acc
}

/// Generate a sequence by repeatedly applying a function.
///
/// Starts with init, then f(init), f(f(init)), etc. for n values.
///
/// Examples:
///   (iterate fn(x) { x * 2 } 1 5)  ; => [1 2 4 8 16]
fn iterate(f, init, n) {
    let mut remaining = n
    let mut current = init
    let mut acc = []
    while remaining > 0 {
        acc = push(acc, current)
        current = f(current)
        remaining = remaining - 1
    }
    acc
}

/// Split a collection into groups of n elements.
///
/// Examples:
///   (partition [1 2 3 4 5 6] 2)  ; => [[1 2] [3 4] [5 6]]
fn partition(coll, n) {
    let mut remaining = coll
    let mut acc = []
    while empty?(remaining) == false {
        let chunk = take(remaining, n)
        remaining = drop(remaining, n)
        acc = push(acc, chunk)
    }
    acc
}

/// Split a collection when the key function's return value changes.
///
/// Groups consecutive elements with the same key value.
///
/// Examples:
///   (partition-by [1 1 2 2 1] identity)  ; => [[1 1] [2 2] [1]]
fn partition-by(coll, f) {
    let mut s = seq(coll)
    if s == null {
        []
    } else {
        let mut acc = []
        let mut current-group = []
        let mut current-key = f(first(s))
        while s != null {
            let elem = first(s)
            let key = f(elem)
            if key == current-key {
                current-group = push(current-group, elem)
            } else {
                acc = push(acc, current-group)
                current-group = [elem]
                current-key = key
            }
            s = next(s)
        }
        // Don't forget the last group
        push(acc, current-group)
    }
}

/// Group elements by the result of a key function.
///
/// Returns a map from keys to vectors of elements with that key.
///
/// Examples:
///   (group-by [1 2 3 4 5] even?)  ; => {true: [2 4], false: [1 3 5]}
fn group-by(coll, f) {
    let mut s = seq(coll)
    let mut groups = {}
    while s != null {
        let elem = first(s)
        let key = f(elem)
        let existing = get(groups, key)
        let updated = if existing == null {
            [elem]
        } else {
            push(existing, elem)
        }
        groups = assoc(groups, key, updated)
        s = next(s)
    }
    groups
}

/// Count occurrences of each value in a collection.
///
/// Returns a map from values to their counts.
///
/// Examples:
///   (frequencies [1 2 1 3 1 2])  ; => {1: 3, 2: 2, 3: 1}
fn frequencies(coll) {
    let mut s = seq(coll)
    let mut counts = {}
    while s != null {
        let elem = first(s)
        let current = get(counts, elem)
        let new-count = if current == null {
            1
        } else {
            current + 1
        }
        counts = assoc(counts, elem, new-count)
        s = next(s)
    }
    counts
}

/// Remove duplicate values from a collection.
///
/// Keeps the first occurrence of each value.
///
/// Examples:
///   (distinct [1 2 1 3 2 1])  ; => [1 2 3]
fn distinct(coll) {
    let mut s = seq(coll)
    let mut seen = {}
    let mut acc = []
    while s != null {
        let elem = first(s)
        let already-seen = get(seen, elem)
        if already-seen == null {
            seen = assoc(seen, elem, true)
            acc = push(acc, elem)
        }
        s = next(s)
    }
    acc
}

/// Remove consecutive duplicate elements.
///
/// Keeps the first occurrence of each run of duplicates.
///
/// Examples:
///   (dedupe [1 1 2 2 2 1 1])  ; => [1 2 1]
fn dedupe(coll) {
    let mut s = seq(coll)
    if s == null {
        []
    } else {
        let mut acc = [first(s)]
        let mut prev = first(s)
        s = next(s)
        while s != null {
            let elem = first(s)
            if elem != prev {
                acc = push(acc, elem)
                prev = elem
            }
            s = next(s)
        }
        acc
    }
}

// ============================================================================
// Sorting Functions
// ============================================================================

// Helper: insert elem into sorted vector at correct position
fn insert-sorted(sorted, elem) {
    let mut s = seq(sorted)
    let mut before = []
    let mut inserted = false
    let mut result = []

    while s != null && inserted == false {
        let current = first(s)
        if elem < current {
            // Insert elem here, then add rest
            result = concat(before, [elem])
            // Add remaining elements
            while s != null {
                result = push(result, first(s))
                s = next(s)
            }
            inserted = true
        } else {
            before = push(before, current)
            s = next(s)
        }
    }

    if inserted == false {
        // elem is largest, append at end
        result = push(before, elem)
    }

    result
}

/// Sort a collection in ascending order.
///
/// Elements must be comparable. Uses insertion sort.
///
/// Examples:
///   (sort [3 1 4 1 5])  ; => [1 1 3 4 5]
fn sort(coll) {
    let mut s = seq(coll)
    let mut sorted = []
    while s != null {
        let elem = first(s)
        sorted = insert-sorted(sorted, elem)
        s = next(s)
    }
    sorted
}

// Helper: insert elem into sorted vector by key at correct position
fn insert-sorted-by(sorted, elem, elem-key, key-fn) {
    let mut s = seq(sorted)
    let mut before = []
    let mut inserted = false
    let mut result = []

    while s != null && inserted == false {
        let current = first(s)
        let current-key = key-fn(current)
        if elem-key < current-key {
            // Insert elem here, then add rest
            result = concat(before, [elem])
            // Add remaining elements
            while s != null {
                result = push(result, first(s))
                s = next(s)
            }
            inserted = true
        } else {
            before = push(before, current)
            s = next(s)
        }
    }

    if inserted == false {
        // elem is largest, append at end
        result = push(before, elem)
    }

    result
}

/// Sort a collection by a key function.
///
/// Elements are ordered by comparing (f elem) values.
///
/// Examples:
///   (sort-by [{:name "bob" :age 30} {:name "alice" :age 25}] fn(x) { x.age })
///   ; => [{:name "alice" :age 25} {:name "bob" :age 30}]
fn sort-by(coll, f) {
    let mut s = seq(coll)
    let mut sorted = []
    while s != null {
        let elem = first(s)
        let elem-key = f(elem)
        sorted = insert-sorted-by(sorted, elem, elem-key, f)
        s = next(s)
    }
    sorted
}

// ============================================================================
// Function Utilities
// ============================================================================

/// Return the input unchanged.
///
/// Useful as a default function argument.
///
/// Examples:
///   (identity 42)  ; => 42
///   (map [1 2 3] identity)  ; => [1 2 3]
fn identity(x) {
    x
}

/// Return a function that always returns the given value.
///
/// Ignores any arguments passed to the returned function.
///
/// Examples:
///   (let always-42 (constantly 42))
///   (always-42 "ignored")  ; => 42
fn constantly(value) {
    fn(ignored) { value }
}

/// Return a function that negates a predicate.
///
/// Examples:
///   (let not-even? (complement even?))
///   (not-even? 3)  ; => true
fn complement(pred) {
    fn(x) { not(pred(x)) }
}

/// Compose two functions: (compose f g) returns fn(x) { f(g(x)) }.
///
/// The second function is applied first, then the first.
///
/// Examples:
///   (let add1-then-double (compose fn(x) { x * 2 } fn(x) { x + 1 }))
///   (add1-then-double 3)  ; => 8  (3+1=4, 4*2=8)
fn compose(f, g) {
    fn(x) { f(g(x)) }
}

/// Partially apply a function by fixing its first argument.
///
/// Examples:
///   (let add10 (partial fn(a b) { a + b } 10))
///   (add10 5)  ; => 15
fn partial(f, a) {
    fn(b) { f(a, b) }
}

// ============================================================================
// Boolean/Logic Utilities
// ============================================================================

/// Boolean negation.
///
/// Returns true if x is falsy, false if x is truthy.
///
/// Examples:
///   (not true)   ; => false
///   (not false)  ; => true
///   (not null)   ; => true
fn not(x) {
    if x {
        false
    } else {
        true
    }
}

/// Check if a value is truthy (not null and not false).
///
/// Examples:
///   (truthy? 1)      ; => true
///   (truthy? null)   ; => false
///   (truthy? false)  ; => false
fn truthy?(x) {
    x != null && x != false
}

/// Check if a value is falsy (null or false).
///
/// Examples:
///   (falsy? null)   ; => true
///   (falsy? false)  ; => true
///   (falsy? 0)      ; => false
fn falsy?(x) {
    x == null || x == false
}

// ============================================================================
// Type Checking Predicates
// ============================================================================

/// Check if a value is null.
///
/// Examples:
///   (nil? null)  ; => true
///   (nil? 0)     ; => false
fn nil?(x) {
    x == null
}

/// Check if a value is not null.
///
/// Examples:
///   (some? 0)     ; => true
///   (some? null)  ; => false
fn some?(x) {
    x != null
}

// ============================================================================
// Map Utilities
// ============================================================================

/// Get all values from a map as a vector.
///
/// Examples:
///   (vals {:a 1 :b 2})  ; => [1 2]
fn vals(m) {
    let ks = keys(m)
    map(ks, fn(k) { get(m, k) })
}

/// Remove a key from a map.
///
/// Returns a new map without the specified key.
///
/// Examples:
///   (dissoc {:a 1 :b 2} :a)  ; => {:b 2}
fn dissoc(m, key) {
    let ks = keys(m)
    let filtered-keys = filter(ks, fn(k) { k != key })
    reduce(filtered-keys, {}, fn(acc, k) { assoc(acc, k, get(m, k)) })
}

/// Merge two maps together.
///
/// m2's values take precedence for duplicate keys.
///
/// Examples:
///   (merge {:a 1 :b 2} {:b 3 :c 4})  ; => {:a 1 :b 3 :c 4}
fn merge(m1, m2) {
    let ks = keys(m2)
    reduce(ks, m1, fn(acc, k) { assoc(acc, k, get(m2, k)) })
}

/// Merge two maps using a function to resolve key conflicts.
///
/// When a key exists in both maps, calls f(v1, v2) to get the merged value.
///
/// Examples:
///   (merge-with fn(a b) { a + b } {:a 1} {:a 2 :b 3})  ; => {:a 3, :b 3}
fn merge-with(f, m1, m2) {
    merge-with-helper(f, m1, m2, keys(m2), 0, m1)
}

fn merge-with-helper(f, m1, m2, ks, idx, acc) {
    if idx >= length(ks) {
        acc
    } else {
        let k = get(ks, idx)
        let v2 = get(m2, k)
        let v1 = get(m1, k)
        let new-acc = if v1 == null {
            assoc(acc, k, v2)
        } else {
            assoc(acc, k, f(v1, v2))
        }
        merge-with-helper(f, m1, m2, ks, idx + 1, new-acc)
    }
}

/// Keep only the specified keys from a map.
///
/// Returns a new map with only the keys in ks.
///
/// Examples:
///   (select-keys {:a 1 :b 2 :c 3} [:a :c])  ; => {:a 1, :c 3}
fn select-keys(m, ks) {
    select-keys-helper(m, ks, 0, {})
}

fn select-keys-helper(m, ks, idx, acc) {
    if idx >= length(ks) {
        acc
    } else {
        let k = get(ks, idx)
        let v = get(m, k)
        let new-acc = if v == null {
            acc
        } else {
            assoc(acc, k, v)
        }
        select-keys-helper(m, ks, idx + 1, new-acc)
    }
}

/// Update a value at a key using a function.
///
/// Applies f to the current value at key and associates the result.
///
/// Examples:
///   (update {:a 1} :a fn(x) { x + 1 })  ; => {:a 2}
fn update(m, key, f) {
    let old-val = get(m, key)
    assoc(m, key, f(old-val))
}

/// Get a nested value using a path of keys.
///
/// Returns null if any key in the path is not found.
///
/// Examples:
///   (get-in {:a {:b {:c 42}}} [:a :b :c])  ; => 42
///   (get-in {:a {:b 1}} [:a :x])           ; => null
fn get-in(m, path) {
    let mut current = m
    let mut s = seq(path)
    while s != null && current != null {
        let k = first(s)
        current = get(current, k)
        s = next(s)
    }
    current
}

/// Set a nested value using a path of keys.
///
/// Creates intermediate maps as needed.
///
/// Examples:
///   (assoc-in {:a {:b 1}} [:a :b] 42)  ; => {:a {:b 42}}
///   (assoc-in {} [:a :b :c] 1)         ; => {:a {:b {:c 1}}}
fn assoc-in(m, path, val) {
    let len = length(path)
    if len == 0 {
        m
    } else {
        if len == 1 {
            assoc(m, get(path, 0), val)
        } else {
            let k = get(path, 0)
            let rest-path = rest(path)
            let nested = get(m, k)
            let new-nested = if nested == null {
                assoc-in({}, rest-path, val)
            } else {
                assoc-in(nested, rest-path, val)
            }
            assoc(m, k, new-nested)
        }
    }
}

/// Update a nested value using a path of keys and a function.
///
/// Applies f to the current value at the path.
///
/// Examples:
///   (update-in {:a {:b 1}} [:a :b] fn(x) { x + 1 })  ; => {:a {:b 2}}
fn update-in(m, path, f) {
    let len = length(path)
    if len == 0 {
        m
    } else {
        if len == 1 {
            update(m, get(path, 0), f)
        } else {
            let k = get(path, 0)
            let rest-path = rest(path)
            let nested = get(m, k)
            let new-nested = if nested == null {
                update-in({}, rest-path, f)
            } else {
                update-in(nested, rest-path, f)
            }
            assoc(m, k, new-nested)
        }
    }
}

/// Check if a map contains a key.
///
/// Examples:
///   (contains-key? {:a 1 :b 2} :a)  ; => true
///   (contains-key? {:a 1 :b 2} :c)  ; => false
fn contains-key?(m, key) {
    let ks = keys(m)
    any?(ks, fn(k) { k == key })
}

/// Swap keys and values in a map.
///
/// Values become keys and keys become values.
///
/// Examples:
///   (invert {:a 1 :b 2})  ; => {1: :a, 2: :b}
fn invert(m) {
    let ks = keys(m)
    reduce(ks, {}, fn(acc, k) {
        let v = get(m, k)
        assoc(acc, v, k)
    })
}

/// Apply a function to all keys in a map.
///
/// Returns a new map with transformed keys, same values.
///
/// Examples:
///   (map-keys {:a 1 :b 2} keyword->string)  ; => {"a": 1, "b": 2}
fn map-keys(m, f) {
    map-keys-helper(m, f, keys(m), 0, {})
}

fn map-keys-helper(m, f, ks, idx, acc) {
    if idx >= length(ks) {
        acc
    } else {
        let k = get(ks, idx)
        let v = get(m, k)
        let new-acc = assoc(acc, f(k), v)
        map-keys-helper(m, f, ks, idx + 1, new-acc)
    }
}

/// Apply a function to all values in a map.
///
/// Returns a new map with same keys, transformed values.
///
/// Examples:
///   (map-vals {:a 1 :b 2} fn(x) { x * 2 })  ; => {:a 2, :b 4}
fn map-vals(m, f) {
    map-vals-helper(m, f, keys(m), 0, {})
}

fn map-vals-helper(m, f, ks, idx, acc) {
    if idx >= length(ks) {
        acc
    } else {
        let k = get(ks, idx)
        let v = get(m, k)
        let new-acc = assoc(acc, k, f(v))
        map-vals-helper(m, f, ks, idx + 1, new-acc)
    }
}

/// Keep only entries where the key satisfies the predicate.
///
/// Examples:
///   (filter-keys {:a 1 :ab 2 :abc 3} fn(k) { length(keyword->string(k)) > 1 })
///   ; => {:ab 2, :abc 3}
fn filter-keys(m, pred) {
    filter-keys-helper(m, pred, keys(m), 0, {})
}

fn filter-keys-helper(m, pred, ks, idx, acc) {
    if idx >= length(ks) {
        acc
    } else {
        let k = get(ks, idx)
        let new-acc = if pred(k) {
            assoc(acc, k, get(m, k))
        } else {
            acc
        }
        filter-keys-helper(m, pred, ks, idx + 1, new-acc)
    }
}

/// Keep only entries where the value satisfies the predicate.
///
/// Examples:
///   (filter-vals {:a 1 :b 2 :c 3} fn(v) { v > 1 })  ; => {:b 2, :c 3}
fn filter-vals(m, pred) {
    filter-vals-helper(m, pred, keys(m), 0, {})
}

fn filter-vals-helper(m, pred, ks, idx, acc) {
    if idx >= length(ks) {
        acc
    } else {
        let k = get(ks, idx)
        let v = get(m, k)
        let new-acc = if pred(v) {
            assoc(acc, k, v)
        } else {
            acc
        }
        filter-vals-helper(m, pred, ks, idx + 1, new-acc)
    }
}

// ============================================================================
// Rust PersistentSet Protocol Implementations
// ============================================================================

extend PersistentSet with Length {
    fn length(set) {
        rust-coll/set-count(set)
    }
}

extend PersistentSet with Format {
    fn format(set, depth) {
        let elems = rust-coll/set-elements(set)
        let len = rust-coll/vec-count(elems)
        if len == 0 {
            "#{}"
        } else {
            format-rust-set-elements(elems, 0, len, "#{")
        }
    }
}

fn format-rust-set-elements(elems-vec, idx, len, acc) {
    if idx >= len {
        acc ++ "}"
    } else {
        let elem = rust-coll/vec-get(elems-vec, idx)
        let elem-str = format(elem, 1)
        let new-acc = if idx == 0 {
            acc ++ elem-str
        } else {
            acc ++ ", " ++ elem-str
        }
        format-rust-set-elements(elems-vec, idx + 1, len, new-acc)
    }
}

// Sequence type for iterating over PersistentSet
struct PersistentSetSeq {
    elements
    index
}

extend PersistentSetSeq with Seq {
    fn first(seq) {
        rust-coll/vec-get(seq.elements, seq.index)
    }
    fn next(seq) {
        let next-idx = seq.index + 1
        if next-idx >= rust-coll/vec-count(seq.elements) {
            null
        } else {
            PersistentSetSeq { elements: seq.elements, index: next-idx }
        }
    }
}

extend PersistentSet with Seqable {
    fn seq(set) {
        let elems = rust-coll/set-elements(set)
        if rust-coll/vec-count(elems) == 0 {
            null
        } else {
            PersistentSetSeq { elements: elems, index: 0 }
        }
    }
}

// ============================================================================
// Set Utility Functions
// ============================================================================

/// Check if a value is a PersistentSet.
///
/// Examples:
///   (set? #{1 2 3})  ; => true
///   (set? [1 2 3])   ; => false
fn set?(x) {
    instance-of(x, PersistentSet)
}

/// Check if an element is in a set.
///
/// Examples:
///   (set-contains? #{1 2 3} 2)  ; => true
///   (set-contains? #{1 2 3} 5)  ; => false
fn set-contains?(set, elem) {
    rust-coll/set-contains?(set, elem)
}

/// Add an element to a set.
///
/// Returns a new set with the element added (no-op if already present).
///
/// Examples:
///   (set-add #{1 2} 3)  ; => #{1 2 3}
///   (set-add #{1 2} 2)  ; => #{1 2}
fn set-add(set, elem) {
    rust-coll/set-add(set, elem)
}

/// Remove an element from a set.
///
/// Returns a new set without the element.
///
/// Examples:
///   (set-remove #{1 2 3} 2)  ; => #{1 3}
fn set-remove(set, elem) {
    let elems = rust-coll/set-elements(set)
    set-remove-helper(elems, elem, 0, rust-coll/vec-count(elems), #{})
}

fn set-remove-helper(elems, to-remove, idx, len, acc) {
    if idx >= len {
        acc
    } else {
        let elem = rust-coll/vec-get(elems, idx)
        let new-acc = if elem == to-remove {
            acc
        } else {
            rust-coll/set-add(acc, elem)
        }
        set-remove-helper(elems, to-remove, idx + 1, len, new-acc)
    }
}

/// Return the union of two sets.
///
/// Contains all elements from both sets.
///
/// Examples:
///   (set-union #{1 2} #{2 3})  ; => #{1 2 3}
fn set-union(s1, s2) {
    let elems2 = rust-coll/set-elements(s2)
    set-union-helper(s1, elems2, 0, rust-coll/vec-count(elems2))
}

fn set-union-helper(s1, elems2, idx, len) {
    if idx >= len {
        s1
    } else {
        let elem = rust-coll/vec-get(elems2, idx)
        let new-s1 = rust-coll/set-add(s1, elem)
        set-union-helper(new-s1, elems2, idx + 1, len)
    }
}

/// Return the intersection of two sets.
///
/// Contains only elements present in both sets.
///
/// Examples:
///   (set-intersection #{1 2 3} #{2 3 4})  ; => #{2 3}
fn set-intersection(s1, s2) {
    let elems1 = rust-coll/set-elements(s1)
    set-intersection-helper(elems1, s2, 0, rust-coll/vec-count(elems1), #{})
}

fn set-intersection-helper(elems1, s2, idx, len, acc) {
    if idx >= len {
        acc
    } else {
        let elem = rust-coll/vec-get(elems1, idx)
        let new-acc = if rust-coll/set-contains?(s2, elem) {
            rust-coll/set-add(acc, elem)
        } else {
            acc
        }
        set-intersection-helper(elems1, s2, idx + 1, len, new-acc)
    }
}

/// Return the difference of two sets.
///
/// Contains elements in s1 but not in s2.
///
/// Examples:
///   (set-difference #{1 2 3} #{2 3 4})  ; => #{1}
fn set-difference(s1, s2) {
    let elems1 = rust-coll/set-elements(s1)
    set-difference-helper(elems1, s2, 0, rust-coll/vec-count(elems1), #{})
}

fn set-difference-helper(elems1, s2, idx, len, acc) {
    if idx >= len {
        acc
    } else {
        let elem = rust-coll/vec-get(elems1, idx)
        let new-acc = if rust-coll/set-contains?(s2, elem) {
            acc
        } else {
            rust-coll/set-add(acc, elem)
        }
        set-difference-helper(elems1, s2, idx + 1, len, new-acc)
    }
}

/// Check if s1 is a subset of s2.
///
/// Returns true if all elements of s1 are also in s2.
///
/// Examples:
///   (set-subset? #{1 2} #{1 2 3})  ; => true
///   (set-subset? #{1 4} #{1 2 3})  ; => false
fn set-subset?(s1, s2) {
    let elems1 = rust-coll/set-elements(s1)
    set-subset-helper(elems1, s2, 0, rust-coll/vec-count(elems1))
}

fn set-subset-helper(elems1, s2, idx, len) {
    if idx >= len {
        true
    } else {
        let elem = rust-coll/vec-get(elems1, idx)
        if rust-coll/set-contains?(s2, elem) {
            set-subset-helper(elems1, s2, idx + 1, len)
        } else {
            false
        }
    }
}

/// Convert a collection to a set.
///
/// Removes duplicates since sets only contain unique elements.
///
/// Examples:
///   (into-set [1 2 2 3 3 3])  ; => #{1 2 3}
fn into-set(coll) {
    reduce(coll, #{}, fn(acc, elem) { rust-coll/set-add(acc, elem) })
}

// ============================================================================
// Regex Protocol Implementations
// ============================================================================

extend Regex with Format {
    fn format(regex, depth) {
        "#regex"
    }
}

// ============================================================================
// Character Code Functions
// ============================================================================

/// Get the Unicode code point of the first character in a string.
///
/// Examples:
///   (char-code "A")  ; => 65
///   (char-code "a")  ; => 97
fn char-code(s) {
    builtin/char-code(s)
}

/// Create a single-character string from a Unicode code point.
///
/// Examples:
///   (char-from-code 65)  ; => "A"
///   (char-from-code 97)  ; => "a"
fn char-from-code(code) {
    builtin/char-from-code(code)
}

// ============================================================================
// Error Enum for Unified Error Handling
// ============================================================================
// This is the canonical Error type used across all async and I/O operations.
// Pattern match on specific error types to handle different failure cases.

enum Error {
    NotFound { path },
    PermissionDenied { path },
    AlreadyExists { path },
    IsDirectory { path },
    NotDirectory { path },
    Timeout { operation },
    Cancelled {},
    IO { message },
    Other { code, message }
}

// ============================================================================
// Result Type for Error Handling
// ============================================================================
// This is the canonical Result type used across all async and I/O operations.
// All namespaces (fs, timer, io, async) should use this type.

enum Result {
    Ok { value },
    Err { error }
}

/// Create a successful Result containing a value.
///
/// Examples:
///   (ok 42)  ; => Result.Ok { value: 42 }
fn ok(value) {
    Result.Ok { value: value }
}

/// Create an error Result containing an Error.
///
/// Examples:
///   (err (Error.NotFound { path: "/missing" }))
fn err(error) {
    Result.Err { error: error }
}

// Create an error result with code and message (convenience for legacy/IO errors)
fn err-io(message) {
    Result.Err { error: Error.IO { message: message } }
}

// Create an error result with code (convenience for legacy code)
fn err-code(code, message) {
    Result.Err { error: Error.Other { code: code, message: message } }
}

/// Check if a Result is successful (Ok variant).
///
/// Examples:
///   (ok? (ok 42))                      ; => true
///   (ok? (err (Error.IO { message: "failed" })))  ; => false
fn ok?(result) {
    match result {
        Result.Ok { value } => true,
        Result.Err { error } => false
    }
}

/// Unwrap a Result, returning the value or null on error.
///
/// Prints an error message if the result is an Err.
///
/// Examples:
///   (unwrap (ok 42))  ; => 42
///   (unwrap (err (Error.NotFound { path: "/x" })))  ; prints error, returns null
fn unwrap(result) {
    match result {
        Result.Ok { value } => value,
        Result.Err { error } => {
            match error {
                Error.NotFound { path } => println("Error: Not found:", path),
                Error.PermissionDenied { path } => println("Error: Permission denied:", path),
                Error.AlreadyExists { path } => println("Error: Already exists:", path),
                Error.IsDirectory { path } => println("Error: Is a directory:", path),
                Error.NotDirectory { path } => println("Error: Not a directory:", path),
                Error.Timeout { operation } => println("Error: Timeout on:", operation),
                Error.Cancelled {} => println("Error: Cancelled"),
                Error.IO { message } => println("Error:", message),
                Error.Other { code, message } => println("Error:", message)
            }
            null
        }
    }
}

/// Unwrap a Result, returning the value or a default on error.
///
/// Examples:
///   (unwrap-or (ok 42) 0)                        ; => 42
///   (unwrap-or (err (Error.IO { message: "" })) 0)  ; => 0
fn unwrap-or(result, default) {
    match result {
        Result.Ok { value } => value,
        Result.Err { error } => default
    }
}

// Check if a result is a timeout error
fn timeout?(result) {
    match result {
        Result.Err { error } => match error {
            Error.Timeout { operation } => true,
            _ => false
        },
        _ => false
    }
}

// Check if a result is a not-found error
fn not-found?(result) {
    match result {
        Result.Err { error } => match error {
            Error.NotFound { path } => true,
            _ => false
        },
        _ => false
    }
}

// Get the error from a result (returns null if Ok)
fn get-error(result) {
    match result {
        Result.Ok { value } => null,
        Result.Err { error } => error
    }
}

// ============================================================================
// String Utility Functions
// ============================================================================
// Note: split() and starts-with?() are provided as builtins - see builtins.rs

// ============================================================================
// Reflection Utilities (aliases for beagle.reflect)
// ============================================================================

use beagle.reflect as reflect

/// Get documentation for a function or type.
///
/// Returns the docstring associated with the value, or null if none exists.
/// Works with functions, structs, enums, and other documented values.
///
/// Examples:
///   doc(map)       ; => "Apply a function to each element..."
///   doc(Result)    ; => documentation for Result enum
fn doc(value) {
    reflect/doc(value)
}

/// Search for functions by name or docstring.
///
/// Returns a list of fully-qualified function names that match the query.
/// The query is matched against both function names and their docstrings.
///
/// Examples:
///   apropos("file")    ; => ["beagle.fs/read-file", "beagle.fs/write-file", ...]
///   apropos("reduce")  ; => ["beagle.core/reduce", "beagle.core/reduce-right"]
fn apropos(query) {
    reflect/apropos(query)
}

/// Assert that calling the given function throws an exception.
/// Throws AssertionError if no exception is thrown.
///
/// Examples:
///   assert-throws!(fn() { throw "boom" })   ; passes
///   assert-throws!(fn() { 42 })              ; fails - no exception thrown
fn assert-throws!(thunk) {
    let threw = try {
        thunk()
        false
    } catch (_e) {
        true
    }
    if !threw {
        throw("assert-throws! failed: expected function to throw, but it returned normally")
    }
}

// Writer protocol definitions moved to beginning of file
