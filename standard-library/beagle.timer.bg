namespace beagle.timer

use beagle.core as core
use beagle.effect as effect

// ============================================================================
// Timer Effect
// ============================================================================
// The Timer effect provides time-related operations.
// Handlers determine how operations execute (blocking sleep vs async timer).
//
// Usage:
//   use beagle.timer as timer
//
//   // With a handler installed:
//   handle effect/Handler(timer/Timer) with some_handler {
//       timer/sleep(100)  // Sleep for 100ms
//       let now = timer/now()
//   }
//
// For blocking sleep (no handler required):
//   timer/blocking-sleep(100)

// ============================================================================
// Timer Effect Enum
// ============================================================================

enum Timer {
    Sleep { ms },
    Now {}
}

// ============================================================================
// Timer Operations
// ============================================================================
// These functions perform Timer effects. They must be called within a
// `handle effect/Handler(Timer) with handler { ... }` block.

/// Sleep for a number of milliseconds.
///
/// Must be called within a Timer effect handler block.
///
/// Examples:
///   (timer/sleep 100)  ; Sleep for 100ms
fn sleep(ms) {
    perform Timer.Sleep { ms: ms }
}

/// Get current time in nanoseconds since epoch.
///
/// Examples:
///   (let start (timer/now))
///   ; ... do work ...
///   (let elapsed (- (timer/now) start))
fn now() {
    perform Timer.Now {}
}

// ============================================================================
// BlockingTimerHandler - Synchronous timer handler
// ============================================================================

struct BlockingTimerHandler {}

extend BlockingTimerHandler with effect/Handler(Timer) {
    fn handle(self, op, resume) {
        let result = match op {
            Timer.Sleep { ms } => {
                core/sleep(ms)
                ok(null)
            },
            Timer.Now {} => {
                core/time-now()
            }
        }
        resume(result)
    }
}

// ============================================================================
// Helper Functions
// ============================================================================

/// Wrap a future with a timeout.
///
/// Returns Result.Ok if completed before timeout, or Result.Err with Timeout error.
/// Requires both Timer and Async handlers to be installed.
///
/// Examples:
///   (match (timer/timeout 1000 my-future) {
///       Result.Ok { value } => value,
///       Result.Err { error } => "timed out"
///   })
fn timeout(ms, future) {
    // Import async module for future-state
    use beagle.async as async

    let start = core/time-now()
    let deadline_ns = start + (ms * 1000000)  // Convert ms to ns
    let wait_timeout = 50  // Check every 50ms at most

    loop {
        let state = async/future-state(future)
        match state {
            async/FutureState.Resolved { value } => {
                break(core/ok(value))
            },
            async/FutureState.Rejected { error } => {
                throw(error)
            },
            async/FutureState.Cancelled {} => {
                break(core/err(core/Error.Cancelled {}))
            },
            _ => {
                let now-time = core/time-now()
                if now-time >= deadline_ns {
                    break(core/err(core/Error.Timeout { operation: "timeout" }))
                }
                let remaining_ms = (deadline_ns - now-time) / 1000000
                let actual_wait = if remaining_ms < wait_timeout {
                    remaining_ms
                } else {
                    wait_timeout
                }
                core/future-wait(actual_wait)
            }
        }
    }
}

/// Create a deadline (absolute time in nanoseconds from now).
///
/// Useful for setting a single deadline across multiple operations.
///
/// Examples:
///   (let d (timer/deadline 5000))  ; 5 second deadline
fn deadline(ms) {
    core/time-now() + (ms * 1000000)
}

/// Check if a deadline has passed.
fn deadline-passed?(deadline-time) {
    core/time-now() >= deadline-time
}

/// Get remaining milliseconds until a deadline (0 if passed).
fn deadline-remaining(deadline-time) {
    let remaining = deadline-time - core/time-now()
    if remaining < 0 {
        0
    } else {
        remaining / 1000000
    }
}

// ============================================================================
// Blocking Convenience Functions
// ============================================================================

fn run-blocking(thunk) {
    let handler = BlockingTimerHandler {}
    handle effect/Handler(Timer) with handler {
        thunk()
    }
}

/// Sleep for a number of milliseconds synchronously.
///
/// No handler required. Blocks the current thread.
///
/// Examples:
///   (timer/blocking-sleep 100)  ; Sleep for 100ms
fn blocking-sleep(ms) {
    run-blocking(fn() { sleep(ms) })
}

/// Get current time in nanoseconds synchronously.
///
/// No handler required.
fn blocking-now() {
    run-blocking(fn() { now() })
}
