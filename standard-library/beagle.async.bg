namespace beagle.async

use beagle.io as io
use beagle.ffi as ffi
use beagle.builtin as builtin
use beagle.effect as effect
use beagle.core as core

// ============================================================================
// Async Effect System
// ============================================================================
// This module provides the core async/await mechanism via the Async effect.
// Users write normal code; the event loop and threading are invisible.
//
// The ImplicitAsyncHandler is the primary production handler, automatically
// wrapped around main() by __main__. It combines threaded spawn/await with
// event-loop-based sleep and async file I/O for best-of-both-worlds behavior.
//
// BlockingAsyncHandler is available for deterministic testing.

// ============================================================================
// Future Data Types
// ============================================================================
// Futures represent values that may not be available yet. They are created
// by spawn() and resolved by the async runtime.

enum FutureState {
    Pending {},
    Running {},
    Resolved { value },
    Rejected { error },
    Cancelled {}
}

// Future struct - holds state as an atom for thread-safe access
// The state_atom contains a FutureState value
struct Future {
    state_atom
}

/// Create a new future with an initial state.
///
/// Futures represent values that may not be available yet.
///
/// Examples:
///   (let f (make-future (FutureState.Pending {})))
fn make-future(initial_state) {
    Future { state_atom: atom(initial_state) }
}

/// Get the current state of a future.
///
/// Returns a FutureState: Pending, Running, Resolved, Rejected, or Cancelled.
fn future-state(future) {
    deref(future.state_atom)
}

/// Resolve a future with a successful value.
///
/// Notifies any threads waiting on this future.
fn resolve-future!(future, value) {
    reset!(future.state_atom, FutureState.Resolved { value: value })
    // Notify any threads waiting on futures
    core/future-notify()
}

/// Reject a future with an error.
///
/// Notifies any threads waiting on this future.
fn reject-future!(future, error) {
    reset!(future.state_atom, FutureState.Rejected { error: error })
    // Notify any threads waiting on futures
    core/future-notify()
}

/// Cancel a future.
///
/// The future's state becomes Cancelled. Notifies any waiting threads.
fn cancel-future!(future) {
    reset!(future.state_atom, FutureState.Cancelled {})
    // Notify any threads waiting on futures
    core/future-notify()
}

/// Check if a future has been cancelled.
fn future-cancelled?(future) {
    let state = future-state(future)
    match state {
        FutureState.Cancelled {} => true,
        _ => false
    }
}

// ============================================================================
// Cancellation Token
// ============================================================================
// CancellationToken provides a cooperative cancellation mechanism.
// Tasks check the token periodically and exit early if cancelled.

struct CancellationToken {
    cancelled_atom
}

/// Create a new cancellation token.
///
/// Cancellation tokens provide cooperative cancellation for async tasks.
fn make-cancellation-token() {
    CancellationToken { cancelled_atom: atom(false) }
}

/// Cancel a cancellation token.
///
/// All tasks watching this token should stop.
fn cancel!(token) {
    reset!(token.cancelled_atom, true)
    // Notify waiters so they can check cancellation
    core/future-notify()
}

/// Check if a cancellation token has been cancelled.
fn cancelled?(token) {
    deref(token.cancelled_atom)
}

// ============================================================================
// Task Scope for Structured Concurrency
// ============================================================================
// TaskScope ensures that all spawned tasks complete before the scope exits.
// If the scope exits early (error or cancellation), all child tasks are cancelled.

struct TaskScope {
    token
    children_atom
}

// Create a new task scope
fn make-scope() {
    TaskScope {
        token: make-cancellation-token()
        children_atom: atom([])
    }
}

// Add a child future to a scope
fn scope-add-child!(scope, future) {
    let children = deref(scope.children_atom)
    reset!(scope.children_atom, push(children, future))
}

// Get all children from a scope
fn scope-children(scope) {
    deref(scope.children_atom)
}

// Cancel all children in a scope
fn scope-cancel-all!(scope) {
    cancel!(scope.token)
    let children = scope-children(scope)
    let mut s = seq(children)
    while s != null {
        let child = first(s)
        cancel-future!(child)
        s = next(s)
    }
}

// Wait for all children to complete (or be cancelled)
fn scope-await-all-children(scope) {
    let children = scope-children(scope)
    let mut s = seq(children)
    while s != null {
        let child = first(s)
        // Wait for child to reach a terminal state
        loop {
            let state = future-state(child)
            match state {
                FutureState.Resolved { value } => break(null),
                FutureState.Rejected { error } => break(null),
                FutureState.Cancelled {} => break(null),
                _ => {
                    // Wait a bit and check again
                    core/future-wait(10)
                }
            }
        }
        s = next(s)
    }
}

/// Run a block with a task scope for structured concurrency.
///
/// Ensures all spawned tasks complete before the scope exits.
/// On error or cancellation, all child tasks are cancelled.
///
/// Examples:
///   (with-scope fn(scope) {
///       let f1 = spawn(scope, fn() { compute1() })
///       let f2 = spawn(scope, fn() { compute2() })
///       [await(f1), await(f2)]
///   })
fn with-scope(body) {
    let scope = make-scope()
    let result = try {
        let r = body(scope)
        // Normal exit - wait for children
        scope-await-all-children(scope)
        r
    } catch (e) {
        // On error, cancel all children and wait for cleanup
        scope-cancel-all!(scope)
        scope-await-all-children(scope)
        throw(e)
    }
    result
}

// Result types for await-first
enum RaceResult {
    Ok { value, index },
    AllFailed { errors }
}

// Result type for timeout operations
enum TimeoutResult {
    Ok { value },
    TimedOut {}
}

// ============================================================================
// IO Action Enum - Generic async I/O operations
// ============================================================================
// IOAction describes what I/O operation to perform. The handler executes
// the operation and resumes the continuation when it completes.

// TCP Listener - wraps a listener ID and event loop ID
struct TcpListener {
    loop_id
    listener_id
}

// TCP Socket - wraps a socket ID and event loop ID
struct TcpSocket {
    loop_id
    socket_id
}

enum IOAction {
    // TCP operations
    TcpListen { host, port },
    TcpConnect { host, port },
    TcpAccept { listener },
    TcpRead { socket, n },
    TcpWrite { socket, data },
    TcpClose { socket },
    TcpCloseListener { listener }
}

// ============================================================================
// Async Effect Enum
// ============================================================================
// The Async effect handles all async operations including legacy file I/O.

enum Async {
    // Future operations
    Await { future },
    AwaitAll { futures },
    AwaitFirst { futures },
    Cancel { future },

    // Generic I/O - handler multiplexes across pending operations
    IO { action },

    // File operations
    ReadFile { path },
    WriteFile { path, content },
    AppendFile { path, content },
    DeleteFile { path },
    FileExists { path },
    RenameFile { old_path, new_path },
    CopyFile { src_path, dest_path },

    // Directory operations
    ReadDir { path },
    CreateDir { path },
    CreateDirAll { path },
    RemoveDir { path },
    RemoveDirAll { path },

    // File metadata
    FileSize { path },
    IsDirectory { path },
    IsFile { path },

    // Low-level file operations
    Open { path, mode },
    Close { file },
    Read { file, n },
    Write { file, content },
    ReadLine { file },
    Flush { file },

    // Timing
    Sleep { ms },

    // Spawning
    Spawn { thunk },
    SpawnWithToken { thunk, token }
}

// ============================================================================
// Async Result Helpers (wrappers around beagle.core Result/Error)
// ============================================================================
// These provide a consistent API for async operations while using the
// standard Result and Error types from beagle.core.

// Create an async success result (uses beagle.core/ok)
fn async-ok(value) {
    ok(value)
}

// Create an async error result (uses beagle.core/err with Error.IO)
fn async-err(code, message) {
    err(Error.IO { message: message })
}

// Check if a result is successful
fn async-ok?(result) {
    match result {
        Result.Ok { value } => true,
        Result.Err { error } => false
    }
}

// Unwrap a result, throwing on error
fn async-unwrap(result) {
    match result {
        Result.Ok { value } => value,
        Result.Err { error } => throw(error)
    }
}

// Unwrap a result with a default value on error
fn async-unwrap-or(result, default) {
    match result {
        Result.Ok { value } => value,
        Result.Err { error } => default
    }
}

// ============================================================================
// File Handler Implementation Functions (inlined to avoid circular deps)
// ============================================================================

fn handle-read-file(path) {
    try {
        let content = read-full-file(path)
        ok(content)
    } catch (e) {
        err(Error.NotFound { path: path })
    }
}

fn handle-write-file(path, content) {
    let file-result = io/open(path, "w")
    match file-result {
        Result.Ok { value } => {
            let file = value
            let write-result = io/write-string(file, content)
            io/close(file)
            match write-result {
                Result.Ok { value } => ok(value),
                Result.Err { error } => err(error)
            }
        },
        Result.Err { error } => {
            err(error)
        }
    }
}

fn handle-append-file(path, content) {
    let file-result = io/open(path, "a")
    match file-result {
        Result.Ok { value } => {
            let file = value
            let write-result = io/write-string(file, content)
            io/close(file)
            match write-result {
                Result.Ok { value } => ok(value),
                Result.Err { error } => err(error)
            }
        },
        Result.Err { error } => {
            err(error)
        }
    }
}

fn handle-delete-file(path) {
    let result = core/fs-unlink(path)
    if result == 0 {
        ok(null)
    } else {
        err(Error.NotFound { path: path })
    }
}

fn handle-file-exists(path) {
    let result = core/fs-access(path, 0) // F_OK = 0
    ok(result == 0)
}

fn handle-file-size(path) {
    let size = core/fs-file-size(path)
    if size < 0 {
        async-err(size, "Failed to get file size: " ++ path)
    } else {
        async-ok(size)
    }
}

fn handle-is-file(path) {
    let result = core/fs-is-file?(path)
    async-ok(result)
}

fn handle-is-directory(path) {
    let result = core/fs-is-directory?(path)
    async-ok(result)
}

fn handle-rename-file(old-path, new-path) {
    let result = core/fs-rename(old-path, new-path)
    if result == 0 {
        async-ok(null)
    } else {
        async-err(result, "Failed to rename " ++ old-path ++ " to " ++ new-path)
    }
}

fn handle-copy-file(src-path, dest-path) {
    let read-result = handle-read-file(src-path)
    match read-result {
        Result.Ok { value } => {
            handle-write-file(dest-path, value)
        },
        Result.Err { error } => {
            err(error)
        }
    }
}

fn handle-read-dir(path) {
    let entries = core/fs-readdir(path)
    if entries == null {
        err(Error.NotFound { path: path })
    } else {
        ok(entries)
    }
}

fn handle-create-dir(path) {
    let result = core/fs-mkdir(path, 493) // 0755 in octal
    if result == 0 {
        ok(null)
    } else if result == -17 {
        err(Error.AlreadyExists { path: path })
    } else {
        err(Error.IO { message: "Failed to create directory" })
    }
}

fn handle-create-dir-all(path) {
    if path == "" || path == "/" {
        async-ok(null)
    } else {
        let components = core/split(path, "/")
        let mut current-path = ""
        let mut i = 0
        let len = length(components)
        let mut found-error = null

        while i < len && found-error == null {
            let component = get(components, i)
            if component != "" {
                if current-path == "" && core/starts-with?(path, "/") {
                    current-path = "/" ++ component
                } else if current-path == "" {
                    current-path = component
                } else {
                    current-path = current-path ++ "/" ++ component
                }

                let result = core/fs-mkdir(current-path, 493) // 0755 in octal
                // 0 = success, -17 = EEXIST (already exists, that's ok)
                if result != 0 && result != -17 {
                    found-error = async-err(result, "Failed to create directory: " ++ current-path)
                }
            }
            i = i + 1
        }

        if found-error == null {
            async-ok(null)
        } else {
            found-error
        }
    }
}

fn handle-remove-dir(path) {
    let result = core/fs-rmdir(path)
    if result == 0 {
        async-ok(null)
    } else {
        async-err(result, "Failed to remove directory")
    }
}

fn handle-remove-dir-all(path) {
    let entries = core/fs-readdir(path)
    if entries == null {
        // Not a directory or doesn't exist - try to unlink as file
        let result = core/fs-unlink(path)
        if result == 0 {
            async-ok(null)
        } else {
            async-err(result, "Failed to remove: " ++ path)
        }
    } else {
        // It's a directory - remove all entries first
        let mut i = 0
        let len = length(entries)
        let mut found-error = null

        while i < len && found-error == null {
            let entry = get(entries, i)
            // Skip . and ..
            if entry != "." && entry != ".." {
                let entry-path = path ++ "/" ++ entry

                // Try to unlink as file first
                let unlink-result = core/fs-unlink(entry-path)
                if unlink-result != 0 {
                    // unlink failed - might be a directory, try recursive remove
                    let recursive-result = handle-remove-dir-all(entry-path)
                    if async-ok?(recursive-result) == false {
                        found-error = recursive-result
                    }
                }
            }
            i = i + 1
        }

        if found-error != null {
            found-error
        } else {
            // Now remove the empty directory
            let result = core/fs-rmdir(path)
            if result == 0 {
                async-ok(null)
            } else {
                async-err(result, "Failed to remove directory: " ++ path)
            }
        }
    }
}

fn handle-open(path, mode) {
    let result = io/open(path, mode)
    match result {
        Result.Ok { value } => async-ok(value),
        Result.Err { error } => err(error)
    }
}

fn handle-close(file) {
    let result = io/close(file)
    match result {
        Result.Ok { value } => async-ok(null),
        Result.Err { error } => err(error)
    }
}

fn handle-read(file, n) {
    let result = io/read-bytes(file, n)
    match result {
        Result.Ok { value } => {
            let s = ffi/get-string(value.buffer, 0, value.length)
            ffi/deallocate(value.buffer)
            async-ok(s)
        },
        Result.Err { error } => err(error)
    }
}

fn handle-write(file, content) {
    let result = io/write-string(file, content)
    match result {
        Result.Ok { value } => async-ok(value),
        Result.Err { error } => err(error)
    }
}

fn handle-read-line(file) {
    let result = io/read-line(file, 4096)
    match result {
        Result.Ok { value } => async-ok(value),
        Result.Err { error } => err(error)
    }
}

fn handle-flush(file) {
    let result = io/flush(file)
    match result {
        Result.Ok { value } => async-ok(null),
        Result.Err { error } => err(error)
    }
}

fn handle-sleep(ms) {
    // Use the builtin sleep from beagle.core
    core/sleep(ms)
    async-ok(null)
}

// ============================================================================
// BlockingAsyncHandler - handles Async effects synchronously
// ============================================================================

struct BlockingAsyncHandler {}

extend BlockingAsyncHandler with effect/Handler(Async) {
    fn handle(self, op, resume) {
        let result = match op {
            // Core async operations
            Async.Await { future } => {
                handle-await-blocking(future)
            },
            Async.AwaitAll { futures } => {
                handle-await-all-blocking(futures)
            },
            Async.AwaitFirst { futures } => {
                handle-await-first-blocking(futures)
            },
            Async.Cancel { future } => {
                handle-cancel(future)
            },

            // Generic IO operations
            Async.IO { action } => {
                handle-io-action(action)
            },

            // File operations
            Async.ReadFile { path } => {
                handle-read-file(path)
            },
            Async.WriteFile { path, content } => {
                handle-write-file(path, content)
            },
            Async.AppendFile { path, content } => {
                handle-append-file(path, content)
            },
            Async.DeleteFile { path } => {
                handle-delete-file(path)
            },
            Async.FileExists { path } => {
                handle-file-exists(path)
            },
            Async.RenameFile { old_path, new_path } => {
                handle-rename-file(old_path, new_path)
            },
            Async.CopyFile { src_path, dest_path } => {
                handle-copy-file(src_path, dest_path)
            },
            Async.ReadDir { path } => {
                handle-read-dir(path)
            },
            Async.CreateDir { path } => {
                handle-create-dir(path)
            },
            Async.CreateDirAll { path } => {
                handle-create-dir-all(path)
            },
            Async.RemoveDir { path } => {
                handle-remove-dir(path)
            },
            Async.RemoveDirAll { path } => {
                handle-remove-dir-all(path)
            },
            Async.FileSize { path } => {
                handle-file-size(path)
            },
            Async.IsDirectory { path } => {
                handle-is-directory(path)
            },
            Async.IsFile { path } => {
                handle-is-file(path)
            },
            Async.Open { path, mode } => {
                handle-open(path, mode)
            },
            Async.Close { file } => {
                handle-close(file)
            },
            Async.Read { file, n } => {
                handle-read(file, n)
            },
            Async.Write { file, content } => {
                handle-write(file, content)
            },
            Async.ReadLine { file } => {
                handle-read-line(file)
            },
            Async.Flush { file } => {
                handle-flush(file)
            },
            Async.Sleep { ms } => {
                handle-sleep(ms)
            },
            Async.Spawn { thunk } => {
                handle-spawn-blocking(thunk)
            },
            Async.SpawnWithToken { thunk, token } => {
                handle-spawn-with-token-blocking(thunk, token)
            }
        }
        resume(result)
    }
}

// ============================================================================
// Blocking Handler Implementation Functions
// ============================================================================

fn handle-await-blocking(future) {
    // Handle null futures - nothing to await, just return null
    if future == null {
        null
    } else {
        // For blocking handler, futures are already resolved when we get here
        let state = future-state(future)
        match state {
            FutureState.Resolved { value } => value,
            FutureState.Rejected { error } => {
                throw(error)
            },
            FutureState.Cancelled {} => {
                throw("Future was cancelled")
            },
            FutureState.Pending {} => {
                throw("Attempted to await a pending future in blocking mode")
            },
            FutureState.Running {} => {
                throw("Attempted to await a running future in blocking mode")
            }
        }
    }
}

fn handle-await-all-blocking(futures) {
    let mut results = []
    let mut s = seq(futures)
    while s != null {
        let f = first(s)
        let value = handle-await-blocking(f)
        results = push(results, value)
        s = next(s)
    }
    results
}

fn handle-await-first-blocking(futures) {
    // In blocking mode, all futures are already resolved
    // Just return the first resolved one's result
    let mut s = seq(futures)
    let mut index = 0
    let mut result = null
    let mut found = false
    while s != null && found == false {
        let f = first(s)
        let state = future-state(f)
        match state {
            FutureState.Resolved { value } => {
                result = RaceResult.Ok { value: value, index: index }
                found = true
            },
            FutureState.Rejected { error } => {
                // Skip rejected, try next
            },
            _ => {}
        }
        index = index + 1
        s = next(s)
    }
    if found {
        result
    } else {
        // All failed - collect errors
        let mut errors = []
        let mut s2 = seq(futures)
        while s2 != null {
            let f = first(s2)
            let state = future-state(f)
            match state {
                FutureState.Rejected { error } => {
                    errors = push(errors, error)
                },
                FutureState.Cancelled {} => {
                    errors = push(errors, "Cancelled")
                },
                FutureState.Pending {} => {
                    errors = push(errors, "Pending")
                },
                FutureState.Running {} => {
                    errors = push(errors, "Running")
                },
                FutureState.Resolved { value } => {
                    // Shouldn't happen if we didn't find a resolved one above
                    errors = push(errors, "Unexpected resolved state")
                }
            }
            s2 = next(s2)
        }
        RaceResult.AllFailed { errors: errors }
    }
}

fn handle-cancel(future) {
    cancel-future!(future)
    null
}

fn handle-spawn-blocking(thunk) {
    // Create a future and immediately execute the thunk synchronously
    let future = make-future(FutureState.Running {})
    try {
        let result = thunk()
        resolve-future!(future, result)
    } catch (e) {
        reject-future!(future, e)
    }
    future
}

fn handle-spawn-with-token-blocking(thunk, token) {
    // Create a future and immediately execute the thunk synchronously
    let future = make-future(FutureState.Running {})
    try {
        // Check if already cancelled before starting
        if cancelled?(token) {
            cancel-future!(future)
        } else {
            let result = thunk()
            // Check again after completion (cooperative cancellation)
            if cancelled?(token) {
                cancel-future!(future)
            } else {
                resolve-future!(future, result)
            }
        }
    } catch (e) {
        reject-future!(future, e)
    }
    future
}

// ============================================================================
// Threaded Implementation Functions
// ============================================================================
// These functions provide thread-based spawn, await, and polling.
// Used by ImplicitAsyncHandler for production-ready async/concurrency.

// Spawn a thread to execute the thunk
fn handle-spawn-threaded(thunk) {
    let future = make-future(FutureState.Running {})
    // Capture the atom for the closure
    let state_atom = future.state_atom

    // Spawn a thread that executes the thunk and updates the future
    thread(fn() {
        try {
            let result = thunk()
            reset!(state_atom, FutureState.Resolved { value: result })
        } catch (e) {
            reset!(state_atom, FutureState.Rejected { error: e })
        }
    })

    future
}

// Spawn a thread with cancellation token
fn handle-spawn-with-token-threaded(thunk, token) {
    let future = make-future(FutureState.Running {})
    let state_atom = future.state_atom
    let cancelled_atom = token.cancelled_atom

    // Spawn a thread that checks cancellation periodically
    thread(fn() {
        // Check if cancelled before starting
        if deref(cancelled_atom) {
            reset!(state_atom, FutureState.Cancelled {})
            core/future-notify()
        } else {
            try {
                let result = thunk()
                // Check if cancelled after completion
                if deref(cancelled_atom) {
                    reset!(state_atom, FutureState.Cancelled {})
                } else {
                    reset!(state_atom, FutureState.Resolved { value: result })
                }
            } catch (e) {
                reset!(state_atom, FutureState.Rejected { error: e })
            }
            core/future-notify()
        }
    })

    future
}

// Wait for a future by polling its state
fn handle-await-threaded(future) {
    // Handle null futures - nothing to await, just return null
    if future == null {
        null
    } else {
        poll-until-resolved(future)
    }
}

// Poll a future until it resolves, using efficient condition variable waiting
fn poll-until-resolved(future) {
    let wait_timeout = 50  // Wait up to 50ms per iteration for notifications
    loop {
        let state = future-state(future)
        match state {
            FutureState.Resolved { value } => {
                break(value)
            },
            FutureState.Rejected { error } => {
                throw(error)
            },
            FutureState.Cancelled {} => {
                throw("Future was cancelled")
            },
            _ => {
                // Wait for notification that a future completed (or timeout)
                core/future-wait(wait_timeout)
            }
        }
    }
}

// Wait for all futures (they run in parallel already)
fn handle-await-all-threaded(futures) {
    let mut results = []
    let mut s = seq(futures)
    while s != null {
        let f = first(s)
        let value = handle-await-threaded(f)
        results = push(results, value)
        s = next(s)
    }
    results
}

// Wait for first future to resolve
fn handle-await-first-threaded(futures) {
    let len = length(futures)
    if len == 0 {
        RaceResult.AllFailed { errors: [] }
    } else {
        let wait_timeout = 50  // Wait up to 50ms for notifications

        loop {
            // Check all futures for resolved
            let mut i = 0
            let mut found_resolved = false
            let mut resolved_value = null
            let mut resolved_index = 0
            while i < len && found_resolved == false {
                let f = get(futures, i)
                let state = future-state(f)
                match state {
                    FutureState.Resolved { value } => {
                        found_resolved = true
                        resolved_value = value
                        resolved_index = i
                    },
                    _ => {}
                }
                i = i + 1
            }

            if found_resolved {
                break(RaceResult.Ok { value: resolved_value, index: resolved_index })
            }

            // Check if all are rejected/failed/cancelled
            let mut all_done = true
            let mut all_failed = true
            let mut j = 0
            while j < len {
                let f = get(futures, j)
                let state = future-state(f)
                match state {
                    FutureState.Running {} => {
                        all_done = false
                        all_failed = false
                    },
                    FutureState.Pending {} => {
                        all_done = false
                        all_failed = false
                    },
                    FutureState.Resolved { value } => {
                        all_failed = false
                    },
                    FutureState.Rejected { error } => {},
                    FutureState.Cancelled {} => {}
                }
                j = j + 1
            }

            if all_done && all_failed {
                // Collect all errors
                let mut errors = []
                let mut k = 0
                while k < len {
                    let f = get(futures, k)
                    let state = future-state(f)
                    match state {
                        FutureState.Rejected { error } => {
                            errors = push(errors, error)
                        },
                        FutureState.Cancelled {} => {
                            errors = push(errors, "Cancelled")
                        },
                        FutureState.Pending {} => {},
                        FutureState.Running {} => {},
                        FutureState.Resolved { value } => {}
                    }
                    k = k + 1
                }
                break(RaceResult.AllFailed { errors: errors })
            }

            // Wait for notification or timeout
            core/future-wait(wait_timeout)
        }
    }
}

// ============================================================================
// Event Loop Functions
// ============================================================================
// Timer-based sleep and async file I/O using the event loop.
// Used by ImplicitAsyncHandler for non-blocking sleep and file operations.

// Sleep using event loop timers
fn handle-sleep-event-loop(loop_id, ms) {
    // Use a unique marker value for this timer
    let marker = core/time-now()

    // Set a timer that will complete after ms
    let timer_id = core/timer-set(loop_id, ms, marker)
    if timer_id < 0 {
        throw("Failed to set timer")
    }

    // Poll until the timer completes
    loop {
        // Process events with timeout slightly less than remaining time
        core/event-loop-run-once(loop_id, 10)

        // Consume only our completion marker so concurrent sleepers
        // cannot steal each other's timer completions.
        let completed = core/timer-take-completed(loop_id, marker)
        if completed == 1 {
            // Our timer completed - return Result like other handlers
            break(async-ok(null))
        }
    }
}

// ============================================================================
// Handle-Based Async File I/O Functions
// ============================================================================
// These functions use the new handle-based API which is:
// - Memory-safe: No raw heap pointers passed to worker threads
// - Thread-safe: Single atomic poll operation
// - O(1) lookup: Results indexed by handle in HashMap

// Poll a file operation result by handle
// Returns the result value (ok/err) or null if not ready
// Type codes: 1=ReadOk, 2=ReadErr, 3=WriteOk, 4=WriteErr,
//             5=DeleteOk, 6=DeleteErr, 7=StatOk, 8=StatErr,
//             9=ReadDirOk, 10=ReadDirErr
fn poll-file-result(loop_id, handle) {
    let type_code = core/file-result-poll-type(loop_id, handle)
    if type_code == 0 {
        // Not ready yet
        null
    } else if type_code == 1 {
        // ReadOk - get content string
        let content = core/file-result-get-string(loop_id, handle)
        async-ok(content)
    } else if type_code == 2 {
        // ReadErr - get error message
        let error_msg = core/file-result-get-string(loop_id, handle)
        async-err(-1, error_msg)
    } else if type_code == 3 {
        // WriteOk - get bytes written
        let bytes_written = core/file-result-get-value(loop_id, handle)
        async-ok(bytes_written)
    } else if type_code == 4 {
        // WriteErr - get error message
        let error_msg = core/file-result-get-string(loop_id, handle)
        async-err(-1, error_msg)
    } else if type_code == 5 {
        // DeleteOk - consume the result
        core/file-result-consume(loop_id, handle)
        async-ok(null)
    } else if type_code == 6 {
        // DeleteErr - get error message
        let error_msg = core/file-result-get-string(loop_id, handle)
        async-err(-1, error_msg)
    } else if type_code == 7 {
        // StatOk - get file size
        let file_size = core/file-result-get-value(loop_id, handle)
        async-ok(file_size)
    } else if type_code == 8 {
        // StatErr - get error message
        let error_msg = core/file-result-get-string(loop_id, handle)
        async-err(-1, error_msg)
    } else if type_code == 9 {
        // ReadDirOk - get entries
        let entries = core/file-result-get-entries(loop_id, handle)
        async-ok(entries)
    } else if type_code == 10 {
        // ReadDirErr - get error message
        let error_msg = core/file-result-get-string(loop_id, handle)
        async-err(-1, error_msg)
    } else if type_code == 11 {
        // BoolOk - get boolean value (1 = true, 0 = false)
        let bool_val = core/file-result-get-value(loop_id, handle)
        async-ok(bool_val == 1)
    } else if type_code == 12 {
        // BoolErr - get error message
        let error_msg = core/file-result-get-string(loop_id, handle)
        async-err(-1, error_msg)
    } else if type_code == 13 {
        // HandleOk - get handle key
        let handle_key = core/file-result-get-value(loop_id, handle)
        async-ok(handle_key)
    } else if type_code == 14 {
        // HandleErr - get error message
        let error_msg = core/file-result-get-string(loop_id, handle)
        async-err(-1, error_msg)
    } else {
        // Unknown type code - consume and return error
        core/file-result-consume(loop_id, handle)
        async-err(-1, "Unknown result type")
    }
}

// Wait for a file operation to complete by handle
fn wait-for-file-result(loop_id, handle) {
    loop {
        // Block until notified (timeout=0 means wait forever)
        // Workers notify immediately when results are ready
        // This eliminates polling overhead and matches Node.js libuv pattern
        core/event-loop-run-once(loop_id, 0)
        let result = poll-file-result(loop_id, handle)
        if result != null {
            break(result)
        }
    }
}

// ============================================================================
// Async File Handler Functions
// ============================================================================

fn handle-read-file-async(loop_id, path) {
    let handle = core/file-read-submit(loop_id, path)
    if handle < 0 {
        throw("Failed to submit read operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-write-file-async(loop_id, path, content) {
    let handle = core/file-write-submit(loop_id, path, content)
    if handle < 0 {
        throw("Failed to submit write operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-delete-file-async(loop_id, path) {
    let handle = core/file-delete-submit(loop_id, path)
    if handle < 0 {
        throw("Failed to submit delete operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-file-size-async(loop_id, path) {
    let handle = core/file-stat-submit(loop_id, path)
    if handle < 0 {
        throw("Failed to submit stat operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-read-dir-async(loop_id, path) {
    let handle = core/file-readdir-submit(loop_id, path)
    if handle < 0 {
        throw("Failed to submit readdir operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-append-file-async(loop_id, path, content) {
    let handle = core/file-append-submit(loop_id, path, content)
    if handle < 0 {
        throw("Failed to submit append operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-file-exists-async(loop_id, path) {
    let handle = core/file-exists-submit(loop_id, path)
    if handle < 0 {
        throw("Failed to submit exists operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-rename-file-async(loop_id, old_path, new_path) {
    let handle = core/file-rename-submit(loop_id, old_path, new_path)
    if handle < 0 {
        throw("Failed to submit rename operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-copy-file-async(loop_id, src_path, dest_path) {
    let handle = core/file-copy-submit(loop_id, src_path, dest_path)
    if handle < 0 {
        throw("Failed to submit copy operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-create-dir-async(loop_id, path) {
    let handle = core/file-mkdir-submit(loop_id, path)
    if handle < 0 {
        throw("Failed to submit mkdir operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-create-dir-all-async(loop_id, path) {
    let handle = core/file-mkdir-all-submit(loop_id, path)
    if handle < 0 {
        throw("Failed to submit mkdir-all operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-remove-dir-async(loop_id, path) {
    let handle = core/file-rmdir-submit(loop_id, path)
    if handle < 0 {
        throw("Failed to submit rmdir operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-remove-dir-all-async(loop_id, path) {
    let handle = core/file-rmdir-all-submit(loop_id, path)
    if handle < 0 {
        throw("Failed to submit rmdir-all operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-is-directory-async(loop_id, path) {
    let handle = core/file-is-dir-submit(loop_id, path)
    if handle < 0 {
        throw("Failed to submit is-directory operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-is-file-async(loop_id, path) {
    let handle = core/file-is-file-submit(loop_id, path)
    if handle < 0 {
        throw("Failed to submit is-file operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-open-async(loop_id, path, mode) {
    let handle = core/file-open-submit(loop_id, path, mode)
    if handle < 0 {
        throw("Failed to submit open operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-close-async(loop_id, handle_key) {
    let handle = core/file-close-submit(loop_id, handle_key)
    if handle < 0 {
        throw("Failed to submit close operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-handle-read-async(loop_id, handle_key, n) {
    let handle = core/file-handle-read-submit(loop_id, handle_key, n)
    if handle < 0 {
        throw("Failed to submit handle-read operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-handle-write-async(loop_id, handle_key, content) {
    let handle = core/file-handle-write-submit(loop_id, handle_key, content)
    if handle < 0 {
        throw("Failed to submit handle-write operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-handle-readline-async(loop_id, handle_key) {
    let handle = core/file-handle-readline-submit(loop_id, handle_key)
    if handle < 0 {
        throw("Failed to submit handle-readline operation")
    }
    wait-for-file-result(loop_id, handle)
}

fn handle-handle-flush-async(loop_id, handle_key) {
    let handle = core/file-handle-flush-submit(loop_id, handle_key)
    if handle < 0 {
        throw("Failed to submit handle-flush operation")
    }
    wait-for-file-result(loop_id, handle)
}

// ============================================================================
// Public Async API Functions
// ============================================================================

// Read the entire contents of a file as a string
fn read-file(path) {
    perform Async.ReadFile { path: path }
}

// Write content to a file (creates or overwrites)
fn write-file(path, content) {
    perform Async.WriteFile { path: path, content: content }
}

// Append content to a file (creates if doesn't exist)
fn append-file(path, content) {
    perform Async.AppendFile { path: path, content: content }
}

// Delete a file
fn delete-file(path) {
    perform Async.DeleteFile { path: path }
}

// Check if a file exists
fn file-exists?(path) {
    perform Async.FileExists { path: path }
}

// List directory contents
fn read-dir(path) {
    perform Async.ReadDir { path: path }
}

// Create a directory
fn create-dir(path) {
    perform Async.CreateDir { path: path }
}

// Create a directory and all parent directories
fn create-dir-all(path) {
    perform Async.CreateDirAll { path: path }
}

// Remove an empty directory
fn remove-dir(path) {
    perform Async.RemoveDir { path: path }
}

// Remove a directory and all contents
fn remove-dir-all(path) {
    perform Async.RemoveDirAll { path: path }
}

// Get file size in bytes
fn file-size(path) {
    perform Async.FileSize { path: path }
}

// Check if path is a directory
fn is-directory?(path) {
    perform Async.IsDirectory { path: path }
}

// Check if path is a regular file
fn is-file?(path) {
    perform Async.IsFile { path: path }
}

// Rename/move a file or directory
fn rename-file(old-path, new-path) {
    perform Async.RenameFile { old_path: old-path, new_path: new-path }
}

// Copy a file
fn copy-file(src-path, dest-path) {
    perform Async.CopyFile { src_path: src-path, dest_path: dest-path }
}

// Open a file with mode ("r", "w", "a", etc.)
fn open(path, mode) {
    perform Async.Open { path: path, mode: mode }
}

// Close a file handle
fn close(file) {
    perform Async.Close { file: file }
}

// Read n bytes from a file
fn read(file, n) {
    perform Async.Read { file: file, n: n }
}

// Write content to a file
fn write(file, content) {
    perform Async.Write { file: file, content: content }
}

// Read a line from a file
fn read-line(file) {
    perform Async.ReadLine { file: file }
}

// Flush a file's buffers
fn flush(file) {
    perform Async.Flush { file: file }
}

/// Sleep for a number of milliseconds.
///
/// Must be called within an Async effect handler.
///
/// Examples:
///   (sleep 1000)  ; Sleep for 1 second
fn sleep(ms) {
    perform Async.Sleep { ms: ms }
}

// ============================================================================
// Future/Async API Functions
// ============================================================================

// Create a future from a thunk - starts execution immediately (eager)
fn async(thunk) {
    perform Async.Spawn { thunk: thunk }
}

/// Wait for a future to complete and return its value.
///
/// Blocks until the future resolves, rejects, or is cancelled.
///
/// Examples:
///   (let f (spawn fn() { compute() }))
///   (await f)  ; => result of compute()
fn await(future) {
    perform Async.Await { future: future }
}

/// Wait for all futures to complete and return their values as a vector.
///
/// Examples:
///   (let fs [(spawn fn() { 1 }) (spawn fn() { 2 })])
///   (await-all fs)  ; => [1 2]
fn await-all(futures) {
    perform Async.AwaitAll { futures: futures }
}

/// Wait for the first future to complete and return its result.
///
/// Returns a RaceResult indicating which future completed first.
fn await-first(futures) {
    perform Async.AwaitFirst { futures: futures }
}

/// Wait for a future with a timeout in milliseconds.
///
/// Returns TimeoutResult.Ok if completed, TimeoutResult.TimedOut if timeout.
fn await-timeout(ms, future) {
    let start = time-now()
    let deadline_ns = start + (ms * 1000000)
    let wait_timeout = 50

    loop {
        let state = future-state(future)
        match state {
            FutureState.Resolved { value } => {
                break(TimeoutResult.Ok { value: value })
            },
            FutureState.Rejected { error } => {
                throw(error)
            },
            FutureState.Cancelled {} => {
                throw("Future was cancelled")
            },
            _ => {
                let now = time-now()
                if now >= deadline_ns {
                    break(TimeoutResult.TimedOut {})
                }
                let remaining_ms = (deadline_ns - now) / 1000000
                let actual_wait = if remaining_ms < wait_timeout {
                    remaining_ms
                } else {
                    wait_timeout
                }
                core/future-wait(actual_wait)
            }
        }
    }
}

// ============================================================================
// Cancellation API Functions
// ============================================================================

// Create a future with a cancellation token
fn async-with-token(token, thunk) {
    perform Async.SpawnWithToken { thunk: thunk, token: token }
}

// Cancel a future (cooperative cancellation)
fn cancel(future) {
    perform Async.Cancel { future: future }
}

// Spawn a task in a scope
fn spawn-in-scope(scope, thunk) {
    let future = async-with-token(scope.token, thunk)
    scope-add-child!(scope, future)
    future
}

// ============================================================================
// Timeout Wrappers
// ============================================================================

// Run a thunk with a timeout (in milliseconds)
fn with-timeout(ms, thunk) {
    let start = time-now()
    let deadline_ns = start + (ms * 1000000)

    let result = thunk()
    let end = time-now()

    if end > deadline_ns {
        TimeoutResult.TimedOut {}
    } else {
        TimeoutResult.Ok { value: result }
    }
}

// Run an async operation with a timeout
fn async-with-timeout(ms, thunk) {
    let token = make-cancellation-token()
    let result_future = async-with-token(token, thunk)

    let outcome = await-timeout(ms, result_future)
    match outcome {
        TimeoutResult.TimedOut {} => {
            cancel!(token)
            TimeoutResult.TimedOut {}
        },
        TimeoutResult.Ok { value } => {
            TimeoutResult.Ok { value: value }
        }
    }
}

// Create an async sleep - returns a future that resolves after ms milliseconds
fn async-sleep(ms) {
    async(fn() {
        core/sleep(ms)
        null
    })
}

// Shorthand for awaiting a sleep
fn await-sleep(ms) {
    await(async-sleep(ms))
}

// Get current time in nanoseconds
fn time-now() {
    core/time-now()
}

/// Spawn an async task and return a future.
///
/// The task runs concurrently. Use await to get the result.
///
/// Examples:
///   (let f (spawn fn() { expensive-computation() }))
///   (await f)  ; => result of computation
fn spawn(thunk) {
    perform Async.Spawn { thunk: thunk }
}

// ============================================================================
// Convenience Functions
// ============================================================================

// Read file and unwrap the result
fn read-file!(path) {
    async-unwrap(read-file(path))
}

// Write file and unwrap the result
fn write-file!(path, content) {
    async-unwrap(write-file(path, content))
}

// Check if operation was successful
fn ok?(result) {
    async-ok?(result)
}

// Unwrap result or return default
fn unwrap-or(result, default) {
    async-unwrap-or(result, default)
}

// Create the default async handler
fn default-handler() {
    BlockingAsyncHandler {}
}

// Run a block with the default blocking handler
fn run-blocking(thunk) {
    let handler = BlockingAsyncHandler {}
    handle effect/Handler(Async) with handler {
        thunk()
    }
}

// ============================================================================
// Single-Operation Convenience Functions
// ============================================================================

fn blocking-read-file(path) {
    let handler = BlockingAsyncHandler {}
    handle effect/Handler(Async) with handler {
        read-file(path)
    }
}

fn blocking-write-file(path, content) {
    let handler = BlockingAsyncHandler {}
    handle effect/Handler(Async) with handler {
        write-file(path, content)
    }
}

fn blocking-append-file(path, content) {
    let handler = BlockingAsyncHandler {}
    handle effect/Handler(Async) with handler {
        append-file(path, content)
    }
}

fn blocking-delete-file(path) {
    let handler = BlockingAsyncHandler {}
    handle effect/Handler(Async) with handler {
        delete-file(path)
    }
}

fn blocking-file-exists?(path) {
    let handler = BlockingAsyncHandler {}
    handle effect/Handler(Async) with handler {
        file-exists?(path)
    }
}

fn blocking-read-dir(path) {
    let handler = BlockingAsyncHandler {}
    handle effect/Handler(Async) with handler {
        read-dir(path)
    }
}

fn blocking-create-dir(path) {
    let handler = BlockingAsyncHandler {}
    handle effect/Handler(Async) with handler {
        create-dir(path)
    }
}

fn blocking-remove-dir(path) {
    let handler = BlockingAsyncHandler {}
    handle effect/Handler(Async) with handler {
        remove-dir(path)
    }
}

fn blocking-file-size(path) {
    let handler = BlockingAsyncHandler {}
    handle effect/Handler(Async) with handler {
        file-size(path)
    }
}

fn blocking-is-directory?(path) {
    let handler = BlockingAsyncHandler {}
    handle effect/Handler(Async) with handler {
        is-directory?(path)
    }
}

fn blocking-is-file?(path) {
    let handler = BlockingAsyncHandler {}
    handle effect/Handler(Async) with handler {
        is-file?(path)
    }
}

fn blocking-rename-file(old-path, new-path) {
    let handler = BlockingAsyncHandler {}
    handle effect/Handler(Async) with handler {
        rename-file(old-path, new-path)
    }
}

fn blocking-copy-file(src-path, dest-path) {
    let handler = BlockingAsyncHandler {}
    handle effect/Handler(Async) with handler {
        copy-file(src-path, dest-path)
    }
}

fn blocking-sleep(ms) {
    let handler = BlockingAsyncHandler {}
    handle effect/Handler(Async) with handler {
        sleep(ms)
    }
}

// ============================================================================
// Async Combinators (Legacy - for running thunks)
// ============================================================================

fn run-all-thunks(thunks) {
    let mut results = []
    let mut s = seq(thunks)
    while s != null {
        let thunk = first(s)
        results = push(results, thunk())
        s = next(s)
    }
    results
}

fn await-any(thunks) {
    let mut s = seq(thunks)
    let mut result = null
    let mut found = false
    while s != null && found == false {
        let thunk = first(s)
        let r = thunk()
        if async-ok?(r) {
            result = r
            found = true
        }
        s = next(s)
    }
    result
}

fn map-results(results, f) {
    map(results, fn(r) {
        match r {
            Result.Ok { value } => ok(f(value)),
            Result.Err { error } => r
        }
    })
}

fn filter-ok(results) {
    filter(results, fn(r) { async-ok?(r) })
}

fn unwrap-all(results) {
    map(filter-ok(results), fn(r) {
        match r {
            Result.Ok { value } => value,
            Result.Err { error } => null
        }
    })
}

// ============================================================================
// IO Runtime Support
// ============================================================================
// Global event loop for all IO operations

let __io_loop_atom = atom(null)

// ============================================================================
// TCP Result Type Constants
// ============================================================================
// These constants correspond to the result types returned by core/tcp-result-pop().
// Using named constants instead of magic numbers improves code readability.

let TCP_RESULT_NONE = 0
let TCP_CONNECT_OK = 1
let TCP_CONNECT_ERR = 2
let TCP_ACCEPT_OK = 3
let TCP_ACCEPT_ERR = 4
let TCP_READ_OK = 5
let TCP_READ_ERR = 6
let TCP_WRITE_OK = 7
let TCP_WRITE_ERR = 8

fn get-io-loop() {
    let loop_id = deref(__io_loop_atom)
    if loop_id == null {
        // Use threaded event loop by default for concurrent I/O safety.
        // This prevents deadlocks when multiple threads perform socket I/O
        // concurrently (e.g., server accepting + client connecting).
        let new_loop = core/event-loop-create-threaded(4)
        // Use CAS to avoid race where two threads both see null and both create loops
        let swapped = compare-and-swap!(__io_loop_atom, null, new_loop)
        if swapped {
            new_loop
        } else {
            // Another thread won the race  destroy our loop, use theirs
            core/event-loop-destroy(new_loop)
            deref(__io_loop_atom)
        }
    } else {
        loop_id
    }
}

// Atom to store the threaded IO loop ID (for concurrent I/O)
let __threaded_io_loop_atom = atom(null)

// Get or create a threaded event loop for concurrent I/O operations.
// Use this instead of get-io-loop() when multiple threads need to perform
// socket I/O concurrently (e.g., REPL server with multiple connections).
// The threaded event loop runs I/O polling on a dedicated thread, preventing
// deadlocks that occur when multiple threads block on poll_once().
fn get-io-loop-threaded() {
    let loop_id = deref(__threaded_io_loop_atom)
    if loop_id == null {
        let new_loop = core/event-loop-create-threaded(4)
        // Use CAS to avoid race where two threads both see null and both create loops
        let swapped = compare-and-swap!(__threaded_io_loop_atom, null, new_loop)
        if swapped {
            new_loop
        } else {
            // Another thread won the race  destroy our loop, use theirs
            core/event-loop-destroy(new_loop)
            deref(__threaded_io_loop_atom)
        }
    } else {
        loop_id
    }
}

// ============================================================================
// ImplicitAsyncHandler - the primary production handler for main()
// ============================================================================
// This handler provides the implicit async context for main functions.
// It combines threaded spawn/await (for correct concurrent futures) with
// event-loop-based sleep and async file I/O (for non-blocking operations).
// Automatically wrapped around main() by __main__.

struct ImplicitAsyncHandler {}

// Handle an IO action synchronously (blocking current thread)
fn handle-io-action(action) {
    match action {
        // Listen and Connect create new resources - use the current thread's event loop
        IOAction.TcpListen { host, port } => {
            let loop_id = get-io-loop()
            let listener_id = core/tcp-listen(loop_id, host, port, 128)
            if listener_id < 0 {
                throw("Failed to create TCP listener on " ++ host ++ ":" ++ to-string(port))
            }
            TcpListener { loop_id: loop_id, listener_id: listener_id }
        },

        IOAction.TcpConnect { host, port } => {
            let loop_id = get-io-loop()
            let result_atom = atom(null)
            core/tcp-connect-async(loop_id, host, port, result_atom)

            // Block until notified (timeout=0 means wait forever)
            // Workers notify immediately when connection result is ready
            loop {
                core/event-loop-run-once(loop_id, 0)
                let result_type = core/tcp-result-pop-for-atom(loop_id, result_atom)
                if result_type == TCP_CONNECT_OK {
                    let socket_id = core/tcp-result-value(loop_id)
                    break(TcpSocket { loop_id: loop_id, socket_id: socket_id })
                } else if result_type == TCP_CONNECT_ERR {
                    let error = core/tcp-result-data(loop_id)
                    throw("Connect failed: " ++ error)
                }
            }
        },

        // Accept, Read, Write, Close use the resource's owning event loop
        // so operations go to the correct event loop thread regardless of
        // which thread is calling
        IOAction.TcpAccept { listener } => {
            let loop_id = listener.loop_id
            let result_atom = atom(null)
            core/tcp-accept-async(loop_id, listener.listener_id, result_atom)

            // Block until notified (timeout=0 means wait forever)
            // Workers notify immediately when accept result is ready
            loop {
                core/event-loop-run-once(loop_id, 0)
                let result_type = core/tcp-result-pop-for-atom(loop_id, result_atom)
                if result_type == TCP_ACCEPT_OK {
                    let socket_id = core/tcp-result-value(loop_id)
                    break(TcpSocket { loop_id: loop_id, socket_id: socket_id })
                } else if result_type == TCP_ACCEPT_ERR {
                    let error = core/tcp-result-data(loop_id)
                    throw("Accept failed: " ++ error)
                }
            }
        },

        IOAction.TcpRead { socket, n } => {
            let loop_id = socket.loop_id
            let result_atom = atom(null)
            let read_result = core/tcp-read-async(loop_id, socket.socket_id, n, result_atom)
            if read_result < 0 {
                throw("Failed to start read operation")
            }

            // Block until notified (timeout=0 means wait forever)
            // Workers notify immediately when read result is ready
            loop {
                core/event-loop-run-once(loop_id, 0)
                let result_type = core/tcp-result-pop-for-atom(loop_id, result_atom)
                if result_type == TCP_READ_OK {
                    let data = core/tcp-result-data(loop_id)
                    break(data)
                } else if result_type == TCP_READ_ERR {
                    let error = core/tcp-result-data(loop_id)
                    throw("Read failed: " ++ error)
                }
            }
        },

        IOAction.TcpWrite { socket, data } => {
            let loop_id = socket.loop_id
            let result_atom = atom(null)
            core/tcp-write-async(loop_id, socket.socket_id, data, result_atom)

            // Block until notified (timeout=0 means wait forever)
            // Workers notify immediately when write result is ready
            loop {
                core/event-loop-run-once(loop_id, 0)
                let result_type = core/tcp-result-pop-for-atom(loop_id, result_atom)
                if result_type == TCP_WRITE_OK {
                    let bytes_written = core/tcp-result-value(loop_id)
                    break(bytes_written)
                } else if result_type == TCP_WRITE_ERR {
                    let error = core/tcp-result-data(loop_id)
                    throw("Write failed: " ++ error)
                }
            }
        },

        IOAction.TcpClose { socket } => {
            core/tcp-close(socket.loop_id, socket.socket_id)
            null
        },

        IOAction.TcpCloseListener { listener } => {
            core/tcp-close-listener(listener.loop_id, listener.listener_id)
            null
        }
    }
}

extend ImplicitAsyncHandler with effect/Handler(Async) {
    fn handle(self, op, resume) {
        let result = match op {
            // Core async operations - use threaded await (polls with future-wait)
            Async.Await { future } => {
                handle-await-threaded(future)
            },
            Async.AwaitAll { futures } => {
                handle-await-all-threaded(futures)
            },
            Async.AwaitFirst { futures } => {
                handle-await-first-threaded(futures)
            },
            Async.Cancel { future } => {
                handle-cancel(future)
            },

            // Generic IO operations
            Async.IO { action } => {
                handle-io-action(action)
            },

            // File operations - use async thread pool I/O where available
            Async.ReadFile { path } => {
                handle-read-file-async(get-io-loop(), path)
            },
            Async.WriteFile { path, content } => {
                handle-write-file-async(get-io-loop(), path, content)
            },
            Async.AppendFile { path, content } => {
                handle-append-file-async(get-io-loop(), path, content)
            },
            Async.DeleteFile { path } => {
                handle-delete-file-async(get-io-loop(), path)
            },
            Async.FileExists { path } => {
                handle-file-exists-async(get-io-loop(), path)
            },
            Async.RenameFile { old_path, new_path } => {
                handle-rename-file-async(get-io-loop(), old_path, new_path)
            },
            Async.CopyFile { src_path, dest_path } => {
                handle-copy-file-async(get-io-loop(), src_path, dest_path)
            },
            Async.ReadDir { path } => {
                handle-read-dir-async(get-io-loop(), path)
            },
            Async.CreateDir { path } => {
                handle-create-dir-async(get-io-loop(), path)
            },
            Async.CreateDirAll { path } => {
                handle-create-dir-all-async(get-io-loop(), path)
            },
            Async.RemoveDir { path } => {
                handle-remove-dir-async(get-io-loop(), path)
            },
            Async.RemoveDirAll { path } => {
                handle-remove-dir-all-async(get-io-loop(), path)
            },
            Async.FileSize { path } => {
                handle-file-size-async(get-io-loop(), path)
            },
            Async.IsDirectory { path } => {
                handle-is-directory-async(get-io-loop(), path)
            },
            Async.IsFile { path } => {
                handle-is-file-async(get-io-loop(), path)
            },
            Async.Open { path, mode } => {
                handle-open-async(get-io-loop(), path, mode)
            },
            Async.Close { file } => {
                handle-close-async(get-io-loop(), file)
            },
            Async.Read { file, n } => {
                handle-handle-read-async(get-io-loop(), file, n)
            },
            Async.Write { file, content } => {
                handle-handle-write-async(get-io-loop(), file, content)
            },
            Async.ReadLine { file } => {
                handle-handle-readline-async(get-io-loop(), file)
            },
            Async.Flush { file } => {
                handle-handle-flush-async(get-io-loop(), file)
            },
            Async.Sleep { ms } => {
                handle-sleep-event-loop(get-io-loop(), ms)
            },
            Async.Spawn { thunk } => {
                handle-spawn-threaded(thunk)
            },
            Async.SpawnWithToken { thunk, token } => {
                handle-spawn-with-token-threaded(thunk, token)
            }
        }
        resume(result)
    }
}

// Create the default implicit handler instance
fn create-implicit-handler() {
    ImplicitAsyncHandler {}
}

// Run a block with the implicit async handler
fn with-implicit-async(thunk) {
    let handler = create-implicit-handler()
    handle effect/Handler(Async) with handler {
        thunk()
    }
}

// ============================================================================
// Main Function Wrapper
// ============================================================================
// This function is called by the runtime to wrap main() with the implicit
// async handler. It takes the main function pointer and optional args.
// The runtime checks for beagle.async/__main__ and calls it if present.

fn __main__(main_fn, args) {
    let handler = create-implicit-handler()
    handle effect/Handler(Async) with handler {
        reset {
            if args == null {
                main_fn()
            } else {
                main_fn(args)
            }
        }
    }
}
