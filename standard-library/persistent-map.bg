namespace persistent-map
import "beagle.builtin" as builtin
import "beagle.primitive" as primitive
import "raw-mutable-array" as array
import "persistent-vector" as vec


// TODO: ChatGPT wrote this
// It's bad
// Going to rewrite

struct PersistentMap {
    count
    root
}

struct PairNode {
    key
    val
}

struct BitmapIndexedNode {
    bit-map
    children
}

struct CollisionNode {
    hash
    c
    kv-arr
}

let empty = PersistentMap {
    count: 0
    root: null
}

fn map() {
    empty
}

fn count(pm) {
    pm.count
}

fn mask(h, s) {
    (h >>> s) & 31
}

fn bitpos(x) {
    1 << x
}

fn is-bitmap-indexed-node(n) {
    instance-of(n, BitmapIndexedNode)
}

fn is-collision-node(n) {
    instance-of(n, CollisionNode)
}

fn is-pair-node(n) {
    instance-of(n, PairNode)
}

fn new-pair-node(k, v) {
    PairNode {
        key: k
        val: v
    }
}

fn new-bitmap-indexed-node(bm, child-arr) {
    BitmapIndexedNode {
        bit-map: bm
        children: child-arr
    }
}

fn new-collision-node(h, c, kv-arr) {
    CollisionNode {
        hash: h
        c: c
        kv-arr: kv-arr
    }
}

fn collision-count(n) {
    n.c
}

fn collision-hash(n) {
    n.hash
}

fn node-bitmap(n) {
    n.bit-map
}

fn node-children-array(n) {
    n.children
}

fn collision-key(n, i) {
    array/read-field(n.kv-arr, 2 * i)
}

fn collision-val(n, i) {
    array/read-field(n.kv-arr, 2 * i + 1)
}

fn index-from-bitmap(bm, bit) {
    builtin/pop-count(bm & (bit - 1))
}

fn make-kv-array(k, v) {
    let arr = array/new-array(2)
    array/write-field(arr, 0, k)
    array/write-field(arr, 1, v)
    arr
}

// main entry
fn assoc(pm, k, v) {
    let h = builtin/hash(k)
    if pm.root == null {
        let new-root = new-collision-node(h, 1, make-kv-array(k, v))
        PersistentMap {
            count: 1
            root: new-root
        }
    } else {
        let added-leaf-box = array/new-array(1)
        array/write-field(added-leaf-box, 0, 0)
        let new-root = assoc-node(pm.root, 0, h, k, v, added-leaf-box)
        let old-val = array/read-field(added-leaf-box, 0)
        PersistentMap {
            count: pm.count + (if old-val == 1 { 1 } else { 0 })
            root: new-root
        }
    }
}

fn assoc-node(n, shift, h, k, v, added-leaf-box) {
    if n == null {
        // brand-new node
        assoc-bitmap-node(null, shift, h, k, v, added-leaf-box)
    } else if is-bitmap-indexed-node(n) {
        assoc-bitmap-node(n, shift, h, k, v, added-leaf-box)
    } else if is-collision-node(n) {
        assoc-collision-node(n, shift, h, k, v, added-leaf-box)
    } else if is-pair-node(n) {
        assoc-key-val-node(n, shift, h, k, v, added-leaf-box)
    } else {
        println(n)
        builtin/throw-error()
    }
}

fn assoc-bitmap-node(n, shift, h, k, v, added-leaf-box) {
    if n == null {
        // brand-new single-child node
        let bit = bitpos(mask(h, shift))
        let arr = array/new-array(1)
        array/write-field(arr, 0, new-pair-node(k, v))
        array/write-field(added-leaf-box, 0, 1) // added-leaf-box is not an array
        new-bitmap-indexed-node(bit, arr)
    } else if is-bitmap-indexed-node(n) == false {
        // If n is not actually a BitmapIndexedNode, handle it with assoc-node
        assoc-node(n, shift, h, k, v, added-leaf-box)
    } else {
        // normal path for BitmapIndexedNode
        let bm = node-bitmap(n)
        let bit = bitpos(mask(h, shift))
        let idx = index-from-bitmap(bm, bit)
        let ex = (bm & bit) != 0
        let child-arr = node-children-array(n)
        let sub-n = if ex {
            array/read-field(child-arr, idx)
        } else {
            null
        }
        let new-sub = assoc-node(sub-n, shift + 5, h, k, v, added-leaf-box)
        if ex {
            // replace existing child
            let new-child-arr = array/copy-array(child-arr)
            array/write-field(new-child-arr, idx, new-sub)
            new-bitmap-indexed-node(bm, new-child-arr)
        } else {
            // add a new child
            let new-len = array/count(child-arr) + 1
            let inserted = array/new-array(new-len)
            insert-child(child-arr, inserted, new-sub, idx)
            let new-bm = bm | bit
            new-bitmap-indexed-node(new-bm, inserted)
        }
    }
}

// Insert a single new-node into an array of children at position idx
fn insert-child(old-arr, new-arr, new-node, idx) {
    let l-old = array/count(old-arr)
    copy-prefix(old-arr, new-arr, 0, idx)
    array/write-field(new-arr, idx, new-node)
    copy-suffix(old-arr, new-arr, idx, l-old)
}

fn copy-prefix(old-arr, new-arr, i, limit) {
    if i == limit {
        new-arr
    } else {
        array/write-field(new-arr, i, array/read-field(old-arr, i))
        copy-prefix(old-arr, new-arr, i + 1, limit)
    }
}

fn copy-suffix(old-arr, new-arr, start, l-old) {
    let i = start
    copy-suffix-loop(old-arr, new-arr, i, l-old)
}

fn copy-suffix-loop(old-arr, new-arr, i, l-old) {
    if i == l-old {
        new-arr
    } else {
        array/write-field(new-arr, i + 1, array/read-field(old-arr, i))
        copy-suffix-loop(old-arr, new-arr, i + 1, l-old)
    }
}

// Handling a single PairNode
fn assoc-key-val-node(pair, shift, h, k, v, added-leaf-box) {
    let ek = pair.key
    let ev = pair.val
    let eh = builtin/hash(ek)
    if ek == k {
        // Overwrite existing
        new-pair-node(ek, v)
    } else {
        if eh == h {
            // Same hash -> turn into a CollisionNode
            let new-coll = new-collision-node(h, 2, make-kv-array(ek, ev))
            array/write-field(new-coll.kv-arr, 2, k)
            array/write-field(new-coll.kv-arr, 3, v)
            array/write-field(added-leaf-box, 0, 1)
            new-coll
        } else {
            // Different hash -> create minimal bitmap node for the two distinct keys
            let new-n = assoc-bitmap-node(null, shift, eh, ek, ev, added-leaf-box)
            array/write-field(added-leaf-box, 0, 0)
            assoc-bitmap-node(new-n, shift, h, k, v, added-leaf-box)
        }
    }
}

// Handling a CollisionNode
fn assoc-collision-node(n, shift, h, k, v, added-leaf-box) {
    // If n turned out not to be a CollisionNode for some reason, delegate
    if is-collision-node(n) == false {
        assoc-bitmap-node(n, shift, h, k, v, added-leaf-box)
    } else {
        let nh = collision-hash(n)
        if nh == h {
            let ccount = collision-count(n)
            let idx = find-collision-key-index(n, ccount, k)
            if idx >= 0 {
                // Overwrite existing
                let new-coll = new-collision-node(nh, ccount, array/copy-array(n.kv-arr))
                array/write-field(new-coll.kv-arr, 2 * idx + 1, v)
                new-coll
            } else {
                // Grow collision array
                let new-count = ccount + 1
                let old-kv = n.kv-arr
                let old-len = array/count(old-kv)
                let new-size = old-len + 2
                let new-kv = array/new-array(new-size)
                copy-collision-kv(old-kv, new-kv, 0, old-len)
                array/write-field(new-kv, 2 * ccount, k)
                array/write-field(new-kv, 2 * ccount + 1, v)
                let new-coll = new-collision-node(nh, new-count, new-kv)
                array/write-field(added-leaf-box, 0, 1)
                new-coll
            }
        } else {
            // Convert collision to a bitmap node if hash differs
            convert-collision-to-bitmap(n, shift, h, k, v, added-leaf-box)
        }
    }
}

fn find-collision-key-index(n, ccount, k) {
    find-collision-key-index-loop(n, k, 0, ccount)
}

fn find-collision-key-index-loop(n, k, i, ccount) {
    if i == ccount {
        -1
    } else {
        let kk = collision-key(n, i)
        if kk == k {
            i
        } else {
            find-collision-key-index-loop(n, k, i + 1, ccount)
        }
    }
}

fn copy-collision-kv(old-kv, new-kv, i, limit) {
    if i == limit {
        new-kv
    } else {
        array/write-field(new-kv, i, array/read-field(old-kv, i))
        copy-collision-kv(old-kv, new-kv, i + 1, limit)
    }
}

// Convert collisions to a bitmap node when a new hash doesn't match
fn convert-collision-to-bitmap(n, shift, h, k, v, added-leaf-box) {
    let ccount = collision-count(n)
    if ccount == 1 {
        // easy case: single pair -> create 2 children in a bitmap
        let k0 = collision-key(n, 0)
        let v0 = collision-val(n, 0)
        let h0 = collision-hash(n)
        let new-n = assoc-bitmap-node(null, shift, h0, k0, v0, added-leaf-box)
        array/write-field(added-leaf-box, 0, 0)
        assoc-bitmap-node(new-n, shift, h, k, v, added-leaf-box)
    } else {
        // build a small bitmap node with up to 2 children
        let node-h = collision-hash(n)
        let sub-index1 = mask(node-h, shift)
        let sub-index2 = mask(h, shift)
        let bit1 = bitpos(sub-index1)
        let bit2 = bitpos(sub-index2)
        let combo = bit1 | bit2
        let child-size = if bit1 == bit2 { 1 } else { 2 }
        let child-arr = array/new-array(child-size)

        if sub-index1 == sub-index2 {
            // same bit -> keep collisions together
            let new-coll = new-collision-node(node-h, collision-count(n), extract-pairs(n))
            array/write-field(box_, 0, 1)
            let updated = assoc-collision-node(new-coll, shift + 5, builtin/hash(k), k, v, box_)
            array/write-field(child-arr, 0, updated)
            child-arr
        } else {
            // distinct bits -> 2 children
            if s1 < s2 {
                array/write-field(child-arr, 0, n)
                let nc = new-collision-node(builtin/hash(k), 1, make-kv-array(k, v))
                array/write-field(child-arr, 1, nc)
                array/write-field(box_, 0, 0)
                child-arr
            } else {
                let nc = new-collision-node(builtin/hash(k), 1, make-kv-array(k, v))
                array/write-field(child-arr, 0, nc)
                array/write-field(child-arr, 1, n)
                array/write-field(box_, 0, 0)
                child-arr
            }
        }
        new-bitmap-indexed-node(combo, child-arr)
    }
}


fn extract-pairs(n) {
    let ccount = collision-count(n)
    let pc = 2 * ccount
    let out = array/new-array(pc)
    copy-collision-array-no-hdr(n, out, ccount, 0)
}

fn copy-collision-array-no-hdr(n, out, ccount, i) {
    if i == ccount {
        out
    } else {
        array/write-field(out, 2 * i, collision-key(n, i))
        array/write-field(out, 2 * i + 1, collision-val(n, i))
        copy-collision-array-no-hdr(n, out, ccount, i + 1)
    }
}

// lookup
fn _get(pm, k) {
    if pm.root == null {
        null
    } else {
        let h = builtin/hash(k)
        find-node(pm.root, k, h, 0)
    }
}

extend PersistentMap with Indexed {
    fn get(map, index) {
        _get(map, index)
    }
}

extend PersistentMap with Length {
    fn length(map) {
        count(map)
    }
}


fn find-node(n, k, h, shift) {
    if n == null {
        null
    } else if is-bitmap-indexed-node(n) {
        find-bitmap-node(n, k, h, shift)
    } else if is-collision-node(n) {
        find-collision-node(n, k, h)
    } else if is-pair-node(n) {
        let ck = n.key
        let cv = n.val
        if k == ck {
            cv
        } else {
            null
        }
    } else {
        // fallback
        null
    }
}

fn find-bitmap-node(n, k, h, shift) {
    let bm = node-bitmap(n)
    let bit = bitpos(mask(h, shift))
    if (bm & bit) == 0 {
        null
    } else {
        let idx = index-from-bitmap(bm, bit)
        let child = array/read-field(n.children, idx)
        find-node(child, k, h, shift + 5)
    }
}

fn find-collision-node(n, k, h) {
    let nh = collision-hash(n)
    if nh == h {
        let ccount = collision-count(n)
        lookup-collision(n, k, 0, ccount)
    } else {
        null
    }
}

fn lookup-collision(n, k, i, ccount) {
    if i == ccount {
        null
    } else {
        let ck = collision-key(n, i)
        let cv = collision-val(n, i)
        if ck == k {
            cv
        } else {
            lookup-collision(n, k, i + 1, ccount)
        }
    }
}

fn insert-many(pm, i, max) {
    if i == max {
        pm
    } else {
        let pm2 = assoc(pm, i, i)
        insert-many(pm2, i + 1, max)
    }
}

fn _keys(pm) {
    // TODO: Make this a vec not an array
    let keys-array = array/new-array(pm.count)
    if pm.root != null {
        collect-keys(pm.root, keys-array, 0)
    }
    vec/from-array(keys-array)
}

fn collect-keys(n, keys-array, idx) {
    if is-bitmap-indexed-node(n) {
        let children = node-children-array(n)
        let len = array/count(children)
        collect-keys-bitmap(children, keys-array, idx, len, 0)
    } else if is-collision-node(n) {
        let ccount = collision-count(n)
        collect-keys-collision(n, keys-array, idx, ccount)
    } else if is-pair-node(n) {
        array/write-field(keys-array, idx, n.key)
        idx + 1
    } else {
        idx
    }
}

fn collect-keys-bitmap(children, keys-array, idx, len, i) {
    if i == len {
        idx
    } else {
        let child = array/read-field(children, i)
        let new-idx = collect-keys(child, keys-array, idx)
        collect-keys-bitmap(children, keys-array, new-idx, len, i + 1)
    }
}

fn collect-keys-collision(n, keys-array, idx, ccount) {
    if ccount == 0 {
        idx
    } else {
        let key = collision-key(n, 0)
        array/write-field(keys-array, idx, key)
        collect-keys-collision(n, keys-array, idx + 1, ccount - 1)
    }
}

extend PersistentMap with Keys {
    fn keys(map) {
        _keys(map)
    }
}


extend PersistentMap with Format {
    fn format(map, depth) {
        if map.count == 0 {
            "{}"
        } else {
            let keys-vec = keys(map)
            format-entries(map, keys-vec, 0, "{")
        }
    }
}

extend PersistentMap with Associable {
    fn assoc(map, key, value) {
        assoc(map, key, value)
    }
}

fn format-entries(map, keys-vec, idx, acc) {
    if idx >= count(keys-vec) {
        acc ++ "}"
    } else {
        let key = get(keys-vec, idx)
        let val = get(map, key)

        let key-str = format(key, 1)
        let val-str = format(val, 1)

        let entry = key-str ++ ": " ++ val-str

        // Add comma if not the last entry
        let new-acc = if idx == 0 {
            acc ++ entry
        } else {
            acc ++ ", " ++ entry
        }

        format-entries(map, keys-vec, idx + 1, new-acc)
    }
}

fn main() {

    let pm = map()
    println(pm)

    let pm2 = assoc(pm, "foo", 1)
    println(get(pm2, "foo"))
    println(count(pm2))

    let pm3 = assoc(pm2, "bar", 100)
    println(get(pm3, "foo"))
    println(get(pm3, "bar"))
    println(count(pm3))

    let pm4 = assoc(pm3, "bar", 101)
    println(get(pm4, "bar"))
    println(count(pm4))

    let pm5 = assoc(pm4, "baz", 999)
    let pm6 = assoc(pm5, "qux", 777)
    println(get(pm6, "baz"))
    println(get(pm6, "qux"))
    println(count(pm6))

    let val-missing = get(pm6, "no-such-key")
    println(val-missing)

    let times = 10
    let pm7 = insert-many(pm6, 0, times)
    println(count(pm7))

    println(get(pm7, 0))
    println(get(pm7, 9))
    println(get(pm7, 999))
    let keys-vec = keys(pm6)
    println(keys-vec) // Print all keys
    println(format(pm6, 0)) // Print all entries
    "done"
}



// Expect
// {}
// 1
// 1
// 1
// 100
// 2
// 101
// 2
// 999
// 777
// 4
// null
// 14
// 0
// 9
// null
// ["baz", "qux", "bar", "foo"]
// {"baz": 999, "qux": 777, "bar": 101, "foo": 1}
// done
