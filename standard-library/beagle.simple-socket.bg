namespace beagle.simple-socket

// ============================================================================
// Simple Socket API - Continuation-Based Concurrent I/O
// ============================================================================
// Uses shift/reset to capture continuation at listen, then runs it inside
// ContinuationHandler where accept is multi-shot and read/write are single-shot.
//
// Example:
//   let server = socket/listen("0.0.0.0", 8888)
//   let client = socket/accept(server)  // everything after is per-client
//   loop {
//       let data = socket/read(client, 1024)
//       if length(data) == 0 { break(null) }
//       socket/write(client, data)
//   }

use beagle.async as async
use beagle.effect as effect

// ============================================================================
// ContinuationHandler - Single-Threaded Concurrent I/O
// ============================================================================
// Accept is multi-shot (invoked per client), read/write are single-shot.

struct ContinuationHandler {
    loop_id
    accept_continuations   // atom({ listener_id: k }) - multi-shot
    pending_ops            // atom({ op_id: k })       - single-shot
}

fn create-continuation-handler(loop_id) {
    ContinuationHandler {
        loop_id: loop_id,
        accept_continuations: atom({}),
        pending_ops: atom({})
    }
}

// Drive the event loop, dispatching to continuations when I/O completes
fn drive-continuation-loop(handler) {
    loop {
        event-loop-run-once(handler.loop_id, 50)

        // Process all pending results
        loop {
            let result_type = tcp-result-pop(handler.loop_id)
            if result_type == 0 { break(null) }

            let op_id = tcp-result-op-id(handler.loop_id)

            if result_type == 3 {
                // AcceptOk - multi-shot continuation
                let listener_id = tcp-result-listener-id(handler.loop_id)
                let socket_id = tcp-result-value(handler.loop_id)
                let client = async/TcpSocket { loop_id: handler.loop_id, socket_id: socket_id }

                // Get continuation but DON'T remove it (multi-shot)
                let conts = deref(handler.accept_continuations)
                let k = get(conts, listener_id)

                if k != null {
                    // Re-register accept for next client BEFORE invoking k
                    tcp-accept-async(handler.loop_id, listener_id, atom(null))

                    // Invoke continuation with client
                    k(client)
                }
            } else if result_type == 4 {
                // AcceptErr
                let error = tcp-result-data(handler.loop_id)
                println("Accept error:", error)
            } else if result_type == 5 {
                // ReadOk - single-shot continuation
                let data = tcp-result-data(handler.loop_id)

                let pending = deref(handler.pending_ops)
                let k = get(pending, op_id)
                if k != null {
                    reset!(handler.pending_ops, dissoc(pending, op_id))
                    k(data)
                }
            } else if result_type == 6 {
                // ReadErr
                let pending = deref(handler.pending_ops)
                let k = get(pending, op_id)
                if k != null {
                    reset!(handler.pending_ops, dissoc(pending, op_id))
                    k("")
                }
            } else if result_type == 7 {
                // WriteOk - single-shot continuation
                let bytes_written = tcp-result-value(handler.loop_id)

                let pending = deref(handler.pending_ops)
                let k = get(pending, op_id)
                if k != null {
                    reset!(handler.pending_ops, dissoc(pending, op_id))
                    k(bytes_written)
                }
            } else if result_type == 8 {
                // WriteErr
                let pending = deref(handler.pending_ops)
                let k = get(pending, op_id)
                if k != null {
                    reset!(handler.pending_ops, dissoc(pending, op_id))
                    k(0)
                }
            }
        }

        // Keep running while there are pending operations
        let has_accepts = length(keys(deref(handler.accept_continuations))) > 0
        let has_pending = length(keys(deref(handler.pending_ops))) > 0
        if not(has_accepts) && not(has_pending) {
            break(null)
        }
    }
}

extend ContinuationHandler with effect/Handler(async/Async) {
    fn handle(self, op, resume) {
        match op {
            async/Async.IO { action } => {
                match action {
                    async/IOAction.TcpListen { host, port } => {
                        let listener_id = tcp-listen(self.loop_id, host, port, 128)
                        if listener_id < 0 {
                            throw("Failed to create TCP listener on " ++ host ++ ":" ++ to-string(port))
                        }
                        resume(async/TcpListener { loop_id: self.loop_id, listener_id: listener_id })
                    },

                    async/IOAction.TcpAccept { listener } => {
                        // Multi-shot: capture continuation, start accept, drive event loop
                        let conts = deref(self.accept_continuations)
                        reset!(self.accept_continuations, assoc(conts, listener.listener_id, resume))

                        tcp-accept-async(self.loop_id, listener.listener_id, atom(null))
                        drive-continuation-loop(self)
                        null
                    },

                    async/IOAction.TcpRead { socket, n } => {
                        // Single-shot: capture continuation, start read, return to event loop
                        let op_id = tcp-read-async(self.loop_id, socket.socket_id, n, atom(null))
                        let pending = deref(self.pending_ops)
                        reset!(self.pending_ops, assoc(pending, op_id, resume))
                        null
                    },

                    async/IOAction.TcpWrite { socket, data } => {
                        // Single-shot: capture continuation, start write, return to event loop
                        let op_id = tcp-write-async(self.loop_id, socket.socket_id, data, atom(null))
                        let pending = deref(self.pending_ops)
                        reset!(self.pending_ops, assoc(pending, op_id, resume))
                        null
                    },

                    async/IOAction.TcpClose { socket } => {
                        tcp-close(self.loop_id, socket.socket_id)
                        resume(null)
                    },

                    async/IOAction.TcpCloseListener { listener } => {
                        tcp-close-listener(self.loop_id, listener.listener_id)
                        let conts = deref(self.accept_continuations)
                        reset!(self.accept_continuations, dissoc(conts, listener.listener_id))
                        resume(null)
                    },

                    async/IOAction.TcpConnect { host, port } => {
                        // Client connect - delegate to standard handler
                        let socket = async/handle-io-action(action)
                        resume(socket)
                    }
                }
            },

            // For other async ops, use blocking behavior
            _ => {
                let result = async/handle-io-action(op)
                resume(result)
            }
        }
    }
}

// ============================================================================
// Public API
// ============================================================================

// Create listener and capture continuation to run in ContinuationHandler
fn listen(host, port) {
    shift(fn(k) {
        let loop_id = async/get-io-loop()
        let listener_id = tcp-listen(loop_id, host, port, 128)
        if listener_id < 0 {
            throw("Failed to create TCP listener on " ++ host ++ ":" ++ to-string(port))
        }
        let listener = async/TcpListener { loop_id: loop_id, listener_id: listener_id }

        // Run continuation inside ContinuationHandler
        let cont_handler = create-continuation-handler(loop_id)
        handle effect/Handler(async/Async) with cont_handler {
            k(listener)
        }
    })
}

// Accept - multi-shot, invoked per client
fn accept(listener) {
    perform async/Async.IO {
        action: async/IOAction.TcpAccept { listener: listener }
    }
}

// Read - single-shot
fn read(client, n) {
    perform async/Async.IO {
        action: async/IOAction.TcpRead { socket: client, n: n }
    }
}

// Write - single-shot
fn write(client, data) {
    perform async/Async.IO {
        action: async/IOAction.TcpWrite { socket: client, data: data }
    }
}

fn close(client) {
    perform async/Async.IO {
        action: async/IOAction.TcpClose { socket: client }
    }
}
