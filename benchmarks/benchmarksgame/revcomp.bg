namespace revcomp

// The Computer Language Benchmarks Game
// https://salsa.debian.org/benchmarksgame-team/benchmarksgame/
//
// Beagle implementation - fast single-threaded version
// Uses bulk native operations for parsing

use beagle.ffi as ffi
use beagle.io as io
use raw-mutable-array as arr

let LINE_WIDTH = 60
let READ_CHUNK = 65536
let INITIAL_SEQ_SIZE = 1048576

// State array indices
let STATE_SEQ_BUF = 0
let STATE_SEQ_LEN = 1
let STATE_SEQ_CAP = 2
let STATE_TBL = 3

// Build complement lookup table (256 entries)
fn make_complement_table() {
    let tbl = ffi/allocate(256)
    let mut i = 0
    while i < 256 {
        ffi/set-u8(tbl, i, i)
        i = i + 1
    }

    // A <-> T
    ffi/set-u8(tbl, 65, 84)
    ffi/set-u8(tbl, 97, 84)
    ffi/set-u8(tbl, 84, 65)
    ffi/set-u8(tbl, 116, 65)
    // C <-> G
    ffi/set-u8(tbl, 67, 71)
    ffi/set-u8(tbl, 99, 71)
    ffi/set-u8(tbl, 71, 67)
    ffi/set-u8(tbl, 103, 67)
    // U -> A
    ffi/set-u8(tbl, 85, 65)
    ffi/set-u8(tbl, 117, 65)
    // M <-> K
    ffi/set-u8(tbl, 77, 75)
    ffi/set-u8(tbl, 109, 75)
    ffi/set-u8(tbl, 75, 77)
    ffi/set-u8(tbl, 107, 77)
    // R <-> Y
    ffi/set-u8(tbl, 82, 89)
    ffi/set-u8(tbl, 114, 89)
    ffi/set-u8(tbl, 89, 82)
    ffi/set-u8(tbl, 121, 82)
    // W <-> W
    ffi/set-u8(tbl, 87, 87)
    ffi/set-u8(tbl, 119, 87)
    // S <-> S
    ffi/set-u8(tbl, 83, 83)
    ffi/set-u8(tbl, 115, 83)
    // V <-> B
    ffi/set-u8(tbl, 86, 66)
    ffi/set-u8(tbl, 118, 66)
    ffi/set-u8(tbl, 66, 86)
    ffi/set-u8(tbl, 98, 86)
    // H <-> D
    ffi/set-u8(tbl, 72, 68)
    ffi/set-u8(tbl, 104, 68)
    ffi/set-u8(tbl, 68, 72)
    ffi/set-u8(tbl, 100, 72)
    // N <-> N
    ffi/set-u8(tbl, 78, 78)
    ffi/set-u8(tbl, 110, 78)

    tbl
}

// Ensure sequence buffer has enough capacity
fn ensure_capacity(state, needed) {
    let seq_len = arr/read-field(state, STATE_SEQ_LEN)
    let current_cap = arr/read-field(state, STATE_SEQ_CAP)

    if seq_len + needed > current_cap {
        let seq_buf = arr/read-field(state, STATE_SEQ_BUF)
        let mut new_cap = current_cap * 2
        while new_cap < seq_len + needed {
            new_cap = new_cap * 2
        }
        let new_buf = ffi/realloc(seq_buf, new_cap)
        arr/write-field(state, STATE_SEQ_BUF, new_buf)
        arr/write-field(state, STATE_SEQ_CAP, new_cap)
    }
    null
}

// Output sequence with 60-char line wrapping (buffered)
fn output_sequence_wrapped(seq_buf, seq_len) {
    // Use larger output buffer to reduce syscalls
    let out_buf_size = 65536
    let out_buf = ffi/allocate(out_buf_size)
    let mut out_pos = 0
    let mut pos = 0

    while pos < seq_len {
        let remaining = seq_len - pos
        let line_len = if remaining < LINE_WIDTH { remaining } else { LINE_WIDTH }

        // Check if we need to flush
        if out_pos + line_len + 1 > out_buf_size {
            io/write-stdout-buffer(out_buf, out_pos)
            out_pos = 0
        }

        // Copy line to output buffer
        ffi/copy-bytes(seq_buf, pos, out_buf, out_pos, line_len)
        out_pos = out_pos + line_len
        ffi/set-u8(out_buf, out_pos, 10)
        out_pos = out_pos + 1

        pos = pos + LINE_WIDTH
    }

    // Flush remaining
    if out_pos > 0 {
        io/write-stdout-buffer(out_buf, out_pos)
    }

    ffi/deallocate(out_buf)
    null
}

// Process and output current sequence (reverse complement)
fn flush_sequence(state) {
    let seq_len = arr/read-field(state, STATE_SEQ_LEN)
    if seq_len > 0 {
        let seq_buf = arr/read-field(state, STATE_SEQ_BUF)
        let tbl = arr/read-field(state, STATE_TBL)
        // Bulk translate + reverse
        ffi/translate-bytes(seq_buf, 0, seq_len, tbl)
        ffi/reverse-bytes(seq_buf, 0, seq_len)
        output_sequence_wrapped(seq_buf, seq_len)
    }
    arr/write-field(state, STATE_SEQ_LEN, 0)
    null
}

fn new_state(tbl) {
    let state = arr/new-array(4)
    arr/write-field(state, STATE_SEQ_BUF, ffi/allocate(INITIAL_SEQ_SIZE))
    arr/write-field(state, STATE_SEQ_LEN, 0)
    arr/write-field(state, STATE_SEQ_CAP, INITIAL_SEQ_SIZE)
    arr/write-field(state, STATE_TBL, tbl)
    state
}

// Output header from buffer range
fn output_header_range(buf, start, end_pos) {
    let len = end_pos - start
    let header_buf = ffi/allocate(len + 1)
    ffi/copy-bytes(buf, start, header_buf, 0, len)
    ffi/set-u8(header_buf, len, 10)
    io/write-stdout-buffer(header_buf, len + 1)
    ffi/deallocate(header_buf)
    null
}

// Process a chunk of input using bulk operations
fn process_chunk(state, input_buf, chunk_len) {
    let mut pos = 0

    while pos < chunk_len {
        // Find next '>' marker
        let marker_pos = ffi/find-byte(input_buf, pos, chunk_len - pos, 62)

        if marker_pos == -1 {
            // No '>' found - rest is sequence data
            // Copy to seq_buf, filtering out newlines
            ensure_capacity(state, chunk_len - pos)
            let seq_buf = arr/read-field(state, STATE_SEQ_BUF)
            let seq_len = arr/read-field(state, STATE_SEQ_LEN)
            let written = ffi/copy-bytes_filter(input_buf, pos, seq_buf, seq_len, chunk_len - pos, 10)
            arr/write-field(state, STATE_SEQ_LEN, seq_len + written)
            pos = chunk_len
        } else {
            // Found '>' at marker_pos
            // First, copy any sequence data before the marker
            if marker_pos > pos {
                ensure_capacity(state, marker_pos - pos)
                let seq_buf = arr/read-field(state, STATE_SEQ_BUF)
                let seq_len = arr/read-field(state, STATE_SEQ_LEN)
                let written = ffi/copy-bytes_filter(input_buf, pos, seq_buf, seq_len, marker_pos - pos, 10)
                arr/write-field(state, STATE_SEQ_LEN, seq_len + written)
            }

            // Flush previous sequence
            flush_sequence(state)

            // Find end of header line (newline after '>')
            let newline_pos = ffi/find-byte(input_buf, marker_pos, chunk_len - marker_pos, 10)

            if newline_pos == -1 {
                // Header continues to next chunk - just output what we have
                output_header_range(input_buf, marker_pos, chunk_len)
                pos = chunk_len
            } else {
                // Output complete header
                output_header_range(input_buf, marker_pos, newline_pos)
                pos = newline_pos + 1
            }
        }
    }
    null
}

// Main entry point
fn main() {
    let tbl = make_complement_table()
    let state = new_state(tbl)

    let mut done = false
    while done == false {
        let result = io/read-stdin(READ_CHUNK)
        match result {
            Result.Ok { value } => {
                if value.length == 0 {
                    done = true
                } else {
                    process_chunk(state, value.buffer, value.length)
                    ffi/deallocate(value.buffer)
                }
            },
            Result.Err { error } => {
                done = true
            }
        }
    }

    // Flush final sequence
    flush_sequence(state)

    // Cleanup
    let seq_buf = arr/read-field(state, STATE_SEQ_BUF)
    ffi/deallocate(seq_buf)
    ffi/deallocate(tbl)

    ""
}
