namespace nbody

// The Computer Language Benchmarks Game
// https://salsa.debian.org/benchmarksgame-team/benchmarksgame/
//
// Beagle implementation of the N-body simulation
// Uses mutable structs and arrays to avoid allocation in the hot loop

use beagle.mutable-array as arr

let PI = 3.141592653589793
let SOLAR_MASS = 39.47841760435743
let DAYS_PER_YEAR = 365.24

struct Body {
    mut x
    mut y
    mut z
    mut vx
    mut vy
    mut vz
    mass
}

// Sun
fn sun() {
    Body {
        x: 0.0,
        y: 0.0,
        z: 0.0,
        vx: 0.0,
        vy: 0.0,
        vz: 0.0,
        mass: SOLAR_MASS
    }
}

// Jupiter
fn jupiter() {
    Body {
        x: 4.84143144246472090,
        y: 0.0 - 1.16032004402742839,
        z: 0.0 - 0.103622044471123109,
        vx: 0.00166007664274403694 * DAYS_PER_YEAR,
        vy: 0.00769901118419740425 * DAYS_PER_YEAR,
        vz: (0.0 - 0.0000690460016972063023) * DAYS_PER_YEAR,
        mass: 0.000954791938424326609 * SOLAR_MASS
    }
}

// Saturn
fn saturn() {
    Body {
        x: 8.34336671824457987,
        y: 4.12479856412430479,
        z: 0.0 - 0.403523417114321381,
        vx: (0.0 - 0.00276742510726862411) * DAYS_PER_YEAR,
        vy: 0.00499852801234917238 * DAYS_PER_YEAR,
        vz: 0.0000230417297573763929 * DAYS_PER_YEAR,
        mass: 0.000285885980666130812 * SOLAR_MASS
    }
}

// Uranus
fn uranus() {
    Body {
        x: 12.8943695621391310,
        y: 0.0 - 15.1111514016986312,
        z: 0.0 - 0.223307578892655734,
        vx: 0.00296460137564761618 * DAYS_PER_YEAR,
        vy: 0.00237847173959480950 * DAYS_PER_YEAR,
        vz: (0.0 - 0.0000296589568540237556) * DAYS_PER_YEAR,
        mass: 0.0000436624404335156298 * SOLAR_MASS
    }
}

// Neptune
fn neptune() {
    Body {
        x: 15.3796971148509165,
        y: 0.0 - 25.9193146099879641,
        z: 0.179258772950371181,
        vx: 0.00268067772490389322 * DAYS_PER_YEAR,
        vy: 0.00162824170038242295 * DAYS_PER_YEAR,
        vz: (0.0 - 0.0000951592254519715870) * DAYS_PER_YEAR,
        mass: 0.0000515138902046611451 * SOLAR_MASS
    }
}

fn offset_momentum(bodies, n) {
    let mut px = 0.0
    let mut py = 0.0
    let mut pz = 0.0
    let mut i = 0
    while i < n {
        let b = arr/read-field(bodies, i)
        px = px + b.vx * b.mass
        py = py + b.vy * b.mass
        pz = pz + b.vz * b.mass
        i = i + 1
    }
    let s = arr/read-field(bodies, 0)
    s.vx = (0.0 - px) / SOLAR_MASS
    s.vy = (0.0 - py) / SOLAR_MASS
    s.vz = (0.0 - pz) / SOLAR_MASS
}

fn advance(bodies, n, dt) {
    // Update velocities
    let mut i = 0
    while i < n {
        let bi = arr/read-field(bodies, i)
        let mut j = i + 1
        while j < n {
            let bj = arr/read-field(bodies, j)
            let dx = bi.x - bj.x
            let dy = bi.y - bj.y
            let dz = bi.z - bj.z
            let dist_sq = dx * dx + dy * dy + dz * dz
            let distance = sqrt(dist_sq)
            let mag = dt / (dist_sq * distance)

            bi.vx = bi.vx - dx * bj.mass * mag
            bi.vy = bi.vy - dy * bj.mass * mag
            bi.vz = bi.vz - dz * bj.mass * mag
            bj.vx = bj.vx + dx * bi.mass * mag
            bj.vy = bj.vy + dy * bi.mass * mag
            bj.vz = bj.vz + dz * bi.mass * mag

            j = j + 1
        }
        i = i + 1
    }

    // Update positions
    i = 0
    while i < n {
        let b = arr/read-field(bodies, i)
        b.x = b.x + dt * b.vx
        b.y = b.y + dt * b.vy
        b.z = b.z + dt * b.vz
        i = i + 1
    }
}

fn energy(bodies, n) {
    let mut e = 0.0
    let mut i = 0
    while i < n {
        let b = arr/read-field(bodies, i)
        e = e + 0.5 * b.mass * (b.vx * b.vx + b.vy * b.vy + b.vz * b.vz)
        let mut j = i + 1
        while j < n {
            let bj = arr/read-field(bodies, j)
            let dx = b.x - bj.x
            let dy = b.y - bj.y
            let dz = b.z - bj.z
            let distance = sqrt(dx * dx + dy * dy + dz * dz)
            e = e - (b.mass * bj.mass) / distance
            j = j + 1
        }
        i = i + 1
    }
    e
}

// Format float to 9 decimal places (matches benchmarksgame output format)
fn print-fixed9(x) {
    if x < 0.0 {
        print("-")
        print-fixed9(0.0 - x)
    } else {
        let int-part = to-int(x)
        let frac = x - to-float(int-part)
        let frac-scaled = to-int(round(frac * 1000000000.0))
        print(int-part)
        print(".")
        print-padded9(frac-scaled)
        println("")
    }
}

fn print-padded9(n) {
    if n < 10 { print("00000000") }
    else if n < 100 { print("0000000") }
    else if n < 1000 { print("000000") }
    else if n < 10000 { print("00000") }
    else if n < 100000 { print("0000") }
    else if n < 1000000 { print("000") }
    else if n < 10000000 { print("00") }
    else if n < 100000000 { print("0") }
    print(n)
}

fn run(n) {
    let bodies = arr/new-array(5)
    arr/write-field(bodies, 0, sun())
    arr/write-field(bodies, 1, jupiter())
    arr/write-field(bodies, 2, saturn())
    arr/write-field(bodies, 3, uranus())
    arr/write-field(bodies, 4, neptune())

    offset_momentum(bodies, 5)
    print-fixed9(energy(bodies, 5))

    let mut step = 0
    while step < n {
        advance(bodies, 5, 0.01)
        step = step + 1
    }

    print-fixed9(energy(bodies, 5))
}

fn main(args) {
    let n = if length(args) > 0 { to-number(get(args, 0)) } else { 1000 }
    run(n)
}
