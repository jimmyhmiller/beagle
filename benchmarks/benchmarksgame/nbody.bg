namespace nbody

// The Computer Language Benchmarks Game
// https://salsa.debian.org/benchmarksgame-team/benchmarksgame/
//
// Beagle implementation of the N-body simulation

let PI = 3.141592653589793
let SOLAR_MASS = 39.47841760435743
let DAYS_PER_YEAR = 365.24

struct Body {
    x
    y
    z
    vx
    vy
    vz
    mass
}

// Sun
fn sun() {
    Body {
        x: 0.0,
        y: 0.0,
        z: 0.0,
        vx: 0.0,
        vy: 0.0,
        vz: 0.0,
        mass: SOLAR_MASS
    }
}

// Jupiter
fn jupiter() {
    Body {
        x: 4.84143144246472090,
        y: 0.0 - 1.16032004402742839,
        z: 0.0 - 0.103622044471123109,
        vx: 0.00166007664274403694 * DAYS_PER_YEAR,
        vy: 0.00769901118419740425 * DAYS_PER_YEAR,
        vz: (0.0 - 0.0000690460016972063023) * DAYS_PER_YEAR,
        mass: 0.000954791938424326609 * SOLAR_MASS
    }
}

// Saturn
fn saturn() {
    Body {
        x: 8.34336671824457987,
        y: 4.12479856412430479,
        z: 0.0 - 0.403523417114321381,
        vx: (0.0 - 0.00276742510726862411) * DAYS_PER_YEAR,
        vy: 0.00499852801234917238 * DAYS_PER_YEAR,
        vz: 0.0000230417297573763929 * DAYS_PER_YEAR,
        mass: 0.000285885980666130812 * SOLAR_MASS
    }
}

// Uranus
fn uranus() {
    Body {
        x: 12.8943695621391310,
        y: 0.0 - 15.1111514016986312,
        z: 0.0 - 0.223307578892655734,
        vx: 0.00296460137564761618 * DAYS_PER_YEAR,
        vy: 0.00237847173959480950 * DAYS_PER_YEAR,
        vz: (0.0 - 0.0000296589568540237556) * DAYS_PER_YEAR,
        mass: 0.0000436624404335156298 * SOLAR_MASS
    }
}

// Neptune
fn neptune() {
    Body {
        x: 15.3796971148509165,
        y: 0.0 - 25.9193146099879641,
        z: 0.179258772950371181,
        vx: 0.00268067772490389322 * DAYS_PER_YEAR,
        vy: 0.00162824170038242295 * DAYS_PER_YEAR,
        vz: (0.0 - 0.0000951592254519715870) * DAYS_PER_YEAR,
        mass: 0.0000515138902046611451 * SOLAR_MASS
    }
}

fn offset_momentum(sun, bodies, n) {
    let result = sum_momentum(bodies, n, 0, 0.0, 0.0, 0.0)
    Body {
        x: sun.x,
        y: sun.y,
        z: sun.z,
        vx: (0.0 - result.px) / SOLAR_MASS,
        vy: (0.0 - result.py) / SOLAR_MASS,
        vz: (0.0 - result.pz) / SOLAR_MASS,
        mass: sun.mass
    }
}

struct Momentum {
    px
    py
    pz
}

fn sum_momentum(bodies, n, i, px, py, pz) {
    if i >= n {
        Momentum { px: px, py: py, pz: pz }
    } else {
        let b = get_body(bodies, i)
        sum_momentum(bodies, n, i + 1,
            px + b.vx * b.mass,
            py + b.vy * b.mass,
            pz + b.vz * b.mass)
    }
}

fn get_body(bodies, i) {
    if i == 0 { bodies.b0 }
    else if i == 1 { bodies.b1 }
    else if i == 2 { bodies.b2 }
    else if i == 3 { bodies.b3 }
    else { bodies.b4 }
}

fn set_body(bodies, i, b) {
    if i == 0 { Bodies { b0: b, b1: bodies.b1, b2: bodies.b2, b3: bodies.b3, b4: bodies.b4 } }
    else if i == 1 { Bodies { b0: bodies.b0, b1: b, b2: bodies.b2, b3: bodies.b3, b4: bodies.b4 } }
    else if i == 2 { Bodies { b0: bodies.b0, b1: bodies.b1, b2: b, b3: bodies.b3, b4: bodies.b4 } }
    else if i == 3 { Bodies { b0: bodies.b0, b1: bodies.b1, b2: bodies.b2, b3: b, b4: bodies.b4 } }
    else { Bodies { b0: bodies.b0, b1: bodies.b1, b2: bodies.b2, b3: bodies.b3, b4: b } }
}

struct Bodies {
    b0
    b1
    b2
    b3
    b4
}

fn advance(bodies, n, dt) {
    advance_velocities(bodies, n, dt, 0)
}

fn advance_velocities(bodies, n, dt, i) {
    if i >= n {
        advance_positions(bodies, n, dt, 0)
    } else {
        let new_bodies = advance_velocity_pairs(bodies, n, dt, i, i + 1)
        advance_velocities(new_bodies, n, dt, i + 1)
    }
}

fn advance_velocity_pairs(bodies, n, dt, i, j) {
    if j >= n {
        bodies
    } else {
        let bi = get_body(bodies, i)
        let bj = get_body(bodies, j)
        let dx = bi.x - bj.x
        let dy = bi.y - bj.y
        let dz = bi.z - bj.z
        let dist_sq = dx * dx + dy * dy + dz * dz
        let distance = sqrt(dist_sq)
        let mag = dt / (dist_sq * distance)

        let new_bi = Body {
            x: bi.x, y: bi.y, z: bi.z,
            vx: bi.vx - dx * bj.mass * mag,
            vy: bi.vy - dy * bj.mass * mag,
            vz: bi.vz - dz * bj.mass * mag,
            mass: bi.mass
        }
        let new_bj = Body {
            x: bj.x, y: bj.y, z: bj.z,
            vx: bj.vx + dx * bi.mass * mag,
            vy: bj.vy + dy * bi.mass * mag,
            vz: bj.vz + dz * bi.mass * mag,
            mass: bj.mass
        }

        let bodies2 = set_body(bodies, i, new_bi)
        let bodies3 = set_body(bodies2, j, new_bj)
        advance_velocity_pairs(bodies3, n, dt, i, j + 1)
    }
}

fn advance_positions(bodies, n, dt, i) {
    if i >= n {
        bodies
    } else {
        let b = get_body(bodies, i)
        let new_b = Body {
            x: b.x + dt * b.vx,
            y: b.y + dt * b.vy,
            z: b.z + dt * b.vz,
            vx: b.vx, vy: b.vy, vz: b.vz,
            mass: b.mass
        }
        let new_bodies = set_body(bodies, i, new_b)
        advance_positions(new_bodies, n, dt, i + 1)
    }
}

fn energy(bodies, n) {
    energy_loop(bodies, n, 0, 0.0)
}

fn energy_loop(bodies, n, i, e) {
    if i >= n {
        e
    } else {
        let b = get_body(bodies, i)
        let ke = 0.5 * b.mass * (b.vx * b.vx + b.vy * b.vy + b.vz * b.vz)
        let pe = potential_energy(bodies, n, i, i + 1, 0.0)
        energy_loop(bodies, n, i + 1, e + ke - pe)
    }
}

fn potential_energy(bodies, n, i, j, e) {
    if j >= n {
        e
    } else {
        let bi = get_body(bodies, i)
        let bj = get_body(bodies, j)
        let dx = bi.x - bj.x
        let dy = bi.y - bj.y
        let dz = bi.z - bj.z
        let distance = sqrt(dx * dx + dy * dy + dz * dz)
        potential_energy(bodies, n, i, j + 1, e + (bi.mass * bj.mass) / distance)
    }
}

fn run_simulation(bodies, n, steps, dt) {
    if steps <= 0 {
        bodies
    } else {
        let new_bodies = advance(bodies, n, dt)
        run_simulation(new_bodies, n, steps - 1, dt)
    }
}

fn run(n) {
    let sun_init = sun()
    let bodies_init = Bodies {
        b0: sun_init,
        b1: jupiter(),
        b2: saturn(),
        b3: uranus(),
        b4: neptune()
    }

    // Offset sun's momentum
    let sun_offset = offset_momentum(sun_init, bodies_init, 5)
    let bodies = set_body(bodies_init, 0, sun_offset)

    println(energy(bodies, 5))

    let final_bodies = run_simulation(bodies, 5, n, 0.01)

    println(energy(final_bodies, 5))
}

fn main(args) {
    let n = if length(args) > 0 { to_number(get(args, 0)) } else { 1000 }
    run(n)
}

// Expect
// -0.16907516382852442
// -0.16908760523460603
// -0.16908760523460603
