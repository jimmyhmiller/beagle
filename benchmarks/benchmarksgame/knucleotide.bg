namespace knucleotide

// The Computer Language Benchmarks Game
// https://salsa.debian.org/benchmarksgame-team/benchmarksgame/
//
// Beagle implementation - optimized with mutable hash table

import "beagle.ffi" as ffi
import "beagle.io" as io
import "beagle.builtin" as builtin
import "raw_mutable_array" as arr

let READ_CHUNK = 65536
let INITIAL_SEQ_SIZE = 1048576

// Hash table constants
let HT_KEYS = 0
let HT_COUNTS = 1
let HT_SIZE = 2
let HT_CAPACITY = 3

// Create a new hash table
fn new_hash_table(capacity) {
    let ht = arr/new_array(4)
    arr/write_field(ht, HT_KEYS, arr/new_array(capacity))
    arr/write_field(ht, HT_COUNTS, arr/new_array(capacity))
    arr/write_field(ht, HT_SIZE, 0)
    arr/write_field(ht, HT_CAPACITY, capacity)
    ht
}

// Hash a string to get bucket index
fn hash_string(s, capacity) {
    let h = builtin/hash(s)
    // Make sure it's positive
    let h2 = if h < 0 { 0 - h } else { h }
    h2 - (h2 / capacity) * capacity
}

// Find or insert a key, increment count
fn ht_increment(ht, key) {
    let keys = arr/read_field(ht, HT_KEYS)
    let counts = arr/read_field(ht, HT_COUNTS)
    let capacity = arr/read_field(ht, HT_CAPACITY)

    let idx = hash_string(key, capacity)
    ht_probe_and_increment(ht, keys, counts, capacity, key, idx, 0)
}

let DEBUG_COUNT_REF = 0

fn ht_probe_and_increment(ht, keys, counts, capacity, key, idx, probes) {
    if probes >= capacity {
        null
    } else {
        let existing_key = arr/read_field(keys, idx)
        if existing_key == null {
            arr/write_field(keys, idx, key)
            arr/write_field(counts, idx, 1)
            let size = arr/read_field(ht, HT_SIZE)
            arr/write_field(ht, HT_SIZE, size + 1)
            null
        } else {
            let are_equal = existing_key == key
            // Debug FAILED comparison
            if are_equal == false {
                let size = arr/read_field(ht, HT_SIZE)
                if size < 20 {
                    println("MISMATCH at size:")
                    println(size)
                    println("existing:")
                    println(existing_key)
                    println("new:")
                    println(key)
                    println("probes:")
                    println(probes)
                }
            }
            if are_equal {
                let count = arr/read_field(counts, idx)
                arr/write_field(counts, idx, count + 1)
                null
            } else {
                let next_idx = idx + 1
                let wrapped_idx = if next_idx >= capacity { 0 } else { next_idx }
                ht_probe_and_increment(ht, keys, counts, capacity, key, wrapped_idx, probes + 1)
            }
        }
    }
}

// Get count for a key
fn ht_get(ht, key) {
    let keys = arr/read_field(ht, HT_KEYS)
    let counts = arr/read_field(ht, HT_COUNTS)
    let capacity = arr/read_field(ht, HT_CAPACITY)

    let idx = hash_string(key, capacity)
    ht_probe_get(keys, counts, capacity, key, idx, 0)
}

fn ht_probe_get(keys, counts, capacity, key, idx, probes) {
    if probes >= capacity {
        0
    } else {
        let existing_key = arr/read_field(keys, idx)
        if existing_key == null {
            0
        } else {
            if existing_key == key {
                arr/read_field(counts, idx)
            } else {
                let next_idx = idx + 1
                let wrapped_idx = if next_idx >= capacity { 0 } else { next_idx }
                ht_probe_get(keys, counts, capacity, key, wrapped_idx, probes + 1)
            }
        }
    }
}

// Collect all key-count pairs from hash table
fn ht_entries(ht) {
    let keys = arr/read_field(ht, HT_KEYS)
    let counts = arr/read_field(ht, HT_COUNTS)
    let capacity = arr/read_field(ht, HT_CAPACITY)
    let size = arr/read_field(ht, HT_SIZE)

    println("ht_entries: capacity=")
    println(capacity)
    println("ht_entries: size=")
    println(size)

    // Create result array: each entry is [key, count]
    let result = arr/new_array(size)
    ht_collect_entries(keys, counts, capacity, result, 0, 0)
    result
}

fn ht_collect_entries(keys, counts, capacity, result, src_idx, dest_idx) {
    if src_idx >= capacity {
        null
    } else {
        let key = arr/read_field(keys, src_idx)
        if key == null {
            ht_collect_entries(keys, counts, capacity, result, src_idx + 1, dest_idx)
        } else {
            let count = arr/read_field(counts, src_idx)
            let pair = arr/new_array(2)
            arr/write_field(pair, 0, key)
            arr/write_field(pair, 1, count)
            arr/write_field(result, dest_idx, pair)
            ht_collect_entries(keys, counts, capacity, result, src_idx + 1, dest_idx + 1)
        }
    }
}

// Sort entries by count (descending), then by key (ascending)
fn sort_entries(entries) {
    let len = arr/count(entries)
    bubble_sort(entries, len)
}

fn bubble_sort(entries, len) {
    bubble_sort_outer(entries, len, 0)
}

fn bubble_sort_outer(entries, len, i) {
    if i >= len - 1 {
        entries
    } else {
        bubble_sort_inner(entries, len - 1 - i, 0)
        bubble_sort_outer(entries, len, i + 1)
    }
}

fn bubble_sort_inner(entries, limit, j) {
    if j >= limit {
        null
    } else {
        let p1 = arr/read_field(entries, j)
        let p2 = arr/read_field(entries, j + 1)
        let k1 = arr/read_field(p1, 0)
        let k2 = arr/read_field(p2, 0)
        let c1 = arr/read_field(p1, 1)
        let c2 = arr/read_field(p2, 1)

        let should_swap = if c1 < c2 {
            true
        } else {
            if c1 > c2 {
                false
            } else {
                // Same count - compare keys (ascending)
                k2 < k1
            }
        }

        if should_swap {
            arr/write_field(entries, j, p2)
            arr/write_field(entries, j + 1, p1)
        }
        bubble_sort_inner(entries, limit, j + 1)
    }
}

// State for reading sequence
let STATE_SEQ = 0
let STATE_READING = 1

fn new_read_state() {
    let state = arr/new_array(2)
    arr/write_field(state, STATE_SEQ, "")
    arr/write_field(state, STATE_READING, false)
    state
}

// Process a chunk of input
fn process_chunk(state, chunk) {
    let lines = split_lines(chunk)
    let num_lines = arr/count(lines)
    process_lines(state, lines, 0, num_lines)
}

fn split_lines(s) {
    let len = length(s)
    if len == 0 {
        arr/new_array(0)
    } else {
        // Count newlines to determine number of lines
        let newline_count = count_newlines(s, 0, len, 0)
        // If string doesn't end with newline, there's one more line
        let last_char = get(s, len - 1)
        let line_count = if last_char == "\n" { newline_count } else { newline_count + 1 }
        let result = arr/new_array(line_count)
        split_lines_into(s, 0, len, result, 0)
        result
    }
}

fn count_newlines(s, i, len, count) {
    if i >= len {
        count
    } else {
        let ch = get(s, i)
        if ch == "\n" {
            count_newlines(s, i + 1, len, count + 1)
        } else {
            count_newlines(s, i + 1, len, count)
        }
    }
}

fn split_lines_into(s, start, len, result, line_idx) {
    if start >= len {
        null
    } else {
        let end = find_newline(s, start, len)
        let line = substring(s, start, end - start)
        arr/write_field(result, line_idx, line)
        split_lines_into(s, end + 1, len, result, line_idx + 1)
    }
}

fn find_newline(s, i, len) {
    if i >= len {
        len
    } else {
        let ch = get(s, i)
        if ch == "\n" {
            i
        } else {
            find_newline(s, i + 1, len)
        }
    }
}

fn process_lines(state, lines, i, num_lines) {
    if i >= num_lines {
        null
    } else {
        let line = arr/read_field(lines, i)
        let reading = arr/read_field(state, STATE_READING)

        if reading {
            let line_len = length(line)
            if line_len > 0 {
                let first = get(line, 0)
                if first == ">" {
                    // End of sequence
                    null
                } else {
                    // Append uppercase line to sequence
                    let seq = arr/read_field(state, STATE_SEQ)
                    let upper_line = uppercase(line)
                    arr/write_field(state, STATE_SEQ, seq ++ upper_line)
                    process_lines(state, lines, i + 1, num_lines)
                }
            } else {
                process_lines(state, lines, i + 1, num_lines)
            }
        } else {
            // Looking for >THREE
            let line_len = length(line)
            if line_len >= 6 {
                let prefix = substring(line, 0, 6)
                if prefix == ">THREE" {
                    arr/write_field(state, STATE_READING, true)
                }
            }
            process_lines(state, lines, i + 1, num_lines)
        }
    }
}

// Read all input and extract the THREE sequence
fn read_sequence() {
    let state = new_read_state()
    read_loop(state)
    arr/read_field(state, STATE_SEQ)
}

fn read_loop(state) {
    let result = io/read_stdin_string(READ_CHUNK)
    match result {
        io/Result.Ok { value } => {
            if length(value) == 0 {
                null
            } else {
                process_chunk(state, value)
                // Check if we're done (found a > after >THREE)
                let reading = arr/read_field(state, STATE_READING)
                if reading {
                    read_loop(state)
                } else {
                    read_loop(state)
                }
            }
        },
        io/Result.Err { code, message } => {
            null
        }
    }
}

// Count all k-mers of given length
fn count_kmers(seq, k) {
    let len = length(seq)
    let n = len - k + 1
    // Use a hash table with capacity = 2 * expected unique kmers
    // For DNA with 4 letters, max unique k-mers is 4^k
    // But we'll use a simpler heuristic: capacity = n / 2 for small k
    let capacity = if n < 100 { 64 } else { n }
    let ht = new_hash_table(capacity)
    count_kmers_loop(seq, k, n, ht, 0)
    ht
}

fn count_kmers_loop(seq, k, n, ht, i) {
    if i >= n {
        null
    } else {
        let kmer = substring(seq, i, k)
        ht_increment(ht, kmer)
        count_kmers_loop(seq, k, n, ht, i + 1)
    }
}

// Print frequency percentage with 3 decimal places
fn print_percent(count, total) {
    let pct = ((count * 100000) + (total / 2)) / total
    let int_part = pct / 1000
    let frac_part = pct - int_part * 1000
    print(int_part)
    print(".")
    print_frac(frac_part)
}

fn print_frac(n) {
    if n < 10 {
        print("00")
        print(n)
    } else {
        if n < 100 {
            print("0")
            print(n)
        } else {
            print(n)
        }
    }
}

// Print frequency table
fn print_freq_table(entries, total) {
    let len = arr/count(entries)
    print_freq_loop(entries, total, 0, len)
}

fn print_freq_loop(entries, total, i, len) {
    if i >= len {
        null
    } else {
        let pair = arr/read_field(entries, i)
        let key = arr/read_field(pair, 0)
        let count = arr/read_field(pair, 1)
        print(key)
        print(" ")
        print_percent(count, total)
        println("")
        print_freq_loop(entries, total, i + 1, len)
    }
}

// Print count for a specific sequence
fn print_count(seq, ht) {
    let c = ht_get(ht, seq)
    print(c)
    print("\t")
    println(seq)
}

fn main() {
    // Read the sequence
    let seq = read_sequence()
    let len = length(seq)

    // Debug
    println("Sequence length:")
    println(len)

    println("First 20 chars:")
    println(substring(seq, 0, 20))

    println("Testing a few substrings:")
    let s1 = substring(seq, 0, 1)
    let s2 = substring(seq, 1, 1)
    let s3 = substring(seq, 100, 1)
    println(s1)
    println(s2)
    println(s3)
    println("s1 == s3?")
    println(s1 == s3)

    // 1-mer frequencies
    let ht1 = count_kmers(seq, 1)
    println("Hash table created")
    let entries1 = ht_entries(ht1)
    println("Entries:")
    println(entries1)
    println("Entries count:")
    println(arr/count(entries1))
    sort_entries(entries1)
    print_freq_table(entries1, len)
    println("")

    // 2-mer frequencies
    let ht2 = count_kmers(seq, 2)
    let entries2 = ht_entries(ht2)
    sort_entries(entries2)
    print_freq_table(entries2, len - 1)
    println("")

    // Specific sequence counts
    let ht3 = count_kmers(seq, 3)
    print_count("GGT", ht3)

    let ht4 = count_kmers(seq, 4)
    print_count("GGTA", ht4)

    let ht6 = count_kmers(seq, 6)
    print_count("GGTATT", ht6)

    let ht12 = count_kmers(seq, 12)
    print_count("GGTATTTTAATT", ht12)

    let ht18 = count_kmers(seq, 18)
    print_count("GGTATTTTAATTTATAGT", ht18)

    ""
}
