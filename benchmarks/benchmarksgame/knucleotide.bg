namespace knucleotide

// The Computer Language Benchmarks Game
// https://salsa.debian.org/benchmarksgame-team/benchmarksgame/
//
// Beagle implementation - optimized with builtin mutable hash map

use beagle.ffi as ffi
use beagle.io as io
use beagle.builtin as builtin
use beagle.collections as c
use raw-mutable-array as arr

let READ_CHUNK = 65536

// Sort entries by count (descending), then by key (ascending)
fn sort_entries(entries) {
    let len = arr/count(entries)
    bubble_sort(entries, len)
}

fn bubble_sort(entries, len) {
    bubble_sort_outer(entries, len, 0)
}

fn bubble_sort_outer(entries, len, i) {
    if i >= len - 1 {
        entries
    } else {
        bubble_sort_inner(entries, len - 1 - i, 0)
        bubble_sort_outer(entries, len, i + 1)
    }
}

fn bubble_sort_inner(entries, limit, j) {
    if j >= limit {
        null
    } else {
        let p1 = arr/read-field(entries, j)
        let p2 = arr/read-field(entries, j + 1)
        let k1 = arr/read-field(p1, 0)
        let k2 = arr/read-field(p2, 0)
        let c1 = arr/read-field(p1, 1)
        let c2 = arr/read-field(p2, 1)

        let should_swap = if c1 < c2 {
            true
        } else {
            if c1 > c2 {
                false
            } else {
                // Same count - compare keys (ascending)
                k2 < k1
            }
        }

        if should_swap {
            arr/write-field(entries, j, p2)
            arr/write-field(entries, j + 1, p1)
        }
        bubble_sort_inner(entries, limit, j + 1)
    }
}

// Read all input and extract the THREE sequence
// Accumulates lines into a list, then joins once at the end to avoid O(n^2) concat
fn read_sequence() {
    // Growable array of lines: [lines_array, count, capacity]
    let lines_cap = 1024
    let state = arr/new-array(4)
    arr/write-field(state, 0, arr/new-array(lines_cap)) // lines
    arr/write-field(state, 1, 0)     // count
    arr/write-field(state, 2, lines_cap) // capacity
    arr/write-field(state, 3, false) // reading flag

    read_loop(state)

    // Join all collected lines into one string
    let lines = arr/read-field(state, 0)
    let count = arr/read-field(state, 1)

    // Calculate total length
    let mut total_len = 0
    let mut i = 0
    while i < count {
        total_len = total_len + length(arr/read-field(lines, i))
        i = i + 1
    }

    // Build result by concatenating into a buffer
    let buf = ffi/allocate(total_len)
    let mut pos = 0
    i = 0
    while i < count {
        let line = arr/read-field(lines, i)
        let line_len = length(line)
        let mut j = 0
        while j < line_len {
            let ch = get(line, j)
            let byte = builtin/char-code(ch)
            ffi/set-u8(buf, pos, byte)
            pos = pos + 1
            j = j + 1
        }
        i = i + 1
    }

    // Convert buffer back to string
    let result = ffi/get-string(buf, 0, total_len)
    ffi/deallocate(buf)
    result
}

fn add_line(state, line) {
    let lines = arr/read-field(state, 0)
    let count = arr/read-field(state, 1)
    let capacity = arr/read-field(state, 2)

    // Grow if needed
    if count >= capacity {
        let new_cap = capacity * 2
        let new_lines = arr/new-array(new_cap)
        let mut i = 0
        while i < count {
            arr/write-field(new_lines, i, arr/read-field(lines, i))
            i = i + 1
        }
        arr/write-field(state, 0, new_lines)
        arr/write-field(state, 2, new_cap)
        arr/write-field(new_lines, count, line)
    } else {
        arr/write-field(lines, count, line)
    }
    arr/write-field(state, 1, count + 1)
}

fn read_loop(state) {
    let result = io/read-stdin-string(READ_CHUNK)
    match result {
        Result.Ok { value } => {
            if length(value) == 0 {
                null
            } else {
                process_chunk(state, value)
                read_loop(state)
            }
        },
        Result.Err { error } => {
            null
        }
    }
}

fn process_chunk(state, chunk) {
    let len = length(chunk)
    let mut i = 0
    let mut line_start = 0

    while i < len {
        let ch = get(chunk, i)
        if ch == "\n" {
            if i > line_start {
                process_line(state, chunk, line_start, i - line_start)
            }
            line_start = i + 1
        }
        i = i + 1
    }
    // Handle last line without newline
    if line_start < len {
        process_line(state, chunk, line_start, len - line_start)
    }
}

fn process_line(state, chunk, start, line_len) {
    let reading = arr/read-field(state, 3)
    if reading {
        let first = get(chunk, start)
        if first == ">" {
            // End of sequence - stop reading
            arr/write-field(state, 3, false)
        } else {
            let line = uppercase(substring(chunk, start, line_len))
            add_line(state, line)
        }
    } else {
        if line_len >= 6 {
            let prefix = substring(chunk, start, 6)
            if prefix == ">THREE" {
                arr/write-field(state, 3, true)
            }
        }
    }
}

// Power of 4
fn pow4(k) {
    let mut result = 1
    let mut i = 0
    while i < k {
        result = result * 4
        i = i + 1
    }
    result
}

// Count all k-mers of given length using builtin mutable map
fn count_kmers(seq, k) {
    let len = length(seq)
    let n = len - k + 1
    // Capacity based on expected unique kmers
    let max_unique = pow4(k)
    let capacity = if max_unique * 4 < n * 2 { max_unique * 4 } else { n * 2 }
    let ht = c/mutable-map-with-capacity(capacity)
    let mut i = 0
    while i < n {
        let kmer = substring(seq, i, k)
        c/mutable-map-increment!(ht, kmer)
        i = i + 1
    }
    ht
}

// Print frequency percentage with 3 decimal places
fn print_percent(count, total) {
    let pct = ((count * 100000) + (total / 2)) / total
    let int_part = pct / 1000
    let frac_part = pct - int_part * 1000
    print(int_part)
    print(".")
    print_frac(frac_part)
}

fn print_frac(n) {
    if n < 10 {
        print("00")
        print(n)
    } else {
        if n < 100 {
            print("0")
            print(n)
        } else {
            print(n)
        }
    }
}

// Print frequency table
fn print_freq_table(entries, total) {
    let len = arr/count(entries)
    print_freq_loop(entries, total, 0, len)
}

fn print_freq_loop(entries, total, i, len) {
    if i >= len {
        null
    } else {
        let pair = arr/read-field(entries, i)
        let key = arr/read-field(pair, 0)
        let count = arr/read-field(pair, 1)
        print(key)
        print(" ")
        print_percent(count, total)
        println("")
        print_freq_loop(entries, total, i + 1, len)
    }
}

// Print count for a specific sequence
fn print_count(seq, ht) {
    let v = c/mutable-map-get(ht, seq)
    let c = if v == null { 0 } else { v }
    print(c)
    print("\t")
    println(seq)
}

fn main() {
    let seq = read_sequence()
    let len = length(seq)

    // 1-mer frequencies
    let ht1 = count_kmers(seq, 1)
    let entries1 = c/mutable-map-entries(ht1)
    sort_entries(entries1)
    print_freq_table(entries1, len)
    println("")

    // 2-mer frequencies
    let ht2 = count_kmers(seq, 2)
    let entries2 = c/mutable-map-entries(ht2)
    sort_entries(entries2)
    print_freq_table(entries2, len - 1)
    println("")

    // Specific sequence counts
    let ht3 = count_kmers(seq, 3)
    print_count("GGT", ht3)

    let ht4 = count_kmers(seq, 4)
    print_count("GGTA", ht4)

    let ht6 = count_kmers(seq, 6)
    print_count("GGTATT", ht6)

    let ht12 = count_kmers(seq, 12)
    print_count("GGTATTTTAATT", ht12)

    let ht18 = count_kmers(seq, 18)
    print_count("GGTATTTTAATTTATAGT", ht18)

    ""
}
