namespace fasta

// The Computer Language Benchmarks Game
// https://salsa.debian.org/benchmarksgame-team/benchmarksgame/
//
// Beagle implementation - fast buffered I/O version

import "beagle.ffi" as ffi
import "beagle.io" as io
import "beagle.builtin" as builtin
import "raw_mutable_array" as arr

let LINE_WIDTH = 60
let IM = 139968
let IA = 3877
let IC = 29573
let OUT_BUF_SIZE = 65536

// ALU sequence for repeat
let ALU = "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGACCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAATACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGGAGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCCAGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA"

// Convert ALU string to a byte buffer for fast access
fn make_alu_buffer() {
    let len = length(ALU)
    let buf = ffi/allocate(len)
    let mut i = 0
    while i < len {
        let char = get(ALU, i)
        let byte = builtin/char_code(char)
        ffi/set_u8(buf, i, byte)
        i = i + 1
    }
    buf
}

// Convert code string to byte buffer
fn make_codes_buffer(codes) {
    let len = length(codes)
    let buf = ffi/allocate(len)
    let mut i = 0
    while i < len {
        let char = get(codes, i)
        let byte = builtin/char_code(char)
        ffi/set_u8(buf, i, byte)
        i = i + 1
    }
    buf
}

// IUB cumulative probabilities (scaled to IM)
fn make_iub_probs() {
    let probs = arr/new_array(15)
    arr/write_field(probs, 0, 37792)
    arr/write_field(probs, 1, 54588)
    arr/write_field(probs, 2, 71384)
    arr/write_field(probs, 3, 109176)
    arr/write_field(probs, 4, 111975)
    arr/write_field(probs, 5, 114774)
    arr/write_field(probs, 6, 117574)
    arr/write_field(probs, 7, 120373)
    arr/write_field(probs, 8, 123172)
    arr/write_field(probs, 9, 125972)
    arr/write_field(probs, 10, 128771)
    arr/write_field(probs, 11, 131570)
    arr/write_field(probs, 12, 134370)
    arr/write_field(probs, 13, 137169)
    arr/write_field(probs, 14, 139969)
    probs
}

// Homo sapiens cumulative probabilities (scaled to IM)
fn make_homo_probs() {
    let probs = arr/new_array(4)
    arr/write_field(probs, 0, 42404)
    arr/write_field(probs, 1, 70117)
    arr/write_field(probs, 2, 97767)
    arr/write_field(probs, 3, 139968)
    probs
}

// Find code index using linear search
fn find_code_index(probs, probs_len, r) {
    let mut i = 0
    let mut found = false
    while i < probs_len && found == false {
        let p = arr/read_field(probs, i)
        if p > r {
            found = true
        } else {
            i = i + 1
        }
    }
    if i >= probs_len { probs_len - 1 } else { i }
}

// Write a header string to stdout
fn write_header(s) {
    let len = length(s)
    let buf = ffi/allocate(len + 1)
    let mut i = 0
    while i < len {
        let char = get(s, i)
        let byte = builtin/char_code(char)
        ffi/set_u8(buf, i, byte)
        i = i + 1
    }
    ffi/set_u8(buf, len, 10)  // newline
    io/write_stdout_buffer(buf, len + 1)
    ffi/deallocate(buf)
    null
}

// Write repeated ALU sequence with line wrapping
fn write_repeat_fasta(alu_buf, alu_len, size) {
    let out_buf = ffi/allocate(OUT_BUF_SIZE)
    let mut out_pos = 0
    let mut alu_idx = 0
    let mut remaining = size

    while remaining > 0 {
        let line_len = if remaining < LINE_WIDTH { remaining } else { LINE_WIDTH }

        // Check if we need to flush
        if out_pos + line_len + 1 > OUT_BUF_SIZE {
            io/write_stdout_buffer(out_buf, out_pos)
            out_pos = 0
        }

        // Write one line
        let mut col = 0
        while col < line_len {
            let byte = ffi/get_u8(alu_buf, alu_idx)
            ffi/set_u8(out_buf, out_pos, byte)
            out_pos = out_pos + 1
            alu_idx = alu_idx + 1
            if alu_idx >= alu_len {
                alu_idx = 0
            }
            col = col + 1
        }

        // Add newline
        ffi/set_u8(out_buf, out_pos, 10)
        out_pos = out_pos + 1

        remaining = remaining - line_len
    }

    // Flush remaining
    if out_pos > 0 {
        io/write_stdout_buffer(out_buf, out_pos)
    }

    ffi/deallocate(out_buf)
    null
}

// Write random sequence with line wrapping
// Returns the final seed value
fn write_random_fasta(codes_buf, probs, probs_len, size, seed, add_final_newline) {
    let out_buf = ffi/allocate(OUT_BUF_SIZE)
    let mut out_pos = 0
    let mut remaining = size
    let mut current_seed = seed

    while remaining > 0 {
        let line_len = if remaining < LINE_WIDTH { remaining } else { LINE_WIDTH }

        // Check if we need to flush
        if out_pos + line_len + 1 > OUT_BUF_SIZE {
            io/write_stdout_buffer(out_buf, out_pos)
            out_pos = 0
        }

        // Write one line
        let mut col = 0
        while col < line_len {
            // Generate next random number
            current_seed = (current_seed * IA + IC) - ((current_seed * IA + IC) / IM) * IM
            let idx = find_code_index(probs, probs_len, current_seed)
            let byte = ffi/get_u8(codes_buf, idx)
            ffi/set_u8(out_buf, out_pos, byte)
            out_pos = out_pos + 1
            col = col + 1
        }

        // Add newline (except possibly for last line)
        remaining = remaining - line_len
        if remaining > 0 || add_final_newline {
            ffi/set_u8(out_buf, out_pos, 10)
            out_pos = out_pos + 1
        }
    }

    // Flush remaining
    if out_pos > 0 {
        io/write_stdout_buffer(out_buf, out_pos)
    }

    ffi/deallocate(out_buf)
    current_seed
}

fn run(n) {
    // Prepare ALU buffer
    let alu_buf = make_alu_buffer()
    let alu_len = length(ALU)

    // ONE: repeat ALU
    write_header(">ONE Homo sapiens alu")
    write_repeat_fasta(alu_buf, alu_len, n * 2)

    // TWO: IUB random
    let iub_codes = make_codes_buffer("acgtBDHKMNRSVWY")
    let iub_probs = make_iub_probs()
    write_header(">TWO IUB ambiguity codes")
    let seed2 = write_random_fasta(iub_codes, iub_probs, 15, n * 3, 42, true)

    // THREE: Homo sapiens random
    let homo_codes = make_codes_buffer("acgt")
    let homo_probs = make_homo_probs()
    write_header(">THREE Homo sapiens frequency")
    write_random_fasta(homo_codes, homo_probs, 4, n * 5, seed2, false)

    // Cleanup
    ffi/deallocate(alu_buf)
    ffi/deallocate(iub_codes)
    ffi/deallocate(homo_codes)

    ""
}

fn main(args) {
    let n = if length(args) > 0 { to_number(get(args, 0)) } else { 10 }
    run(n)
    ""
}

// Expect
// >ONE Homo sapiens alu
// GGCCGGGCGCGGTGGCTCAC
// >TWO IUB ambiguity codes
// cttBtatcatatgctaKggNcataaaSatg
// >THREE Homo sapiens frequency
// taaatcttgtgcttcgttagaagtctcgactacgtgtagcctagtgtttg
